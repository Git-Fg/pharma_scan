// integration_test/helpers/golden_db_helper.dart

import 'dart:io';
import 'dart:math';

import 'package:drift/native.dart';
import 'package:path/path.dart' as p;
import 'package:pharma_scan/core/database/database.dart';
import 'package:pharma_scan/core/logic/sanitizer.dart';
import 'package:sqlite3/common.dart';

/// Configure SQLite avec les optimisations et fonctions personnalis√©es.
/// This is only used in tests/integration tests (native platform only).
void configureAppSQLite(CommonDatabase database) {
  database
    ..execute('PRAGMA journal_mode=WAL')
    ..execute('PRAGMA busy_timeout=30000')
    ..execute('PRAGMA synchronous=NORMAL')
    ..execute('PRAGMA mmap_size=300000000')
    ..execute('PRAGMA temp_store=MEMORY')
    ..createFunction(
      functionName: 'normalize_text',
      argumentCount: const AllowedArgumentCount(1),
      deterministic: true,
      directOnly: false,
      function: (List<Object?> args) {
        final source = args.isEmpty ? '' : args.first?.toString() ?? '';
        if (source.isEmpty) return '';
        return normalizeForSearch(source);
      },
    );
}

/// WHY: Implements the "Thin Client" architecture for integration tests.
/// Instead of manually seeding tables with potentially outdated SQL,
/// we load a pre-populated "golden" database artifact from the backend.
///
/// This ensures:
/// 1. Schema consistency - The golden DB is built by the same backend that
///    builds production DBs, so schema is always correct.
/// 2. Realistic data - Tests run against real-world data structures.
/// 3. No test fragility - No hardcoded SQL strings to maintain.

/// Loads the golden database artifact for integration testing.
///
/// This function:
/// 1. Locates the golden.db file at `test/assets/golden.db`
/// 2. Creates a unique temporary copy to avoid file locking issues
/// 3. Returns an AppDatabase instance connected to this copy
///
/// Usage:
/// ```dart
/// late AppDatabase db;
///
/// setUp(() async {
///   db = await loadGoldenDatabase();
/// });
///
/// tearDown(() async {
///   await db.close();
/// });
/// ```
Future<AppDatabase> loadGoldenDatabase() async {
  // Locate the golden database source file
  final goldenDbPath = _resolveGoldenDbPath();
  final sourceFile = File(goldenDbPath);

  if (!sourceFile.existsSync()) {
    throw StateError(
      'Golden database not found at: $goldenDbPath\n'
      'Please ensure test/assets/golden.db exists.\n'
      'This file should be generated by the backend pipeline.',
    );
  }

  // Create a unique temporary copy to avoid SQLite locking issues
  // when running multiple tests in parallel
  final tempDir = await Directory.systemTemp.createTemp('pharma_integration_');
  final timestamp = DateTime.now().millisecondsSinceEpoch;
  final randomSuffix = Random().nextInt(10000);
  final tempDbPath = p.join(
    tempDir.path,
    'golden_${timestamp}_$randomSuffix.db',
  );

  // Copy the golden database bytes to the temp location
  await sourceFile.copy(tempDbPath);

  // Initialize NativeDatabase with the temp copy
  final nativeDb = NativeDatabase(
    File(tempDbPath),
    setup: configureAppSQLite,
  );

  return AppDatabase.forTesting(nativeDb);
}

/// Resolves the path to the golden database file.
///
/// Integration tests run from the project root, so we look for the file
/// at `test/assets/golden.db` relative to the current working directory.
String _resolveGoldenDbPath() {
  final cwd = Directory.current.path;

  // Standard path for integration tests run from project root
  final standardPath = p.join(cwd, 'test', 'assets', 'golden.db');
  if (File(standardPath).existsSync()) {
    return standardPath;
  }

  // Fallback: integration_test relative path (for certain test runners)
  final integrationPath = p.join(cwd, '..', 'test', 'assets', 'golden.db');
  if (File(integrationPath).existsSync()) {
    return integrationPath;
  }

  // Return standard path for error message clarity
  return standardPath;
}
