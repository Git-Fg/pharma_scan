---
paths:
  - "lib/core/database/**/*"
  - "lib/core/**/*"
  - "**/*.drift"
---

# Database Rules for PharmaScan

## Overview

PharmaScan uses a **Dual Database Architecture** with Drift (SQLite):
- **`reference.db`**: Read-only BDPM medication data downloaded from backend
- **`user.db`**: Local user data (restock items, scan history, settings)

Both databases are accessed transparently via SQLite `ATTACH DATABASE`.

## Drift Schema Patterns

### Table Definitions
- Define reference tables in `reference_schema.drift` (read from attached DB)
- Define user tables in `user_schema.drift` (created locally)
- Use `STRICT` tables for type safety (override `isStrict => true` in Dart, or use `STRICT` keyword in SQL)
- Use `CHECK` constraints for boolean columns (0/1)

**Idiomatic Drift approach:**
```dart
class MedicamentSummary extends Table {
  @override
  bool get isStrict => true;

  Text('cis_code', primaryKey: true);
  Bool('isPrinceps')();
}
```

**SQL approach (for reference schema):**
```drift
CREATE TABLE medicament_summary (
  cis_code TEXT PRIMARY KEY NOT NULL,
  is_princeps INTEGER NOT NULL DEFAULT 0 CHECK(is_princeps IN(0, 1)),
  ...
) STRICT;
```

### Generated Columns
Use for computed values like CIP7 derived from CIP13:
```drift
cip7 TEXT GENERATED ALWAYS AS (SUBSTR(cip_code, 6, 7)) STORED,
```

### Include Files in Database
```dart
@DriftDatabase(
  include: {
    'reference_schema.drift',
    'user_schema.drift',
    'queries.drift',
    'restock_views.drift'
  },
  tables: [AppSettings],
  daos: [CatalogDao, RestockDao, ExplorerDao],
)
class AppDatabase extends $AppDatabase { ... }
```

## Dual Database Pattern

### Connection Setup (Native)
Located in `lib/core/database/connection/native.dart`:

**Modern Pattern (Drift 2.20+):**
```dart
QueryExecutor openConnection(LoggerService logger, {String? path}) {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final userDbFile = File(p.join(dbFolder.path, 'user.db'));
    final referenceDbFile = File(p.join(dbFolder.path, 'reference.db'));

    // Use createInBackground for better performance (Drift 2.20+)
    return NativeDatabase.createInBackground(
      userDbFile,
      setup: (database) {
        try {
          database.execute(
            "ATTACH DATABASE '${referenceDbFile.path}' AS reference_db"
          );
        } catch (e) {
          logger.error('Failed to attach reference database', e);
          rethrow;
        }
      },
    );
  });
}
```

**Alternative with isolate sharing (Drift 2.20+):**
```dart
@DriftDatabase(/* ... */)
class AppDatabase extends $AppDatabase {
  AppDatabase.defaults() : super(
    driftDatabase(
      name: 'app_db',
      native: DriftNativeOptions(
        shareAcrossIsolates: true,  // Enable for background processing
      ),
    ),
  );
}
```

### Key Points
1. Open `user.db` as the primary connection
2. Attach `reference.db` with alias `reference_db`
3. Reference tables are queried via `reference_db.table_name` prefix
4. User tables are queried directly (no prefix needed)

### Cross-Database Queries
```sql
-- Join user scanned_boxes with reference medicament data
SELECT sb.cip_code, ms.nom_canonique
FROM scanned_boxes sb
LEFT JOIN medicaments m ON m.cip_code = sb.cip_code
LEFT JOIN medicament_summary ms ON ms.cis_code = m.cis_code
```

### NEVER Modify Reference Schema
> **Critical**: The `reference.db` schema is generated by the backend pipeline.
> Any schema change must be synchronized with `backend_pipeline/src/db.ts`.

## DAO Pattern

### DAO Structure
- One DAO per feature domain (Catalog, Restock, Explorer)
- Extend `DatabaseAccessor<AppDatabase>`
- Mark class with `@DriftAccessor()`

```dart
@DriftAccessor()
class CatalogDao extends DatabaseAccessor<AppDatabase> {
  CatalogDao(super.attachedDatabase);

  Future<ScanResult?> getProductByCip(Cip13 codeCip) async { ... }
}
```

### Export as Singleton
All DAOs are exported from `database.dart` and accessed via `database.catalogDao`.

### Use TableManager API (Drift 2.18+)
Prefer the managers API for CRUD operations:

```dart
// Access managers via database.managers (not attachedDatabase)
await database.managers.productScanCache
    .filter((f) => f.cipCode.equals(cipString))
    .getSingleOrNull();

// For writes
await database.managers.restockItems
    .filter((f) => f.cipCode.equals(cipString))
    .update((c) => c(stockCount: Value(newCount)));
```

### Custom Queries in drift Files
Define complex queries in `.drift` files using generated methods:

```drift
-- In queries.drift
getScanHistory:
SELECT
    sb.cip_code AS cip,
    datetime(sb.scan_timestamp) AS scanned_at,
    COALESCE(ms.nom_canonique, 'Produit inconnu') AS label
FROM scanned_boxes sb
LEFT JOIN medicaments m ON m.cip_code = sb.cip_code
LEFT JOIN medicament_summary ms ON ms.cis_code = m.cis_code
ORDER BY sb.scan_timestamp DESC
LIMIT :limit;
```

## FTS5 Integration

### Virtual Table for Full-Text Search
Located in `reference_schema.drift`:

```sql
CREATE VIRTUAL TABLE search_index USING fts5(
  cluster_id UNINDEXED,
  search_vector,
  tokenize = 'trigram'
);
```

### Search Query Pattern
```sql
SELECT ci.*
FROM cluster_index ci
INNER JOIN search_index si ON si.cluster_id = ci.cluster_id
WHERE search_index MATCH ?
ORDER BY si.rowid
LIMIT 50;
```

### Trigram Tokenizer
- Use `tokenize = 'trigram'` for fuzzy matching
- Better for French medication names
- Handles partial word matches

## Schema Contract

### Generated Type Constants
Use `lib/core/database/generated/generated_types.dart` for backend-synchronized type constants:

```dart
// Auto-generated from backend/types.json
const Map<String, String> kColumnExtensionTypes = {
  'cis_code': 'CisId',
  'cip_code': 'Cip13',
  'group_id': 'GroupId',
  'cluster_id': 'ClusterId',
};

const Map<String, String> kTableToEntityMap = {
  'cluster_index': 'ClusterIndexData',
  'medicament_summary': 'MedicamentSummary',
  'ui_group_details': 'GroupDetailEntity',
};
```

### Manual Schema Contract
Use `lib/core/database/schema_contract.dart` for additional compile-time type safety:

```dart
extension type SchemaTable(String _) {
  static const String medicamentSummary = 'medicament_summary';
  static const String productScanCache = 'product_scan_cache';
  static const String clusterIndex = 'cluster_index';
}

extension type BooleanColumn(String _) {
  static const String isPrinceps = 'is_princeps';
  static const String isNarcotic = 'is_narcotic';
}
```

### Validation Utilities
```dart
class SchemaContract {
  static bool hasTable(String tableName) { ... }
  static bool isBooleanColumn(String columnName) { ... }
  static String? getForeignKey(String tableName, String columnName) { ... }
}
```

## Performance Patterns

### Pre-computed UI Tables
Backend creates denormalized tables for performance:

- `ui_explorer_list`: Pre-joined cluster data for list views
- `ui_group_details`: Denormalized group membership data
- `ui_stats`: Pre-computed statistics

### Indexes
```sql
CREATE INDEX idx_medicament_summary_cluster_id ON medicament_summary(cluster_id);
CREATE INDEX idx_product_scan_cache_cip7 ON product_scan_cache(cip7);
CREATE INDEX idx_group_members_group_id ON group_members(group_id);
```

### WAL Mode and PRAGMAs
Set in `database.dart` migration strategy:

```dart
beforeOpen: (details) async {
  await customStatement('PRAGMA foreign_keys = ON');
  await customStatement('PRAGMA journal_mode=WAL');
  await customStatement('PRAGMA busy_timeout=30000');
  await customStatement('PRAGMA synchronous=NORMAL');
  await customStatement('PRAGMA mmap_size=300000000');
  await customStatement('PRAGMA temp_store=MEMORY');
},
```

## Error Handling

Use `SqlErrorX` extension for SQLite error detection:

```dart
try {
  await attachedDatabase.managers.scannedBoxes.create(...);
} catch (e) {
  if (e.isUniqueConstraintViolation()) {
    return .duplicate;
  }
  rethrow;
}
```

## Key Files

| File | Purpose |
|------|---------|
| `lib/core/database/database.dart` | Main database class with migration strategy |
| `lib/core/database/connection/native.dart` | SQLite connection with ATTACH DATABASE |
| `lib/core/database/generated/generated_types.dart` | **Backend-generated type constants** |
| `lib/core/database/generated/generated_queries.dart` | **Backend-generated query contracts** |
| `lib/core/database/generated/dao_references.dart` | **Reference implementations (copy to DAOs)** |
| `lib/core/database/schema_contract.dart` | Compile-time schema types |
| `lib/core/database/reference_schema.drift` | Reference DB schema definitions |
| `lib/core/database/user_schema.drift` | User DB schema definitions |
| `lib/core/database/queries.drift` | Complex query definitions |
| `lib/core/database/daos/catalog_dao.dart` | Medication lookup operations |
| `lib/core/database/daos/explorer_dao.dart` | Search and cluster operations |
| `lib/core/database/daos/restock_dao.dart` | Restock and scan history |
| `lib/core/database/utils/sql_error_x.dart` | SQLite error utilities |

## Code Generation

After schema changes, regenerate drift files:

```bash
dart run build_runner build --delete-conflicting-outputs
```

## References

- [Drift Documentation](https://drift.dev/docs/)
- [SQLite ATTACH DATABASE](https://www.sqlite.org/lang_attach.html)
- [FTS5 Extension](https://www.sqlite.org/fts5.html)
- [Drift TableManager API](https://drift.dev/docs/managed_table/)
- [SQLite STRICT Tables](https://www.sqlite.org/strict.html)
