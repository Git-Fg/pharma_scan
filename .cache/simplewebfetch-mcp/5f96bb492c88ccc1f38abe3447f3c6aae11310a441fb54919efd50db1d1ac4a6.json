{
  "url": "https://docs.objectbox.io/queries",
  "markdown": "# ObjectBox Queries | ObjectBox Docs\nbars[![](https://docs.objectbox.io/~gitbook/image?url=https%3A%2F%2F4174656640-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-LETufmyus5LFkviJjr4%252Favatar.png%3Fgeneration%3D1528453316288221%26alt%3Dmedia&width=32&dpr=3&quality=100&sign=96b28d45&sv=2)![](https://docs.objectbox.io/~gitbook/image?url=https%3A%2F%2F4174656640-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-LETufmyus5LFkviJjr4%252Favatar.png%3Fgeneration%3D1528453316288221%26alt%3Dmedia&width=32&dpr=3&quality=100&sign=96b28d45&sv=2)\nObjectBox Docs\n](https://docs.objectbox.io/)\nsearch\ncircle-xmark\n⌘Ctrlk\n[Home](https://objectbox.io/)[Blog](https://objectbox.io/blog/)[Twitter](https://twitter.com/ObjectBox_io)[GitHub](https://github.com/objectbox/objectbox-java)\nMoreellipsischevron-down\n[![](https://docs.objectbox.io/~gitbook/image?url=https%3A%2F%2F4174656640-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-LETufmyus5LFkviJjr4%252Favatar.png%3Fgeneration%3D1528453316288221%26alt%3Dmedia&width=32&dpr=3&quality=100&sign=96b28d45&sv=2)![](https://docs.objectbox.io/~gitbook/image?url=https%3A%2F%2F4174656640-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-LETufmyus5LFkviJjr4%252Favatar.png%3Fgeneration%3D1528453316288221%26alt%3Dmedia&width=32&dpr=3&quality=100&sign=96b28d45&sv=2)\nObjectBox Docs\n](https://docs.objectbox.io/)\n-   [ObjectBox Docs](https://docs.objectbox.io/)\n-   [Getting started](https://docs.objectbox.io/getting-started)\n-   [Tutorial: Demo Project](https://docs.objectbox.io/tutorial-demo-project)\n-   [Entity Annotations](https://docs.objectbox.io/entity-annotations)\n-   [Property Types](https://docs.objectbox.io/property-types)\n-   [Android (Java/Kotlin)chevron-right](https://docs.objectbox.io/android)\n-   [Desktop Apps](https://docs.objectbox.io/java-desktop-apps)\n-   [Kotlin Support](https://docs.objectbox.io/kotlin-support)\n-   [ObjectBox Queries](https://docs.objectbox.io/queries)\n-   [On-Device Vector Search](https://docs.objectbox.io/on-device-vector-search)\n-   [Data Observers & Rx](https://docs.objectbox.io/data-observers-and-rx)\n-   [Relations](https://docs.objectbox.io/relations)\n-   [ObjectBox Admin](https://docs.objectbox.io/data-browser)\n-   [Transactions](https://docs.objectbox.io/transactions)\n-   [Advancedchevron-right](https://docs.objectbox.io/advanced)\n-   [Changelogs](https://docs.objectbox.io/changelogs)\n-   [Java API referencearrow-up-right](https://objectbox.io/docfiles/java/current/)\n-   [Dart API referencearrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/objectbox-library.html)\n-   [Python API referencearrow-up-right](https://objectbox.io/docfiles/python/current/)\n-   [Binary Licensearrow-up-right](https://objectbox.io/0209-ob-binary-license/)\n-   [FAQ](https://docs.objectbox.io/faq)\n-   [Troubleshooting](https://docs.objectbox.io/troubleshooting)\n-   [Data Syncarrow-up-right](https://objectbox.io/sync/)\n-   [Swift Database for iOSarrow-up-right](https://swift.objectbox.io/)\n-   [C++ Database Docsarrow-up-right](https://cpp.objectbox.io/)\n-   [Java Release History (<= v1.5)](https://docs.objectbox.io/release-history)\nchevron-upchevron-down\n[gitbookPowered by GitBook](https://www.gitbook.com/?utm_source=content&utm_medium=trademark&utm_campaign=-LETufmyus5LFkviJjr4)\nxmark\nblock-quoteOn this pagechevron-down\ncopyCopychevron-down\n# ObjectBox Queries\nDiscover how to use the Query API to create queries with ObjectBox DB. By utilizing these queries, you can retrieve stored objects that meet user-defined criteria.\n##\n[hashtag](#build-a-query)\nBuild a query\nUse `box.query(condition)` and supply a `condition` on one or more properties to start building a query.\nCreate a `condition` by accessing a property via the underscore class of the entity, e.g. `User_.firstName.equal(\"Joe\")`.\nUse `build()` to create a re-usable query instance. To then retrieve all results use `find()` on the query. More options on retrieving results are discussed later in [Run a query](https://docs.objectbox.io/queries#run-a-query).\nOnce done, `close()` the query to clean up resources.\nHere is a full example to query for all users with the first name “Joe”:\nJava\nKotlin\nDart\nPython\nTypeScript\nCopy\n```\nQuery<User> query = userBox.query(User_.firstName.equal(\"Joe\")).build();\nList<User> joes = query.find();\nquery.close();\n```\nCopy\n```\nval query = userBox.query(User_.firstName.equal(\"Joe\")).build()\nval joes = query.find()\nquery.close()\n```\nCopy\n```\nQuery<User> query = userBox.query(User_.firstName.equals('Joe')).build();\nList<User> joes = query.find();\nquery.close();\n```\nCopy\n```\nquery = userBox.query(User.firstName.equals(\"Joe\")).build()\njoes = query.find()\n```\nCopy\n```\nconst query = userBox.query(User_.firstName.equals(\"Joe\")).build();\nconst joes = query.find();\nquery.close();\n```\n**To combine multiple conditions** use `and(condition)` and `or(condition)`. This implicitly adds parentheses around the combined conditions, e.g. `cond1.and(cond2)` is logically equivalent to `(cond1 AND cond2)`.\nFor example to get users with the first name “Joe” that are born later than 2015 and whose last name starts with “O”:\nJava\nKotlin\nDart\nPython\nTypeScript\nCopy\n```\nQuery<User> query = userBox.query(\n        User_.firstName.equal(\"Joe\")\n                .and(User_.yearOfBirth.greater(2015))\n                .and(User_.lastName.startsWith(\"O\"))\n).build();\nList<User> youngJoes = query.find();\nquery.close();\n```\nCopy\n```\nval query = userBox.query(\n    User_.firstName equal \"Joe\" and\n            (User_.yearOfBirth greater 2015) and\n            (User_.lastName startsWith \"O\")\n).build()\nval youngJoes = query.find()\nquery.close()\n```\nCopy\n```\nQuery<User> query = userBox\n    .query(User_.firstName.equals('Joe')\n        .and(User_.yearOfBirth.greaterThan(2015))\n        .and(User_.lastName.startsWith('O')))\n    .build();\n// or use operator overloads:\nQuery<User> query2 = userBox\n    .query(User_.firstName.equals('Joe') &\n        User_.yearOfBirth.greaterThan(2015) &\n        User_.lastName.startsWith('O'))\n    .build();\n```\nThis also makes it possible to **make a condition optional:**\nJava\nKotlin\nDart\nTypeScript\n**To nest conditions** pass a combined condition to `and()` or `or()`:\nJava\nKotlin\nDart\nPython\nTypeScript\ncircle-info\none\\_of is not yet available in Python.\n####\n[hashtag](#other-notable-features)\nOther notable features\n-   In Kotlin, instead of `condition1.and(condition2)` you can write ` condition1`` ` `**and**` ` ``condition2 ` (similarly ` condition1`` ` `**or**` ` ``condition2 `).\n-   In Dart and Python, instead of `condition1.and(condition2)` you can write ` condition1`` ` `**&**` ` ``condition2 ` (similarly ` condition1`` ` `**|**` ` ``conditon2 `).\n-   Use `condition.alias(aliasName)` to set an alias for a `condition` that can later be used to change the parameter value of the condition on the built query.\ncircle-info\n**TypeScript:** String conditions are **case-sensitive by default**. Pass `false` as the second argument for case-insensitive matching: `User_.name.equals(\"joe\", false)`.\n###\n[hashtag](#common-conditions)\nCommon conditions\nApart from the standard conditions like `equal()`, `notEqual()`, `greater()` and `less()` there are also additional conditions available:\n-   `isNull()` and `notNull()`,\n-   `between()` to filter for values that are between the given two,\n-   `oneOf()` and `notOneOf()` to filter for values that match any in the given array,\n-   `startsWith()`, `endsWith()` and `contains()` for extended String filtering.\nSee the API for a full list:\n-   Property conditions: [Javaarrow-up-right](https://objectbox.io/docfiles/java/current/io/objectbox/Property.html) and [Dartarrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/QueryProperty-class.html)\n-   Relation conditions: [Javaarrow-up-right](https://objectbox.io/docfiles/java/current/io/objectbox/relation/RelationInfo.html)\ncircle-info\n**Dart only: DateTime caveat**\nFor Dart `DateTime` is stored as time in milliseconds internally in the database (or nanoseconds for `@Property(type: PropertyType.dateNano)`).\nTo avoid having to manually convert to `int` when creating a query condition, extra methods that accept `DateTime` exist.\nFor example, to query an `Order` entity with a `date` field to find all orders in 2023:\n###\n[hashtag](#nearest-neighbor-vector-search)\nNearest neighbor vector search\nA special condition is available for vector properties with an HNSW index. See the dedicated page for details:\n[On-Device Vector Searchchevron-right](https://docs.objectbox.io/on-device-vector-search)\n###\n[hashtag](#order-results)\nOrder results\nIn addition to specifying conditions, you can order the returned results using the `order()` method. By default this sorts ASCII characters in alphabetical order while ignoring case and numbers in ascending order.\nJava\nKotlin\nDart\nPython\nTypeScript\ncircle-info\nOrder results feature is not yet available in Python.\nYou can also pass flags to `order()` to sort in descending order, to sort case sensitive or to specially treat null values. For example to sort the above results in descending order and case sensitive instead:\nJava\nKotlin\nDart\nPython\nTypeScript\ncircle-info\nOrder results feature is not yet available in Python.\nOrder directives can also be chained. Check the method documentation ([Javaarrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/query/QueryBuilder.html#order\\(io.objectbox.Property,int\\))) for details.\n##\n[hashtag](#run-a-query)\nRun a query\n[Queries](https://docs.objectbox.io/queries) are first created (and not yet executed) by calling `build()` on the `QueryBuilder`.\nOnce the query is created, it allows various operations, which we will explore in the following sub sections.\n###\n[hashtag](#find-objects)\nFind objects\nThere are a couple of find methods to retrieve objects matching the query:\nJava\nTypeScript\nTo return all entities matching the query simply call `find()`.\nTo only return the first result, use `findFirst()`.\nIf you expect a unique result, call `findUnique()` instead. It will give you a single result or null, if no matching entity was found and throw an exception if there was more than one result.\n###\n[hashtag](#remove-objects)\nRemove objects\nTo remove all objects matching a query, call `query.remove()`.\nJava\nKotlin\nDart\nPython\nTypeScript\n###\n[hashtag](#reuse-queries-and-parameters)\nReuse Queries and Parameters\nIf you frequently run the same query you should cache the `Query` object and re-use it. To make a `Query` more reusable you can change the values, or query parameters, of each condition you added even after the `Query` is built. Let's see how.\ncircle-info\nQuery is not thread safe. To use a query in a different thread, either build a new query or synchronize access to it. Alternatively, in Java use `query.copy()` or a `QueryThreadLocal` to obtain an instance for each thread.\nAssume we want to find a list of `User` with specific `firstName` values. First, we build a regular `Query` with an `equal()` condition for `firstName`. Because we have to pass an initial parameter value to `equal()` but plan to override it before running the `Query` later, we just pass an empty string:\nJava\nKotlin\nDart\nPython\nTypeScript\ncircle-info\nQuery parameter reuse via `setParameter()` is not yet available in TypeScript. Rebuild the query with new values instead.\nNow at some later point, we want to run the `Query` with an actual value for the `equals` condition on`firstName` :\nJava\nKotlin\nDart\nPython\nYou might already be wondering what happens if you have more than one condition using `firstName`? For this purpose you can **assign each parameter an alias** while specifying the condition:\nJava\nKotlin\nDart\nPython\nThen, when setting a new parameter value pass the alias instead of the property:\nJava\nKotlin\nDart\nPython\n###\n[hashtag](#limit-offset-and-pagination)\nLimit, Offset, and Pagination\nSometimes you only need a subset of a query, for example, the first 10 elements to display in your user interface. This is especially helpful (and resource-efficient) when you have a high number of entities and you cannot limit the result using query conditions only.\nJava\nKotlin\nDart\nPython\nTypeScript\n`offset:` The first `offset` results are skipped.\n`limit:` At most `limit` results are returned.\n###\n[hashtag](#lazy-load-results-java)\nLazy-load results (Java)\ncircle-info\nOnly Java/Kotlin\nTo avoid loading query results right away, Query offers `findLazy()` and `findLazyCached()` which return a [`LazyList`arrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/query/LazyList.html) of the query results.\n[LazyListarrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/query/LazyList.html) is a thread-safe, unmodifiable list that reads entities lazily only once they are accessed. Depending on the find method called, the lazy list will be cached or not. Cached lazy lists store the previously accessed objects to avoid loading entities more than once. Some features of the list are limited to cached lists (e.g. features that require the entire list). See the [LazyList class documentationarrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/query/LazyList.html) for more details.\n###\n[hashtag](#stream-results-dart)\nStream results (Dart)\ncircle-info\nOnly Dart\nInstead of reading the whole result (list of objects) using `find()` you can stream it using `stream()` :\nDart\n###\n[hashtag](#observe-or-listen-to-changes)\nObserve or listen to changes\nTo learn how to observe or listen to changes to the results of a query, see the data observers page:\n[Data Observers & Rxchevron-right](https://docs.objectbox.io/data-observers-and-rx)\n##\n[hashtag](#query-a-single-property)\nQuery a single property\nIf you only want to return the values of a particular property and not a list of full objects you can use a [PropertyQueryarrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/query/PropertyQuery.html). After building a query, simply call `property(Property)` to define the property followed by the appropriate find method.\nFor example, instead of getting all `User`s, to just get their email addresses:\nJava\nKotlin\nDart\nTypeScript\ncircle-info\nProperty queries are not yet available in TypeScript. Use `find()` and map the results instead:\ncircle-info\nNote: the returned array of property values is **not in any particular order**, even if you did specify an order when building the query.\n###\n[hashtag](#handle-null-values)\nHandle null values\n**By default, null values are not returned.** However, you can specify a replacement value to return if a property is null:\nJava\nKotlin\nDart\n###\n[hashtag](#distinct-and-unique-results)\nDistinct and unique results\nThe property query can also only return distinct values:\nJava\nKotlin\nDart\n###\n[hashtag](#aggregate-values)\nAggregate values\nProperty queries ([JavaDocarrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/query/PropertyQuery.html) and [Dart API docsarrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/PropertyQuery-class.html)) also offer aggregate functions to directly calculate the minimum, maximum, average, sum and count of all found values:\n-   `min()` / `minDouble()`: Finds the minimum value for the given property over all objects matching the query.\n-   `max()` / `maxDouble()`: Finds the maximum value.\n-   `sum()` / `sumDouble()`: Calculates the sum of all values. _Note: the non-double version detects overflows and throws an exception in that case._\n-   `avg()` : Calculates the average (always a double) of all values.\n-   `count()`: returns the number of results. This is faster than finding and getting the length of the result array. Can be combined with `distinct()` to count only the number of distinct values.\n##\n[hashtag](#query-a-related-entity-links)\nQuery a related entity (links)\nAfter creating a relation between entities, you might want to add a query condition for a property that only exists in the related entity. In SQL this is solved using JOINs. But as ObjectBox is not a SQL database we built something very similar: links. Links are based on [Relations](https://docs.objectbox.io/relations) \\- see the doc page for the introduction.\nAssume there is a `Person` that can be associated with multiple `Address` entities:\nJava\nKotlin\nDart\nTo get a `Person` with a certain name that also lives on a specific street, we need to query the associated `Address` entities of a `Person`. To do this, use the `link()` method of the query builder to tell that the `addresses` relation should be queried. Then add a condition for `Address`:\nJava\nKotlin\nDart\nWhat if we want to get a list of `Address` instead of `Person`? If you know ObjectBox relations well, you would probably add a `@Backlink` relation to `Address` and build your query using it with `link()` as shown above:\nJava\nKotlin\nDart\nBut actually, you do not have to modify the `Address` entity (you still can if you need the `@Backlink` elsewhere). Instead, we can use the `backlink()` method to create a backlink to the `addresses` relation from `Person` just for that query:\nJava\nKotlin\nDart\n##\n[hashtag](#eager-load-relations)\nEager-load relations\ncircle-info\nOnly Java/Kotlin. Relations are not yet available in TypeScript.\nBy default [relations](https://docs.objectbox.io/relations) are loaded lazily: when you first access a `ToOne` or `ToMany` property it will perform a database lookup to get its data. On each subsequent access it will use a cached version of that data.\nJava\nKotlin\nWhile this initial lookup is fast, you might want to prefetch `ToOne` or `ToMany` values before the query results are returned. To do this call the [`QueryBuilder.eager`arrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/query/QueryBuilder.html) method when building your query and pass the `RelationInfo` objects associated with the `ToOne` and `ToMany` properties to prefetch:\nJava\nKotlin\nEager loading only works one level deep. If you have **nested relations** and you want to prefetch relations of all children, you can instead add a query filter as described below. Use it to simply access all relation properties, which triggers them to lookup there values as described above.\n##\n[hashtag](#query-filters)\nQuery filters\ncircle-info\nOnly Java/Kotlin. For Dart and TypeScript, use the built-in array filter methods (`where()` in Dart, `filter()` in TypeScript).\nQuery filters come into play when you are looking for objects that need to match complex conditions, which cannot be fully expressed with the QueryBuilder class. Filters are written in Java and thus can express any complexity. Needless to say, that database conditions can be matched more efficiently than Java-based filters. Thus you will get the best results when you use both together:\n1.  Narrow down results using standard database conditions to a reasonable number (use QueryBuilder to get “candidates”)\n2.  Now filter those candidates using the [QueryFilterarrow-up-right](https://objectbox.io/docfiles/java/current/io/objectbox/query/QueryFilter.html) Java interface to identify final results\nA QueryFilter implementation looks at one candidate object at a time and returns true if the candidate is a result or false if not.\nExample:\nNotes on performance: 1) ObjectBox creates objects very fast. 2) The virtual machine is tuned to garbage collect short-lived objects. Notes 1) and 2) combined makes a case for filtering because ObjectBox creates candidate objects of which some are not used and thus get garbage collected quickly after their creation.\n###\n[hashtag](#query-filters-and-tomany-relation)\nQuery filters and ToMany relation\nThe ToMany class offers additional methods that can be convenient in query filters:\n-   hasA: returns true if one of the elements matches the given QueryFilter\n-   hasAll: returns true if all of the elements match the given QueryFilter\n-   getById: return the element with the given ID (value of the property with the @Id annotation)\n##\n[hashtag](#debug-queries)\nDebug queries\nTo see what query is actually executed by ObjectBox:\nJava\nKotlin\nDart\nTypeScript\ncircle-info\nQuery debugging is not yet available in TypeScript.\nThen in your console (or logcat on Android) you will see log output like:\n[PreviousKotlin Supportchevron-left](https://docs.objectbox.io/kotlin-support)[NextOn-Device Vector Searchchevron-right](https://docs.objectbox.io/on-device-vector-search)\nLast updated 25 days ago\nWas this helpful?\n-   [Build a query](#build-a-query)\n-   [Common conditions](#common-conditions)\n-   [Nearest neighbor vector search](#nearest-neighbor-vector-search)\n-   [Order results](#order-results)\n-   [Run a query](#run-a-query)\n-   [Find objects](#find-objects)\n-   [Remove objects](#remove-objects)\n-   [Reuse Queries and Parameters](#reuse-queries-and-parameters)\n-   [Limit, Offset, and Pagination](#limit-offset-and-pagination)\n-   [Lazy-load results (Java)](#lazy-load-results-java)\n-   [Stream results (Dart)](#stream-results-dart)\n-   [Observe or listen to changes](#observe-or-listen-to-changes)\n-   [Query a single property](#query-a-single-property)\n-   [Handle null values](#handle-null-values)\n-   [Distinct and unique results](#distinct-and-unique-results)\n-   [Aggregate values](#aggregate-values)\n-   [Query a related entity (links)](#query-a-related-entity-links)\n-   [Eager-load relations](#eager-load-relations)\n-   [Query filters](#query-filters)\n-   [Query filters and ToMany relation](#query-filters-and-tomany-relation)\n-   [Debug queries](#debug-queries)\nWas this helpful?\nCopy\n```\nquery = userBox.query(\n  User.firstName.equals(\"Joe\") &\n  User.yearOfBirth.greater_than(2015) &\n  User.lastName.starts_with('O')\n).build()\njoes = query.find()\n```\nCopy\n```\nconst query = userBox.query(\n    User_.firstName.equals(\"Joe\")\n        .and(User_.yearOfBirth.greaterThan(2015))\n        .and(User_.lastName.startsWith(\"O\"))\n).build();\nconst youngJoes = query.find();\nquery.close();\n```\nCopy\n```\nQueryCondition<User> conditions = User_.firstName.equal(\"Joe\");\nif (onlyYoungJoes) {\n    conditions = conditions.and(User_.yearOfBirth.greater(2015));\n}\nQuery<User> query = userBox.query(conditions).build();\n```\nCopy\n```\nvar conditions: QueryCondition<User> = User_.firstName equal \"Joe\"\nif (onlyYoungJoes) {\n    conditions = conditions and (User_.yearOfBirth greater 2015)\n}\nval query = userBox.query(conditions).build()\n```\nCopy\n```\nvar conditions = User_.firstName.equals('Joe');\nif (onlyYoungJoes) {\n  conditions = conditions & User_.yearOfBirth.greaterThan(2015);\n}\nQuery<User> query = userBox.query(conditions).build();\n```\nCopy\n```\nlet conditions = User_.firstName.equals(\"Joe\");\nif (onlyYoungJoes) {\n    conditions = conditions.and(User_.yearOfBirth.greaterThan(2015));\n}\nconst query = userBox.query(conditions).build();\n```\nCopy\n```\n// equal AND (less OR oneOf)\nQuery<User> query = box.query(\n        User_.firstName.equal(\"Joe\")\n                .and(User_.age.less(12)\n                        .or(User_.stamp.oneOf(new long[]{1012}))))\n        .build();\n```\nCopy\n```\n// equal AND (less OR oneOf)\nval query = box.query(\n        User_.firstName equal \"Joe\" and\n                (User_.age less 12 or\n                        (User_.stamp oneOf longArrayOf(1012))))\n        .build()\n```\nCopy\n```\nQuery<User> query = box.query(\n    User_.firstName.equals('Joe')\n        .and(User_.age.lessThan(12)\n        .or(User_.stamp.oneOf([1012]))))\n    .build();\n```\nCopy\n```\nquery = userBox.query(\n        (User.firstName.equals(\"Joe\")\n            & User.yearOfBirth.greater_than(1970)) |\n        User.lastName.starts_with('O')\n    ).build()\njoes = query.find()\n```\nCopy\n```\n// equals AND (lessThan OR greaterThan)\nconst query = box.query(\n    User_.firstName.equals(\"Joe\")\n        .and(User_.age.lessThan(12)\n            .or(User_.age.greaterThan(60)))\n).build();\n```\nCopy\n```\nfinal query = box\n    .query(Order_.date.betweenDate(DateTime.utc(2023),\n        DateTime.utc(2024).subtract(Duration(milliseconds: 1))))\n    .build();\n```\nCopy\n```\nQuery<User> query = userBox\n    .query(User_.firstName.equal(\"Joe\"))\n    .order(User_.lastName) // in ascending order, ignoring case\n    .build();\n```\nCopy\n```\nval query = userBox\n    .query(User_.firstName.equal(\"Joe\"))\n    .order(User_.lastName) // in ascending order, ignoring case\n    .build()\n```\nCopy\n```\n// in ascending order, ignoring case\nfinal qBuilder = box.query(User_.firstName.equals('Joe')).order(User_.lastName);\nfinal query = qBuilder.build();\n```\nCopy\n```\n// in ascending order\nconst query = userBox\n    .query(User_.firstName.equals(\"Joe\"))\n    .order(User_.lastName)\n    .build();\n```\nCopy\n```\n.order(User_.lastName, QueryBuilder.DESCENDING | QueryBuilder.CASE_SENSITIVE)\n```\nCopy\n```\n.order(User_.lastName, QueryBuilder.DESCENDING or QueryBuilder.CASE_SENSITIVE)\n```\nCopy\n```\n.order(User_.lastName, flags: Order.descending | Order.caseSensitive)\n```\nCopy\n```\nimport { OrderFlags } from \"objectbox\";\n// ...\n.order(User_.lastName, OrderFlags.DESCENDING | OrderFlags.CASE_SENSITIVE)\n```\nCopy\n```\nQuery<User> query = builder.build();\n```\nCopy\n```\n// return all entities matching the query\nList<User> joes = query.find();\n// return only the first result or null if none\nUser joe = query.findFirst();\n// return the only result or null if none, throw if more than one result\nUser joe = query.findUnique();\n```\nCopy\n```\n// return all entities matching the query\nconst joes = query.find();\n// return only the first result or null if none\nconst joe = query.findFirst();\n// return the only result or null if none, throw if more than one result\nconst uniqueJoe = query.findUnique();\n// return only the IDs of matching entities\nconst ids: bigint[] = query.findIds();\n// return the count of matching entities\nconst count: number = query.count();\n```\nCopy\n```\nlong removedCount = query.remove();\n```\nCopy\n```\nval removedCount = query.remove()\n```\nCopy\n```\nint removedCount = query.remove();\n```\nCopy\n```\nremoved_count = query.remove()\n```\nCopy\n```\nconst removedCount: number = query.remove();\n```\nCopy\n```\n// build a query\nQuery<User> query = userBox.query(User_.firstName.equal(\"\")).build();\n```\nCopy\n```\n// build a query\nval query = userBox.query(User_.firstName.equal(\"\")).build()\n```\nCopy\n```\n// build a query\nfinal query = userBox.query(User_.firstName.equals('')).build();\n```\nCopy\n```\n# build a query\nquery = userBox.query(User.firstName.equals('')).build();\n```\nCopy\n```\n// Change firstName parameter to \"Joe\" and get results\nList<User> joes = query.setParameter(User_.firstName, \"Joe\").find();\n// Change firstName parameter to \"Jake\" and get results\nList<User> jakes = query.setParameter(User_.firstName, \"Jake\").find();\n```\nCopy\n```\n// Change firstName parameter to \"Joe\" and get results\nval joes = query.setParameter(User_.firstName, \"Joe\").find()\n// Change firstName parameter to \"Jake\" and get results\nval jakes = query.setParameter(User_.firstName, \"Jake\").find()\n```\nCopy\n```\n// Change firstName parameter to \"Joe\" and get results\nquery.param(User_.firstName).value = 'Joe';\nfinal joes = query.find();\n// Change firstName parameter to \"Jake\" and get results\nfinal jakes = (query..param(User_.firstName).value = 'Jake').find();\n```\nCopy\n```\n# Change firstName parameter to \"Joe\" and get results\njoes = query.set_parameter_string(User.firstName, \"Joe\").find()\n# Change firstName parameter to \"Jake\" and get results\njakes = query.set_parameter_srting(User.firstName, \"Jake\").find()\n```\nCopy\n```\n// assign alias \"name\" to the equal query parameter\nQuery<User> query = userBox\n    .query(User_.firstName.equal(\"\").alias(\"name\"));\n```\nCopy\n```\n// assign alias \"name\" to the equal query parameter\nval query = userBox\n    .query(User_.firstName.equal(\"\").alias(\"name\"))\n```\nCopy\n```\n// assign alias \"name\" to the equals query parameter\nfinal query = userBox.query(User_.firstName.equals('', alias: 'name')).build();\n```\nCopy\n```\n# Assign alias \"name\" to the equals query parameter\nquery = userBox.query(User.firstName.equals('').alias(\"name\")).build();\n```\nCopy\n```\n// Change parameter with alias \"name\" to \"Joe\", get results\nList<User> joes = query.setParameter(\"name\", \"Joe\").find();\n```\nCopy\n```\n// Change parameter with alias \"name\" to \"Joe\" and get results\nval joes = query.setParameter(\"name\", \"Joe\").find()\n```\nCopy\n```\n// Change parameter with alias \"name\" to \"Joe\" and get results\nfinal joes = (query..param(User_.firstName, alias: 'name').value = 'Joe').find();\n```\nCopy\n```\n# Change parameter with alias \"name\" to \"Joe\" and get results\njoes = query.set_parameter_alias_string(\"name\", \"Joe\").find()\n```\nCopy\n```\n// offset by 10, limit to at most 5 results\nList<User> joes = query.find(10, 5);\n```\nCopy\n```\n// offset by 10, limit to at most 5 results\nval joes = query.find(10, 5)\n```\nCopy\n```\n// offset by 10, limit to at most 5 results\nquery\n  ..offset = 10\n  ..limit = 5;\nList<User> joes = query.find();\n```\nCopy\n```\n# Offset by 10, limit to at most 5 results\njoes = query \\\n    .offset(10)\n    .limit(5)\n    .find()\n```\nCopy\n```\n// offset by 10, limit to at most 5 results\nconst joes = query.offset(10).limit(5).find();\n```\nCopy\n```\nQuery<User> query = userBox.query().build();\nStream<User stream = query.stream();\nawait stream.forEach((User user) => print(user));\nquery.close();\n```\nCopy\n```\nString[] emails = userBox.query().build()\n    .property(User_.email)\n    .findStrings();\n// or use .findString() to return just the first result\n```\nCopy\n```\nval emails = userBox.query().build()\n    .property(User_.email)\n    .findStrings()\n// or use .findString() to return just the first result\n```\nCopy\n```\nfinal query = userBox.query().build();\nList<String> emails = query.property(User_.email).find();\nquery.close();\n```\nCopy\n```\nconst emails = query.find().map(user => user.email);\n```\nCopy\n```\n// includes 'unknown' for each null email\nString[] emails = userBox.query().build()\n    .property(User_.email)\n    .nullValue(\"unknown\")\n    .findStrings();\n```\nCopy\n```\n// includes 'unknown' for each null email\nval emails = userBox.query().build()\n    .property(User_.email)\n    .nullValue(\"unknown\")\n    .findStrings()\n```\nCopy\n```\nfinal query = userBox.query().build();\n// includes 'unknown' for each null email\nList<String> emails = query.property(User_.email).find(replaceNullWith: 'unknown');\nquery.close();\n```\nCopy\n```\nPropertyQuery pq = userBox.query().build().property(User_.firstName);\n// returns ['joe'] because by default, the case of strings is ignored.\nString[] names = pq.distinct().findStrings();\n// returns ['Joe', 'joe', 'JOE']\nString[] names = pq.distinct(StringOrder.CASE_SENSITIVE).findStrings();\n// the query can be configured to throw there is more than one value\nString[] names = pq.unique().findStrings();\n```\nCopy\n```\nval pq = userBox.query().build().property(User_.firstName)\n// returns ['joe'] because by default, the case of strings is ignored.\nval names = pq.distinct().findStrings()\n// returns ['Joe', 'joe', 'JOE']\nval names = pq.distinct(StringOrder.CASE_SENSITIVE).findStrings()\n// the query can be configured to throw there is more than one value\nval names = pq.unique().findStrings()\n```\nCopy\n```\nfinal query = userBox.query().build();\nPropertyQuery<String> pq = query.property(User_.firstName);\npq.distinct = true;\n// returns ['Joe', 'joe', 'JOE']\nList<String> names = pq.find();\n// returns ['joe']\npq.caseSensitive = false;\nList<String> names = pq.find();\nquery.close();\n```\nCopy\n```\n@Entity\npublic class Person {\n    @Id long id;\n    String name;\n    ToMany<Address> addresses;\n}\n@Entity\npublic class Address {\n    @Id long id;\n    String street;\n    String zip;\n}\n```\nCopy\n```\n@Entity\nclass Person {\n    @Id\n    var id: Long = 0\n    var name: String? = null\n    lateinit var addresses: ToMany<Address>\n}\n@Entity\nclass Address {\n    @Id\n    var id: Long = 0\n    var street: String? = null\n    var zip: String? = null\n}\n```\nCopy\n```\n@Entity()\nclass Person {\n    int id;\n    String name;\n    final addresses = ToMany<Address>();\n}\n@Entity()\nclass Address {\n    int id;\n    String street;\n    String zip;\n}\n```\nCopy\n```\n// get all Person objects named \"Elmo\"...\nQueryBuilder<Person> builder = personBox\n    .query(Person_.name.equal(\"Elmo\"));\n// ...which have an address on \"Sesame Street\"\nbuilder.link(Person_.addresses)\n    .apply(Address_.street.equal(\"Sesame Street\"));\nList<Person> elmosOnSesameStreet = builder.build().find();\n```\nCopy\n```\n// get all Person objects named \"Elmo\"...\nval builder = personBox\n    .query(Person_.name.equal(\"Elmo\"))\n// ...which have an address on \"Sesame Street\"\nbuilder.link(Person_.addresses)\n    .apply(Address_.street.equal(\"Sesame Street\"))\nval elmosOnSesameStreet = builder.build().find()\n```\nCopy\n```\n// get all Person objects named \"Elmo\"...\nQueryBuilder<Person> builder = personBox\n    .query(Person_.name.equals('Elmo'));\n// ...which have an address on \"Sesame Street\"\nbuilder.linkMany(Person_.addresses, Address_.street.equals('Sesame Street'));\nQuery<Person> query = builder.build();\nList<Person> elmosOnSesameStreet = query.find();\nquery.close();\n```\nCopy\n```\n@Entity\npublic class Address {\n    // ...\n    @Backlink(to = \"addresses\")\n    ToMany<Person> persons;\n}\n// get all Address objects with street \"Sesame Street\"...\nQueryBuilder<Address> builder = addressBox\n    .query(Address_.street.equal(\"Sesame Street\"));\n// ...which are linked from a Person named \"Elmo\"\nbuilder.link(Address_.persons)\n    .apply(Person_.name.equal(\"Elmo\"));\nList<Address> sesameStreetsWithElmo = builder.build().find();\n```\nCopy\n```\n@Entity\nclass Address {\n    // ...\n    @Backlink(to = \"addresses\")\n    lateinit var persons: ToMany<Person>\n}\n// get all Address objects with street \"Sesame Street\"...\nval builder = addressBox\n    .query(Address_.street.equal(\"Sesame Street\"))\n// ...which are linked from a Person named \"Elmo\"\nbuilder.link(Address_.persons)\n    .apply(Person_.name.equal(\"Elmo\")\nval sesameStreetsWithElmo = builder.build().find()\n```\nCopy\n```\n@Entity()\nclass Address {\n    ...\n    @Backlink()\n    final persons = ToMany<Person>();\n}\n// get all Address objects with street \"Sesame Street\"...\nQueryBuilder<Address> builder =\n    addressBox.query(Address_.street.equals('Sesame Street'));\n// ...which are linked from a Person named \"Elmo\"\nbuilder.linkMany(Address_.persons, Person_.name.equals('Elmo'));\nQuery<Address> query = builder.build();\nList<Address> sesameStreetsWithElmo = query.find();\nquery.close();\n```\nCopy\n```\n// get all Address objects with street \"Sesame Street\"...\nQueryBuilder<Address> builder = addressBox\n    .query(Address_.street.equal(\"Sesame Street\"));\n// ...which are linked from a Person named \"Elmo\"\nbuilder.backlink(Person_.addresses)\n    .apply(Person_.name.equal(\"Elmo\"));\nList<Address> sesameStreetsWithElmo = builder.build().find();\n```\nCopy\n```\n// get all Address objects with street \"Sesame Street\"...\nval builder = addressBox\n    .query(Address_.street.equal(\"Sesame Street\"))\n// ...which are linked from a Person named \"Elmo\"\nbuilder.backlink(Person_.addresses)\n    .apply(Person_.name.equal(\"Elmo\"))\nval sesameStreetsWithElmo = builder.build().find()\n```\nCopy\n```\n// get all Address objects with street \"Sesame Street\"...\nQueryBuilder<Address> builder =\n    addressBox.query(Address_.street.equals('Sesame Street'));\n// ...which are linked from a Person named \"Elmo\"\nbuilder.backlinkMany(Person_.addresses, Person_.name.equals('Elmo'));\nQuery<Address> query = builder.build();\nList<Address> sesameStreetsWithElmo = query.find();\nquery.close();\n```\nCopy\n```\nList<Customer> customers = customerBox.query().build().find();\n// Customer has a ToMany called orders.\n// First access: this will cause a database lookup.\nOrder order = customers.get(0).orders.get(0);\n```\nCopy\n```\nval customers = customerBox.query().build().find()\n// Customer has a ToMany called orders\nval order = customers[0].orders[0] // first access: causes a database lookup\n```\nCopy\n```\nList<Customer> customers = customerBox.query()\n    .eager(Customer_.orders) // Customer has a ToMany called orders.\n    .build()\n    .find();\n// First access: this will cause a database lookup.\nOrder order = customers.get(0).orders.get(0);\n```\nCopy\n```\nval customers = customerBox.query()\n    .eager(Customer_.orders) // Customer has a ToMany called orders\n    .build()\n    .find()\ncustomers[0].orders[0] // first access: this will NOT cause a database lookup\n```\nCopy\n```\n// Reduce object count to reasonable value.\nsongBox.query(Song_.bandId.equal(bandId))\n        // Filter is performed on candidate objects.\n        .filter((song) -> song.starCount * 2 > song.downloads);\n```\nCopy\n```\n// Set the LOG_QUERY_PARAMETERS debug flag\nBoxStore store = MyObjectBox.builder()\n    .debugFlags(DebugFlags.LOG_QUERY_PARAMETERS)\n    .build();\n// Execute a query\nquery.find();\n```\nCopy\n```\n// Set the LOG_QUERY_PARAMETERS debug flag\nval store = MyObjectBox.builder()\n    .debugFlags(DebugFlags.LOG_QUERY_PARAMETERS)\n    .build()\n// Execute a query\nquery.find()\n```\nCopy\n```\nprint(query.describeParameters());\n```\nCopy\n```\nParameters for query #2:\n(firstName ==(i) \"Joe\"\n AND age < 12)\n```",
  "timestamp": 1769974108284,
  "title": "ObjectBox Queries | ObjectBox Docs"
}