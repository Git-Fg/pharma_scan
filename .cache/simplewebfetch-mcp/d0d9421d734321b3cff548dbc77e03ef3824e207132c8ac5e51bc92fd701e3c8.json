{
  "url": "https://docs.objectbox.io/getting-started",
  "markdown": "# Getting started | ObjectBox Docs\nbars[![](https://docs.objectbox.io/~gitbook/image?url=https%3A%2F%2F4174656640-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-LETufmyus5LFkviJjr4%252Favatar.png%3Fgeneration%3D1528453316288221%26alt%3Dmedia&width=32&dpr=3&quality=100&sign=96b28d45&sv=2)![](https://docs.objectbox.io/~gitbook/image?url=https%3A%2F%2F4174656640-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-LETufmyus5LFkviJjr4%252Favatar.png%3Fgeneration%3D1528453316288221%26alt%3Dmedia&width=32&dpr=3&quality=100&sign=96b28d45&sv=2)\nObjectBox Docs\n](https://docs.objectbox.io/)\nsearch\ncircle-xmark\nâŒ˜Ctrlk\n[Home](https://objectbox.io/)[Blog](https://objectbox.io/blog/)[Twitter](https://twitter.com/ObjectBox_io)[GitHub](https://github.com/objectbox/objectbox-java)\nMoreellipsischevron-down\n[![](https://docs.objectbox.io/~gitbook/image?url=https%3A%2F%2F4174656640-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-LETufmyus5LFkviJjr4%252Favatar.png%3Fgeneration%3D1528453316288221%26alt%3Dmedia&width=32&dpr=3&quality=100&sign=96b28d45&sv=2)![](https://docs.objectbox.io/~gitbook/image?url=https%3A%2F%2F4174656640-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fspaces%252F-LETufmyus5LFkviJjr4%252Favatar.png%3Fgeneration%3D1528453316288221%26alt%3Dmedia&width=32&dpr=3&quality=100&sign=96b28d45&sv=2)\nObjectBox Docs\n](https://docs.objectbox.io/)\n-   [ObjectBox Docs](https://docs.objectbox.io/)\n-   [Getting started](https://docs.objectbox.io/getting-started)\n-   [Tutorial: Demo Project](https://docs.objectbox.io/tutorial-demo-project)\n-   [Entity Annotations](https://docs.objectbox.io/entity-annotations)\n-   [Property Types](https://docs.objectbox.io/property-types)\n-   [Android (Java/Kotlin)chevron-right](https://docs.objectbox.io/android)\n-   [Desktop Apps](https://docs.objectbox.io/java-desktop-apps)\n-   [Kotlin Support](https://docs.objectbox.io/kotlin-support)\n-   [ObjectBox Queries](https://docs.objectbox.io/queries)\n-   [On-Device Vector Search](https://docs.objectbox.io/on-device-vector-search)\n-   [Data Observers & Rx](https://docs.objectbox.io/data-observers-and-rx)\n-   [Relations](https://docs.objectbox.io/relations)\n-   [ObjectBox Admin](https://docs.objectbox.io/data-browser)\n-   [Transactions](https://docs.objectbox.io/transactions)\n-   [Advancedchevron-right](https://docs.objectbox.io/advanced)\n-   [Changelogs](https://docs.objectbox.io/changelogs)\n-   [Java API referencearrow-up-right](https://objectbox.io/docfiles/java/current/)\n-   [Dart API referencearrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/objectbox-library.html)\n-   [Python API referencearrow-up-right](https://objectbox.io/docfiles/python/current/)\n-   [Binary Licensearrow-up-right](https://objectbox.io/0209-ob-binary-license/)\n-   [FAQ](https://docs.objectbox.io/faq)\n-   [Troubleshooting](https://docs.objectbox.io/troubleshooting)\n-   [Data Syncarrow-up-right](https://objectbox.io/sync/)\n-   [Swift Database for iOSarrow-up-right](https://swift.objectbox.io/)\n-   [C++ Database Docsarrow-up-right](https://cpp.objectbox.io/)\n-   [Java Release History (<= v1.5)](https://docs.objectbox.io/release-history)\nchevron-upchevron-down\n[gitbookPowered by GitBook](https://www.gitbook.com/?utm_source=content&utm_medium=trademark&utm_campaign=-LETufmyus5LFkviJjr4)\nxmark\nblock-quoteOn this pagechevron-down\ncopyCopychevron-down\n# Getting started\nDiscover ObjectBox: The Lightning-Fast Mobile Database for Persistent Object Storage. Streamline Your Workflow, Eliminate Repetitive Tasks, and Enjoy a User-Friendly Data Interface.\n##\n[hashtag](#add-objectbox-to-your-project)\nAdd ObjectBox to your project\nJava/Kotlin (Android)\nJava/Kotlin (JVM)\nFlutter\nDart Native\nPython\n[media](https://cdn.iframe.ly/XfzWw6J)\nVideo Tutorial on Getting Started with ObjectBox for Android and Java\ncircle-info\nPrefer to look at example code? Check out [our examples repositoryarrow-up-right](https://github.com/objectbox/objectbox-examples).\nTo add ObjectBox to your Android project, [follow the instructions in the objectbox-java READMEarrow-up-right](https://github.com/objectbox/objectbox-java?tab=readme-ov-file#getting-started).\nOnce completed, continue with the next step of defining entity classes below.\ncircle-info\nPrefer to look at example code? Check out [our examples repositoryarrow-up-right](https://github.com/objectbox/objectbox-examples).\nThe ObjectBox Java SDK and runtime libraries support applications:\n-   running on the JVM on Linux (x86\\_64, arm64, armv7), Windows (x86\\_64) and macOS 10.15 or newer (x86\\_64, Apple M1)\n-   written in Java or Kotlin\n-   targeting at least Java 8\n-   built with Gradle or Maven\nObjectBox tools and dependencies are available on [the Maven Central repositoryarrow-up-right](https://central.sonatype.com/namespace/io.objectbox).\n**Maven projects**\nTo set up a Maven project, see the [README of the Java Maven example projectarrow-up-right](https://github.com/objectbox/objectbox-examples/blob/main/java-main-maven/README.md).\n**Gradle projects**\ncircle-info\nThe instructions assume a [multi-project buildarrow-up-right](https://docs.gradle.org/current/userguide/multi_project_builds.html) is used.\n1.  Open the Gradle build script of your root project and\n    1.  add a global variable to store the common version of ObjectBox dependencies and\n    2.  add the [ObjectBox Gradle pluginarrow-up-right](https://github.com/objectbox/objectbox-java-generator):\n1.  Open the Gradle build file for your application subproject and, after other plugins, apply the `io.objectbox` plugin:\ncircle-info\nUsing your IDE of choice with a Gradle project might require additional configuration. E.g.\n-   For IntelliJ IDEA see the [help page for Gradlearrow-up-right](https://www.jetbrains.com/help/idea/gradle.html).\n-   For Eclipse see the [Buildship arrow-up-right](https://projects.eclipse.org/projects/tools.buildship)project and [Getting Startedarrow-up-right](https://www.vogella.com/tutorials/EclipseGradle/article.html) article.\n1.  **Optionally**, add a runtime library for each platform that your application should run on and instead apply the Gradle plugin after the dependencies block:\ncircle-info\nThe ObjectBox database runs mostly in native code written in C/C++ for optimal performance. Thus, ObjectBox will load a runtime library: a â€œ.dllâ€ on Windows, a â€œ.soâ€ on Linux, and a â€œ.dylibâ€ on macOS.\\\\\nBy default, the Gradle plugin adds a runtime library (only) for your current operating system. It also adds the Java SDK (objectbox-java) and if needed the ObjectBox Kotlin extension functions (objectbox-kotlin).\ncircle-info\nObjectBox only supports 64-bit systems for best performance going forward. Talk to us if you require 32-bit support.\n1.  Your project can now use ObjectBox, continue by defining entity classes.\n[media](https://cdn.iframe.ly/RLkUQ28)\nVideo Tutorial on Getting Started with ObjectBox for Flutter\ncircle-info\nYou can watch these video tutorials as well ðŸ˜€:\n-   [Event Management apparrow-up-right](https://youtu.be/6YPSQPS_bhU)\n-   [Restaurant: chef and order appsarrow-up-right](https://youtu.be/r9Lc2r22KBk)\n-   [Task-list app (in Spanish)arrow-up-right](https://youtu.be/osUq6B92-BY)\ncircle-info\nPrefer to look at example code? Check out our [examples directoryarrow-up-right](https://github.com/objectbox/objectbox-dart/tree/main/objectbox/example).\nTo add ObjectBox to your Flutter project:\n1.  Run these commands:\nOr to use [ObjectBox Syncarrow-up-right](https://objectbox.io/sync/) (requires access to the Sync feature) instead run:\ncircle-info\n**To run unit tests on your machine**, download the latest native ObjectBox library for your machine by running this script in a bash shell (e.g. Git Bash on Windows):\n`bash <(curl -s https://raw.githubusercontent.com/objectbox/objectbox-dart/main/install.sh)`\nTo get a variant of the library that supports **ObjectBox Sync**, append the `--sync` argument to above command.\n1.  This should add lines like this to your `pubspec.yaml`:\n1.  If you added the above lines manually, then install the packages with `flutter pub get`.\ncircle-info\n**For all iOS apps** target iOS 15.0: in `ios/Podfile` change the platform and in the `ios/Runner.xcodeproj/poject.pbxproj` file update `IPHONEOS_DEPLOYMENT_TARGET` (or open the Runner workspace in Xcode and edit the build setting). In `ios/Flutter/AppframeworkInfo.plist` update `MinimumOSVersion` to `15.0`.\n**For all macOS apps** target macOS 11.0: in `macos/Podfile` change the platform and in the `macos/Runner.xcodeproj/poject.pbxproj` file update `MACOSX_DEPLOYMENT_TARGET` (or open the Runner workspace in Xcode and edit the build setting).\n**For macOS apps using Sync,** open `macos/Runner.xcodeproj` in Xcode and for the Runner target under Signing & Capabilities in the App Sandbox sections, enable incoming and outgoing network access.\ncircle-info\n**For Linux Desktop apps:** the **Flutter snap** ships with an outdated version of CMake. [**Install Flutter manually**arrow-up-right](https://docs.flutter.dev/get-started/install/linux#install-flutter-manually) **instead** to use the version of CMake installed on your system.\ncircle-info\nPrefer to look at example code? Check out our [examples directoryarrow-up-right](https://github.com/objectbox/objectbox-dart/tree/main/objectbox/example).\n1.  Run these commands:\n1.  This should add lines like this to your `pubspec.yaml`:\n1.  If you added the above lines manually, then install the packages with `dart pub get`\n2.  Install the [ObjectBox C libraryarrow-up-right](https://github.com/objectbox/objectbox-c) for your system (on Windows you can use \"Git Bash\"):\nOr to use [ObjectBox Syncarrow-up-right](https://objectbox.io/sync/) (requires access to the Sync feature) instead run:\ncircle-info\nBy default the library is downloaded into the `lib` subdirectory of the working directory. It's not necessary to install the library system-wide. This also allows to use different versions for different projects. For details see below.\n**Deploying Dart Native projects**\nNatively compiled Dart applications that use ObjectBox Dart require a reference to the [objectbox-carrow-up-right](https://github.com/objectbox/objectbox-c) library. Hence, the shared library file downloaded with `install.sh` needs to be shipped with the executable.\nThe `install.sh` script downloads the library by default to the `lib` subdirectory of the working directory. An executable using ObjectBox Dart looks for the library in this `lib` directory.\nIf it is not found there, it falls back to using system directories (using Dart's `DynamicLibrary.open`):\n-   Windows: working directory and `%WINDIR%\\system32`.\n-   macOS: `/usr/local/lib` (and maybe others).\n-   Linux: `/lib` and `/usr/lib` (again, possibly others).\ncircle-info\nPrefer to look at example code? Check out our [examples directoryarrow-up-right](https://github.com/objectbox/objectbox-python/tree/main/example).\nObjectBox for Python is available via PyPI: Stable Version (4.0.0):\ncircle-info\nIf you encounter any problems in this or later steps, also check the [FAQ](https://docs.objectbox.io/faq) and [Troubleshooting](https://docs.objectbox.io/troubleshooting) pages.\n##\n[hashtag](#define-entity-classes)\nDefine Entity Classes\nDefine your data model by creating **a class with at least an ID property**, a so called entity.\nA simple entity representing a user with an ID and a name property could look like this:\nJava\nKotlin\nDart\nPython\ncircle-exclamation\nWhen using a data class, **add default values for all parameters**. This will ensure your data class will have a constructor that can be called by ObjectBox. (Technically this is only required if adding properties to the class body, like custom or transient properties or relations, but it's a good idea to do it always.)\ncircle-exclamation\n**Avoid naming properties like reserved Java keywords, like** `**private**` **and** `**default**`**.** ObjectBox tooling works with the Java representation of your Kotlin code to be compatible with both Java and Kotlin. It will ignore such properties.\nYou can have multiple entities in the same file (here `models.dart`), or you can have them spread across multiple files in your package's `lib` directory.\n**Important:**\n-   **Entities must have exactly one 64-bit integer ID property** (a Java `long`, Kotlin `Long`, Dart `int`). If you need another type for the ID, like a string, [see the @Id annotation docs](https://docs.objectbox.io/entity-annotations#object-ids-id) for some tips. Also, the ID property must have **non-private visibility** (or non-private getter and setter methods).\n-   **Entities must also have a no-argument constructor**, or for better performance, a constructor with all properties as arguments. In the above examples, a default, no-argument constructor is generated by the compiler.\n[Support for many property types](https://docs.objectbox.io/property-types) is already built-in, but almost any type can be stored [with a converter](https://docs.objectbox.io/advanced/custom-types#convert-annotation-and-property-converter).\nFor more details about entities, like how to create an index or a relation, check the [Entity Annotations](https://docs.objectbox.io/entity-annotations) page.\nYou can also [learn more about the ObjectBox model](https://docs.objectbox.io/advanced/meta-model-ids-and-uids).\ncircle-info\nObjectBox also supports changing your model at a later point. You can **add and remove properties in entities** and the database model is updated **automatically** (after re-generating some code, see section below). There is no need to write migration code.\n**To rename entities or properties, change the type of a property** and more details in general see [Data Model Updates](https://docs.objectbox.io/advanced/data-model-updates).\n##\n[hashtag](#generate-objectbox-code)\nGenerate ObjectBox code\nNext, we generate some binding code based on the model defined in the previous step.\nJava/Kotlin\nFlutter/Dart Native\nPython\n**Build your project** to generate the `MyObjectBox` class and other classes required to use ObjectBox, for example using **Build > Make Project** in Android Studio.\ncircle-info\nNote: If you make significant changes to your entities, e.g. by moving them or modifying annotations, make sure to **rebuild** the project so generated ObjectBox code is updated.\nTo change the package of the `MyObjectBox` class, see the annotation processor options on the [Advanced Setup](https://docs.objectbox.io/advanced/advanced-setup) page.\nTo generate the binding code required to use ObjectBox run\n`dart run build_runner build`\nObjectBox generator will look for all `@Entity` annotations in your `lib` folder and create\n-   a single database definition `lib/objectbox-model.json` and\n-   supporting code in `lib/objectbox.g.dart`.\nTo customize the directory where generated files are written see [Advanced Setup](https://docs.objectbox.io/advanced/advanced-setup).\ncircle-info\nIf you **make changes to your entities**, e.g. by adding a property or modifying annotations, or after the **ObjectBox library has updated** make sure to **re-run the generator** so generated ObjectBox code is updated.\ncircle-check\nYou typically commit the generated code file `objectbox.g.dart` to your version control system (e.g. git) to avoid having to re-run the generator unless there are changes.\ncircle-info\nActually we lied above. The generator will process `lib` and `test` folders separately and generate files for each one (if `@Entity` classes exist there). This allows to create a separate test database that does not share any of the entity classes with the main database.\ncircle-info\nPython bindings offer a convenient default Model to which Entity definitions are automatically associated if not specified otherwise. Similar to the other bindings, a JSON model file is also used for management of Schema history (i.e. to handle add/remove/rename of Entity and Property).\nAmong other files ObjectBox generates a JSON **model file**, by default to\n-   `app/objectbox-models/default.json` for Android projects,\n-   `lib/objectbox-model.json` for Dart/Flutter projects, or\n-   `<user-module-dir>/objectbox-model.json` for Python projects\nTo change the model file path, see [Advanced Setup](https://docs.objectbox.io/advanced/advanced-setup).\ncircle-info\nIn Android Studio you might have to switch the _Project view_ from _Android_ to _Project_ to see the `default.json` model file. Python checks for the call-stack to determine the user-module directory in which the JSON file is stored.\nThis JSON file changes when you change your entity classes (or sometimes with a new version of ObjectBox).\n**Keep this JSON file**, commit the changes to version control!\nThis file keeps track of unique IDs assigned to your entities and properties. This ensures that an older version of **your database can be smoothly upgraded if your entities or properties change**.\ncircle-check\nThe model file also enables you to keep data [when renaming entities or properties](https://docs.objectbox.io/advanced/data-model-updates) or to [resolve conflictsarrow-up-right](https://docs.objectbox.io/advanced/meta-model-ids-and-uids) when two of your developers make changes at the same time.\n##\n[hashtag](#create-a-store)\nCreate a Store\n[**BoxStore**arrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/BoxStore.html) (Java) or [**Store**arrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/Store-class.html) (Dart) is the entry point for using ObjectBox. It is the direct interface to the database and manages Boxes. Typically, you want to only have a single Store (single database) and keep it open while your app is running, not closing it explicitly.\nJava (Android)\nKotlin (Android)\nJVM\nFlutter\nDart Native\nPython\nCreate it using the builder returned by the generated `MyObjectBox` class, for example in a small helper class like this:\ncircle-exclamation\nIf you encounter `UnsatisfiedLinkError` or `LinkageError` on the build call, see [App Bundle, split APKs and Multidex](https://docs.objectbox.io/android/app-bundle-and-split-apk) for solutions.\nThe best time to initialize ObjectBox is when your app starts. We suggest to do it in the `onCreate` method of your [Application classarrow-up-right](https://developer.android.com/reference/android/app/Application):\nCreate it using the builder returned by the generated MyObjectBox class, for example in a small helper class like this:\ncircle-exclamation\nIf you encounter `UnsatisfiedLinkError` or `LinkageError` on the build call, see [App Bundle, split APKs and Multidex](https://docs.objectbox.io/android/app-bundle-and-split-apk) for solutions.\nThe best time to initialize ObjectBox is when your app starts. We suggest to do it in the `onCreate` method of your [Application classarrow-up-right](https://developer.android.com/reference/android/app/Application):\nThe best time to initialize ObjectBox is when your app starts. For a command line app this is typically inside the main method.\n**Create it** using the generated `openStore()` method, for example in a small helper class like this:\ncircle-info\n**For sandboxed macOS apps** also pass `macosApplicationGroup` to `openStore()`. See the notes about \"macOS application group\" in [the constructor documentationarrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/Store/Store.html) of the `Store` class.\nFor example:\n`openStore(macosApplicationGroup: \"FGDTDLOBXDJ.demo\")`\ncircle-info\n**On mobile devices or sandboxed apps** data should be stored in the app's documents directory. See [Flutter: read & write filesarrow-up-right](https://flutter.dev/docs/cookbook/persistence/reading-writing-files) for more info. This is exactly what `openStore()`does, if the `directory` argument is not specified.\n**On desktop systems** it is recommended to specify a `directory` to create a custom sub-directory to avoid conflicts with other apps.\nIf your code passes a directory that the application can't write to, you get an error that looks somewhat like this: `failed to create store: 10199 Dir does not exist: objectbox (30)`.\nThe best time to **initialize ObjectBox** is when your app starts. We suggest to do it in your app's `main()` function:\ncircle-info\n**When using Dart isolates,** note that [each Dart isolate has its own global fieldsarrow-up-right](https://dart.dev/language/concurrency#isolates), they do not share state on the Dart level.\nHowever, as ObjectBox runs on the native or process level (so one native instance shared across all isolates), instead of creating a new Store in another isolate your code should instead [attach to the open native storearrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/Store/Store.attach.html).\nCreate it using the generated `openStore()` method, for example like this:\nThe above minimal example omits the argument to `(directory: )`, using the default - `./objectbox` - in the current working directory.\ncircle-info\n**When using Dart isolates,** note that [each Dart isolate has its own global fieldsarrow-up-right](https://dart.dev/language/concurrency#isolates), they do not share state on the Dart level.\nHowever, as ObjectBox runs on the native or process level (so one native instance shared across all isolates), instead of creating a new Store in another isolate your code should instead [attach to the open native storearrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/Store/Store.attach.html).\nIt is possible to specify various options when building a store. Notably for testing or caching, to use an **in-memory database** that does not create any files:\nJava\nDart\nPython\nFor **more store configuration options:** for Java see the [BoxStoreBuilderarrow-up-right](https://objectbox.io/docfiles/java/current/io/objectbox/BoxStoreBuilder.html) and for Dart the [Storearrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/Store/Store.html) documentation. (Python APIs will be published soon)\n##\n[hashtag](#basic-box-operations)\nBasic Box operations\nThe [Box classarrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/Box.html) is likely the class you interact with most. A Box instance gives you access to objects of a particular type. For example, if you have `User` and `Order` entities, you need a Box object to interact with each:\nJava\nKotlin\nDart\nPython\nThese are some of the operations offered by the Box class:\n**put** inserts a new object or updates an existing one (with the same ID). When inserting, an ID will be assigned to the just inserted object (this will be explained below) and returned. `put` also supports putting multiple objects, which is more efficient.\nJava\nKotlin\nDart\nPython\n**get and getAll:** Given an objectâ€™s ID, `get` reads it from its box. To get all objects in the box use `getAll` .\nJava\nKotlin\nDart\nPython\n**query:** Starts building a query to return objects from the box that match certain conditions. See [queries](https://docs.objectbox.io/queries) for details.\nJava\nKotlin\nDart\nPython\n**remove and removeAll:** Remove a previously put object from its box (deletes it). `remove` also supports removing multiple objects, which is more efficient. `removeAll` removes (deletes) all objects in a box.\nJava\nKotlin\nDart\nPython\n**count:** Returns the number of objects stored in this box.\nJava\nKotlin\nDart\nPython\nFor a complete list of methods available in the Box class, check the API reference documentation for [Javaarrow-up-right](https://objectbox.io/files/objectbox-java/current/io/objectbox/Box.html) or [Dartarrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/Box-class.html).\n###\n[hashtag](#asynchronous-operations)\nAsynchronous operations\nObjectBox has built-in support to run (typically multiple or larger) database operations asynchronously.\nJava\nDart\nPython\n**runInTxAsync** and **callInTxAsync:** runs the given Runnable/Callable in a transaction on a background thread (the internal ObjectBox thread pool) and calls the given callback once done. In case of callInTxAsync the callback also receives the returned result.\n**newCachedThreadPoolExecutor** and **newFixedThreadPoolExecutor**: create an [ObjectBoxThreadPoolExecutorarrow-up-right](https://github.com/objectbox/objectbox-java/blob/main/objectbox-java/src/main/java/io/objectbox/ObjectBoxThreadPoolExecutor.java) to asynchronously execute ObjectBox operations. This default thread pool executor implementation properly cleans up thread-local ObjectBox resources. Use this if the async methods above don't work for your use case or your code needs full control over the thread pool.\n####\n[hashtag](#kotlin-coroutines)\nKotlin Coroutines\n**awaitCallInTx:** wraps callInTxAsync in a coroutine that suspends until the transaction has completed. Likewise, on success the return value of the given callable is returned, on failure an exception is thrown.\n**newCachedThreadPoolDispatcher** and **newFixedThreadPoolDispatcher**: create a coroutine dispatcher backed by an [ObjectBoxThreadPoolExecutorarrow-up-right](https://github.com/objectbox/objectbox-java/blob/main/objectbox-java/src/main/java/io/objectbox/ObjectBoxThreadPoolExecutor.java) to asynchronously execute ObjectBox operations. The executor properly cleans up thread-local ObjectBox resources. For example, use it instead of `Dispatchers.IO` when doing ObjectBox operations in coroutines.\n**Most Box methods do have async versions** which run the operation in a worker isolate.\nFor example **putAsync:** asynchronously inserts a new object or updates an existing one (with the same ID). The returned future completes when the object is successfully written to the database.\n**To run multiple operations,** it is more efficient to wrap the synchronous calls in an asynchronous transaction with **runInTransactionAsync (**[**API reference**arrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/Store/runInTransactionAsync.html)**):** run a callback with multiple database operations within a write or read transaction in the background without blocking the user interface. Can return results.\nThere is also **runAsync (**[**API reference**arrow-up-right](https://pub.dev/documentation/objectbox/latest/objectbox/Store/runAsync.html)**):** like runInTransactionAsync but does not start a transaction, leaving that to your callback code. This allows to supply a callback that is an async function.\nIf it is necessary to **call put many times** in a row, take a look at **putQueued:** Schedules the given object to be put later on, by an asynchronous queue, returns the id immediately even though the object may not have been written yet. You can use Store's `awaitQueueCompletion()` or `awaitQueueSubmitted()` to wait for the async queue to finish.\ncircle-info\nCurrently work in progress.\n##\n[hashtag](#object-ids)\nObject IDs\nBy default **IDs for new objects are assigned by ObjectBox**. When a new object is put, it will be assigned the next highest available ID:\nJava\nKotlin\nDart\nPython\nFor example, if there is an object with ID 1 and another with ID 100 in a box, the next new object that is put will be assigned ID 101.\nIf you try to assign a new ID yourself and put the object, ObjectBox will throw an error.\ncircle-info\nIf you **need to assign IDs by yourself,** have a look at [how to switch to self-assigned IDs](https://docs.objectbox.io/advanced/object-ids#self-assigned-object-ids) and what side effects apply.\n###\n[hashtag](#reserved-object-ids)\nReserved Object IDs\nObject IDs **can not be**:\n-   `**0**` **(zero) or** `**null**` **(if using java.lang.Long)** As said above, when putting an object with ID zero it will be assigned an unused ID (not zero).\n-   `**0xFFFFFFFFFFFFFFFF**` **(-1 in Java)** Reserved for internal use.\nFor a detailed explanation see the page on [Object IDs](https://docs.objectbox.io/advanced/object-ids).\n##\n[hashtag](#transactions)\nTransactions\nWhile ObjectBox offers powerful transactions, it is sufficient for many apps to consider just some basics guidelines about transactions:\n-   A `put` runs an implicit transaction.\n-   Prefer `put` bulk overloads for lists (like `put(entities)`) when possible.\n-   For a high number of DB interactions in loops, consider explicit transactions, such as using `runInTx()`.\nFor more details check the separate [transaction documentation](https://docs.objectbox.io/transactions).\n##\n[hashtag](#have-an-app-with-greendao-daocompat-is-for-you)\nHave an app with greenDAO? DaoCompat is for you!\nDaoCompat is a compatibility layer that gives you a greenDAO like API for ObjectBox. It makes switching from greenDAO to ObjectBox simple. Have a look at [the documentationarrow-up-right](http://greenrobot.org/greendao/documentation/objectbox-compat/) and [the examplearrow-up-right](https://github.com/objectbox/objectbox-examples/tree/master/android-app-daocompat). [Contact usarrow-up-right](https://github.com/objectbox/objectbox-java/issues) if you have any questions!\n##\n[hashtag](#next-steps)\nNext steps\n-   Check out the [ObjectBox example projects on GitHubarrow-up-right](https://github.com/objectbox/objectbox-examples/).\n-   Learn about [Queries](https://docs.objectbox.io/queries) and [Relations](https://docs.objectbox.io/relations).\n-   Learn [how to write unit tests](https://docs.objectbox.io/android/android-local-unit-tests).\n-   To enable debug mode and for advanced use cases, see the [Advanced Setup](https://docs.objectbox.io/advanced/advanced-setup) page.\n[PreviousObjectBox Docschevron-left](https://docs.objectbox.io/)[NextTutorial: Demo Projectchevron-right](https://docs.objectbox.io/tutorial-demo-project)\nLast updated 5 days ago\nWas this helpful?\n-   [Add ObjectBox to your project](#add-objectbox-to-your-project)\n-   [Define Entity Classes](#define-entity-classes)\n-   [Generate ObjectBox code](#generate-objectbox-code)\n-   [Create a Store](#create-a-store)\n-   [Basic Box operations](#basic-box-operations)\n-   [Asynchronous operations](#asynchronous-operations)\n-   [Object IDs](#object-ids)\n-   [Reserved Object IDs](#reserved-object-ids)\n-   [Transactions](#transactions)\n-   [Have an app with greenDAO? DaoCompat is for you!](#have-an-app-with-greendao-daocompat-is-for-you)\n-   [Next steps](#next-steps)\nWas this helpful?\n/build.gradle(.kts)\nCopy\n```\nbuildscript {\n    ext.objectboxVersion = \"5.0.1\" // For Groovy build scripts\n    // val objectboxVersion by extra(\"5.0.1\") // For KTS build scripts\n    repositories {\n        mavenCentral()\n    }\n    dependencies {\n        classpath(\"io.objectbox:objectbox-gradle-plugin:$objectboxVersion\")\n    }\n}\n```\n/app/build.gradle(.kts)\nCopy\n```\n// Using plugins syntax:\nplugins {\n    id(\"java-library\") // or org.jetbrains.kotlin.jvm for Kotlin projects.\n    id(\"io.objectbox\") // Apply last.\n}\n// Or using the old apply syntax:\napply plugin: \"java-library\" // or org.jetbrains.kotlin.jvm for Kotlin projects.\napply plugin: \"io.objectbox\" // Apply last.\n```\nCopy\n```\ndependencies {\n    // ObjectBox platform-specific runtime libraries\n    // Add or remove them as needed to match what your application supports\n    // Linux (x64)\n    implementation(\"io.objectbox:objectbox-linux:$objectboxVersion\")\n    // macOS (Intel and Apple Silicon)\n    implementation(\"io.objectbox:objectbox-macos:$objectboxVersion\")\n    // Windows (x64)\n    implementation(\"io.objectbox:objectbox-windows:$objectboxVersion\")\n    // Additional ObjectBox runtime libraries\n    // Linux (32-bit ARM)\n    implementation(\"io.objectbox:objectbox-linux-arm64:$objectboxVersion\")\n    // Linux (64-bit ARM)\n    implementation(\"io.objectbox:objectbox-linux-armv7:$objectboxVersion\")\n}\n// When manually adding ObjectBox dependencies, the plugin must be\n// applied after the dependencies block so it can detect them.\n// Using Groovy build scripts\napply plugin: \"io.objectbox\"\n// Using KTS build scripts\napply(plugin = \"io.objectbox\")\n```\nCopy\n```\nflutter pub add objectbox objectbox_flutter_libs:any\nflutter pub add --dev build_runner objectbox_generator:any\n```\nCopy\n```\nflutter pub add objectbox objectbox_sync_flutter_libs:any\nflutter pub add --dev build_runner objectbox_generator:any\n```\nCopy\n```\ndependencies:\n  objectbox: ^5.1.0\n  objectbox_flutter_libs: any\n  # If you run the command for ObjectBox Sync it should add instead:\n  # objectbox_sync_flutter_libs: any\ndev_dependencies:\n  build_runner: ^2.4.11\n  objectbox_generator: any\n```\nCopy\n```\ndart pub add objectbox\ndart pub add --dev build_runner objectbox_generator:any\n```\nCopy\n```\ndependencies:\n  objectbox: ^5.1.0\ndev_dependencies:\n  build_runner: ^2.4.11\n  objectbox_generator: any\n```\nCopy\n```\nbash <(curl -s https://raw.githubusercontent.com/objectbox/objectbox-dart/main/install.sh)\n```\nCopy\n```\nbash <(curl -s https://raw.githubusercontent.com/objectbox/objectbox-dart/main/install.sh) --sync\n```\nCopy\n```\npip install --upgrade objectbox\n```\nUser.java\nCopy\n```\n@Entity\npublic class User {\n    @Id\n    public long id;\n    public String name;\n}\n```\nmodels.kt\nCopy\n```\n@Entity\ndata class User(\n        @Id\n        var id: Long = 0,\n        var name: String? = null\n)\n```\nmodels.dart\nCopy\n```\n@Entity()\nclass User {\n  @Id()\n  int id = 0;\n  String? name;\n}\n```\nmodel.py\nCopy\n```\nfrom objectbox import Entity, Id, String\n@Entity()\nclass User:\n  id = Id\n  name = String\n```\nCopy\n```\npublic class ObjectBox {\n    private static BoxStore store;\n    public static void init(Context context) {\n        store = MyObjectBox.builder()\n                .androidContext(context)\n                .build();\n    }\n    public static BoxStore get() { return store; }\n}\n```\nCopy\n```\npublic class ExampleApp extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        ObjectBox.init(this);\n    }\n}\n```\nCopy\n```\nobject ObjectBox {\n    lateinit var store: BoxStore\n        private set\n    fun init(context: Context) {\n        store = MyObjectBox.builder()\n                .androidContext(context)\n                .build()\n    }\n}\n```\nCopy\n```\nclass ExampleApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        ObjectBox.init(this)\n    }\n}\n```\nCopy\n```\npublic class ObjectBox {\n    private static BoxStore store;\n    public static void init(Context context) {\n        store = MyObjectBox.builder()\n                .name(\"objectbox-notes-db\")\n                .build();\n    }\n    public static BoxStore get() { return store; }\n}\n```\nCopy\n```\nimport 'package:path/path.dart' as p;\nimport 'package:path_provider/path_provider.dart';\nimport 'objectbox.g.dart'; // created by `flutter pub run build_runner build`\nclass ObjectBox {\n  /// The Store of this app.\n  late final Store store;\n  ObjectBox._create(this.store) {\n    // Add any additional setup code, e.g. build queries.\n  }\n  /// Create an instance of ObjectBox to use throughout the app.\n  static Future<ObjectBox> create() async {\n    final docsDir = await getApplicationDocumentsDirectory();\n    // Future<Store> openStore() {...} is defined in the generated objectbox.g.dart\n    final store = await openStore(directory: p.join(docsDir.path, \"obx-example\"));\n    return ObjectBox._create(store);\n  }\n}\n```\nCopy\n```\n/// Provides access to the ObjectBox Store throughout the app.\nlate ObjectBox objectbox;\nFuture<void> main() async {\n  // This is required so ObjectBox can get the application directory\n  // to store the database in.\n  WidgetsFlutterBinding.ensureInitialized();\n  objectbox = await ObjectBox.create();\n  runApp(MyApp());\n}\n```\nCopy\n```\nimport 'objectbox.g.dart'; // created by `dart pub run build_runner build`\nvoid main() {\n  // Store openStore() {...} is defined in the generated objectbox.g.dart\n  final store = openStore();\n  // your app code ...\n  store.close(); // don't forget to close the store\n}\n```\nCopy\n```\nfrom objectbox import Store\nstore = Store()\n```\nCopy\n```\nBoxStore inMemoryStore = MyObjectBox.builder()\n        .androidContext(context)\n        .inMemory(\"test-db\")\n        .build();\n```\nCopy\n```\n final inMemoryStore =\n     Store(getObjectBoxModel(), directory: \"memory:test-db\");\n```\nCopy\n```\nstore = Store(directory=\"memory:testdata\")\n```\nCopy\n```\nBox<User> userBox = store.boxFor(User.class);\nBox<Order> orderBox = store.boxFor(Order.class);\n```\nCopy\n```\nval userBox = store.boxFor(User::class)\nval orderBox = store.boxFor(Order::class)\n```\nCopy\n```\nfinal userBox = store.box<User>();\nfinal orderBox = store.box<Order>();\n```\nCopy\n```\nuser_box = store.box(User)\norder_box = store.box(Order)\n```\nCopy\n```\nUser user = new User(\"Tina\");\nuserBox.put(user);\nList<User> users = getNewUsers();\nuserBox.put(users);\n```\nCopy\n```\nval user = User(name = \"Tina\")\nuserBox.put(user)\nval users: List<User> = getNewUsers()\nuserBox.put(users)\n```\nCopy\n```\nfinal user = User(name: 'Tina');\nuserBox.put(user);\nfinal users = getNewUsers();\nuserBox.putMany(users);\n```\nCopy\n```\nuser = User(name=\"Tina\")\nuser_box.put(user)\nusers = get_new_users()\nuser_box.put(*users)\n```\nCopy\n```\nUser user = userBox.get(userId);\nList<User> users = userBox.getAll();\n```\nCopy\n```\nval user = userBox[userId]\nval users = userBox.all\n```\nCopy\n```\nfinal user = userBox.get(userId);\nfinal users = userBox.getMany(userIds);\nfinal users = userBox.getAll();\n```\nCopy\n```\nuser = user_box.get(user_id)\nusers = user_box.get_all()\n```\nCopy\n```\nQuery<User> query = userBox\n    .query(User_.name.equal(\"Tom\"))\n    .order(User_.name)\n    .build();\nList<User> results = query.find();\nquery.close();\n```\nCopy\n```\nval query = userBox\n    .query(User_.name.equal(\"Tom\"))\n    .order(User_.name)\n    .build()\nval results = query.find()\nquery.close()\n```\nCopy\n```\nfinal query =\n    (userBox.query(User_.name.equals('Tom'))..order(User_.name)).build();\nfinal results = query.find();\nquery.close();\n```\nCopy\n```\nquery = user_box \\\n    .query(User.name.equals('Tom')) \\\n    .build()\nresults = query.find()\n```\nCopy\n```\nboolean isRemoved = userBox.remove(userId);\nuserBox.remove(users);\n// alternatively:\nuserBox.removeByIds(userIds);\nuserBox.removeAll();\n```\nCopy\n```\nval isRemoved = userBox.remove(userId)\nuserBox.remove(users)\n// alternatively:\nuserBox.removeByIds(userIds)\nuserBox.removeAll()\n```\nCopy\n```\nfinal isRemoved = userBox.remove(userId);\nuserBox.removeMany(userIds);\nuserBox.removeAll();\n```\nCopy\n```\nis_removed = user_box.remove(user_id)\nuser_box.remove_all()\n```\nCopy\n```\nlong userCount = userBox.count();\n```\nCopy\n```\nval userCount = userBox.count()\n```\nCopy\n```\nfinal userCount = userBox.count();\n```\nCopy\n```\nuser_box.count()\n```\nCopy\n```\nstore.callInTxAsync(() -> {\n    Box<User> box = store.boxFor(User.class);\n    String name = box.get(userId).name;\n    box.remove(userId);\n    return name;\n}, (result, error) -> {\n    if (error != null) {\n        System.out.println(\"Failed to remove user with id \" + userId);\n    } else {\n        System.out.println(\"Removed user with name: \" + result);\n    }\n});\n```\nCopy\n```\n// Create a cached thread pool executor optimized for ObjectBox.\n// Use ObjectBoxThreadPoolExecutor directly for more customization options.\nprivate ObjectBoxThreadPoolExecutor executor = store.newCachedThreadPoolExecutor();\ntry {\n    Future<String> future = executor.submit(() -> store.callInTx(() -> {\n        Box<User> box = store.boxFor(User.class);\n        String name = box.get(userId).name;\n        box.remove(userId);\n        return name;\n    }));\n    String result = future.get();\n    System.out.println(\"Removed user with name: \" + result);\n} catch (Exception e) {\n    System.err.println(\"Failed to remove user with id \" + userId);\n}\n```\nCopy\n```\ntry {\n    val name = store.awaitCallInTx {\n        val box = store.boxFor(User::class.java)\n        val name = box.get(userId).name\n        box.remove(userId)\n        name\n    }\n    println(\"Removed user with name $name\")\n} catch (_: Exception) {\n    println(\"Failed to remove user with id $userId\")\n}\n```\nCopy\n```\n// Create a Coroutine Dispatcher optimized for ObjectBox.\n// Use ObjectBoxThreadPoolExecutor and asCoroutineDispatcher() directly\n// for more customization options.\nprivate val dispatcher = store.newCachedThreadPoolDispatcher()\n// Within a suspend function\nval name = withContext(dispatcher) {\n    store.callInTx {\n        val box = store.boxFor(User::class.java)\n        val name = box.get(userId).name\n        box.remove(userId)\n        name\n    }\n}\nprintln(\"Removed user with name $name\")\n```\nCopy\n```\nfinal user = User(name: 'Tina');\nFuture<int> idFuture = userBox.putAsync(user);\n...\nfinal id = await idFuture;\nuserBox.get(id); // after the future completed, the object is inserted\n```\nCopy\n```\n// The callback must be a function that can be sent to an isolate:\n// either a top-level function, static method or a closure that only\n// captures objects that can be sent to an isolate.\nString? readNameAndRemove(Store store, int objectId) {\n  var box = store.box<User>();\n  final nameOrNull = box.get(objectId)?.name;\n  box.remove(objectId);\n  return nameOrNull;\n}\nfinal nameOrNull =\n  await store.runInTransactionAsync(TxMode.write, readNameAndRemove, objectId);\n```\nCopy\n```\nfor (int i = 0; i < 100; i++) {\n  userBox.putQueued(User(name: 'User $i'));\n}\n// Optional: wait until submitted items are processed.\nstore.awaitQueueSubmitted();\nexpect(userBox.count(), equals(100));\n```\nCopy\n```\nUser user = new User();\n// user.id == 0\nbox.put(user);\n// user.id != 0\nlong id = user.id;\n```\nCopy\n```\nval user = User()\n// user.id == 0\nbox.put(user)\n// user.id != 0\nval id = user.id\n```\nCopy\n```\nfinal user = User();\n// user.id == 0\nbox.put(user);\n// user.id != 0\nfinal id = user.id;\n```\nCopy\n```\nuser = User()\nbox.put(user)\nid: int = user.id\n```",
  "timestamp": 1769974089866,
  "title": "Getting started | ObjectBox Docs"
}