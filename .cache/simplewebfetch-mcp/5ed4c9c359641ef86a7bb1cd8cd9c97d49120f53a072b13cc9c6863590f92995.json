{
  "url": "https://riverpod.dev/docs/whats_new",
  "markdown": "# What's new in Riverpod 3.0 | Riverpod\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n[\n![Riverpod](https://riverpod.dev/img/logo.png)![Riverpod](https://riverpod.dev/img/logo.png)\n**Riverpod**](https://riverpod.dev/)\n[Docs](https://riverpod.dev/docs/introduction/getting_started)\n[English](#)\n-   [English](https://riverpod.dev/docs/whats_new)\n-   [Français](https://riverpod.dev/fr/docs/whats_new)\n-   [한국어](https://riverpod.dev/ko/docs/whats_new)\n-   [日本語](https://riverpod.dev/ja/docs/whats_new)\n-   [Español](https://riverpod.dev/es/docs/whats_new)\n-   [বাংলা](https://riverpod.dev/bn/docs/whats_new)\n-   [Deutsch](https://riverpod.dev/de/docs/whats_new)\n-   [Italiano](https://riverpod.dev/it/docs/whats_new)\n-   [Русский](https://riverpod.dev/ru/docs/whats_new)\n-   [Türkçe](https://riverpod.dev/tr/docs/whats_new)\n-   [简体中文](https://riverpod.dev/zh-Hans/docs/whats_new)\n[GitHub](https://github.com/rrousselGit/riverpod)\nSearch\n-   [What's new in Riverpod 3.0](https://riverpod.dev/docs/whats_new)\n-   [Migrating from 2.0 to 3.0](https://riverpod.dev/docs/3.0_migration)\n-   [FAQ](https://riverpod.dev/docs/root/faq)\n-   [DO/DON'T](https://riverpod.dev/docs/root/do_dont)\n-   [Getting started](https://riverpod.dev/docs/introduction/getting_started)\n-   Tutorials\n    -   [Your first Riverpod app](https://riverpod.dev/docs/tutorials/first_app)\n-   Concepts\n    -   [Providers](https://riverpod.dev/docs/concepts2/providers)\n    -   [Consumers](https://riverpod.dev/docs/concepts2/consumers)\n    -   [ProviderContainers/ProviderScopes](https://riverpod.dev/docs/concepts2/containers)\n    -   [Refs](https://riverpod.dev/docs/concepts2/refs)\n    -   [Automatic disposal](https://riverpod.dev/docs/concepts2/auto_dispose)\n    -   [Family](https://riverpod.dev/docs/concepts2/family)\n    -   [Mutations (experimental)](https://riverpod.dev/docs/concepts2/mutations)\n    -   [Offline persistence (experimental)](https://riverpod.dev/docs/concepts2/offline)\n    -   [Automatic retry](https://riverpod.dev/docs/concepts2/retry)\n    -   [ProviderObservers](https://riverpod.dev/docs/concepts2/observers)\n    -   [Provider overrides](https://riverpod.dev/docs/concepts2/overrides)\n    -   [Scoping providers](https://riverpod.dev/docs/concepts2/scoping)\n    -   [About code generation](https://riverpod.dev/docs/concepts/about_code_generation)\n    -   [About hooks](https://riverpod.dev/docs/concepts/about_hooks)\n-   Guides\n    -   [Testing your providers](https://riverpod.dev/docs/how_to/testing)\n    -   [How to reduce provider/widget rebuilds](https://riverpod.dev/docs/how_to/select)\n    -   [How to eagerly initialize providers](https://riverpod.dev/docs/how_to/eager_initialization)\n    -   [Implementing pull-to-refresh](https://riverpod.dev/docs/how_to/pull_to_refresh)\n    -   [How to debounce/cancel network requests](https://riverpod.dev/docs/how_to/cancel)\n-   References\n    -   [All Providers](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/Provider-class.html)\n    -   [Containers/Scopes](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/ProviderContainer-class.html)\n    -   [Refs](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/Ref-class.html)\n    -   [Consumers](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/ConsumerWidget-class.html)\n    -   [Offline persistence (experimental)](https://pub.dev/documentation/hooks_riverpod/latest/experimental_persist/Storage-class.html)\n    -   [Mutations (experimental)](https://pub.dev/documentation/hooks_riverpod/latest/experimental_mutation/Mutation-class.html)\n    -   [core](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/AsyncValue-class.html)\n    -   [misc](https://pub.dev/documentation/hooks_riverpod/latest/misc/)\n-   Migration guides\n    -   [Riverpod for Provider Users](https://riverpod.dev/docs/from_provider/quickstart)\n    -   [From \\`StateNotifier\\`](https://riverpod.dev/docs/migration/from_state_notifier)\n    -   [From \\`ChangeNotifier\\`](https://riverpod.dev/docs/migration/from_change_notifier)\n    -   [^0.14.0 to ^1.0.0](https://riverpod.dev/docs/migration/0.14.0_to_1.0.0)\n    -   [^0.13.0 to ^0.14.0](https://riverpod.dev/docs/migration/0.13.0_to_0.14.0)\n-   [Official examples](https://github.com/rrousselGit/riverpod/tree/master/examples/counter)\n-   [Third party examples](https://github.com/dhafinrayhan/dummymart)\n-   [](https://riverpod.dev/)\n-   What's new in Riverpod 3.0\nOn this page\n# What's new in Riverpod 3.0\nWelcome to Riverpod 3.0!\nThis update includes many long-due features, bug fixes, and simplifications of the API.\nThis version is a transition period toward a simpler, unified Riverpod.\ncaution\nThis version contains a few life-cycle changes. Those could break your app in subtle ways. Upgrade carefully.\nFor the migration guide, please refer to the [migration page](https://riverpod.dev/docs/3.0_migration).\nSome of the key highlights include:\n-   [Offline persistence (experimental)](#offline-persistence-experimental) - Providers can now opt-in to be persisted to a database\n-   [Mutations (experimental)](#mutations-experimental) - A new mechanism to enable interfaces to react to side-effects\n-   [Automatic retry](#automatic-retry) - Providers now refresh when they fail, with exponential backoff\n-   [`Ref.mounted`](#refmounted) - Similar to `BuildContext.mounted`, but for `Ref`.\n-   [Generic support (code-generation)](#generic-support-code-generation) - Generated providers can now define type parameters\n-   [Pause/Resume support](#pauseresume-support) - Temporarily pause a listener when using `ref.listen`\n-   [Unification of the Public APIs](#unification-of-the-public-apis) - Behaviors are unified and duplicate interfaces are fused\n-   [Provider life-cycle changes](#provider-life-cycle-changes) - Slight tweaks to how providers behave, to better fit modern code\n-   [New testing utilities](#new-testing-utilities):\n    -   [`ProviderContainer.test`](#providercontainertest) - A test util that creates a container and automatically disposes it after the test ends.\n    -   [`NotifierProvider.overrideWithBuild`](#notifierprovideroverridewithbuild) - A way to mock only `Notifier.build`, without mocking the whole notifier.\n    -   [`Future/StreamProvider.overrideWithValue`](#futurestreamprovideroverridewithvalue) - The old utilities are back\n    -   [`WidgetTester.container`](#widgettestercontainer) - A helper method to obtain the `ProviderContainer` inside widget tests\n-   [Statically safe scoping](#statically-safe-scoping-code-generation-only) - New lint rules are added to detect when an override is missing\n## Offline persistence (experimental)[​](#offline-persistence-experimental \"Direct link to Offline persistence (experimental)\")\ninfo\nThis feature is experimental and not yet stable. It is usable, but the API may change in breaking ways without a major version bump.\nOffline persistence is a new feature that enables caching a provider locally on the device. Then, when the application is closed and reopened, the provider can be restored from the cache.\nOffline persistence is opt-in, and supported by all \"Notifier\" providers, and regardless of if you use code generation or not.\nRiverpod only includes interfaces to interact with a database. It does not include a database itself. You can use any database you want, as long as it implements the interfaces.\nAn official package for SQLite is maintained: [riverpod\\_sqflite](https://pub.dev/packages/riverpod_sqflite).\nAs a short demo, here's how you can use offline persistence:\n-   riverpod\n-   riverpod\\_generator\n```\n// A example showcasing JsonSqFliteStorage without code generation.final storageProvider = FutureProvider<JsonSqFliteStorage>((ref) async {  // Initialize SQFlite. We should share the Storage instance between providers.  return JsonSqFliteStorage.open(    join(await getDatabasesPath(), 'riverpod.db'),  );});/// A serializable Todo class.class Todo {  const Todo({    required this.id,    required this.description,    required this.completed,  });  Todo.fromJson(Map<String, dynamic> json)      : id = json['id'] as int,        description = json['description'] as String,        completed = json['completed'] as bool;  final int id;  final String description;  final bool completed;  Map<String, dynamic> toJson() {    return {      'id': id,      'description': description,      'completed': completed,    };  }}final todosProvider =    AsyncNotifierProvider<TodosNotifier, List<Todo>>(TodosNotifier.new);class TodosNotifier extends AsyncNotifier<List<Todo>>{  @override  FutureOr<List<Todo>> build() async {    // We call persist at the start of our 'build' method.    // This will:    // - Read the DB and update the state with the persisted value the first    //   time this method executes.    // - Listen to changes on this provider and write those changes to the DB.    persist(      // We pass our JsonSqFliteStorage instance. No need to \"await\" the Future.      // Riverpod will take care of that.      ref.watch(storageProvider.future),      // A unique key for this state.      // No other provider should use the same key.      key: 'todos',      // By default, state is cached offline only for 2 days.      // We can optionally uncomment the following line to change cache duration.      // options: const StorageOptions(cacheTime: StorageCacheTime.unsafe_forever),      encode: jsonEncode,      decode: (json) {        final decoded = jsonDecode(json) as List;        return decoded            .map((e) => Todo.fromJson(e as Map<String, Object?>))            .toList();      },    );      // We asynchronously fetch todos from the server.      // During the await, the persisted todo list will be available.      // After the network request completes, the server state will take precedence      // over the persisted state.      final todos = await fetchTodos();      return todos;  }  Future<void> add(Todo todo) async {    // When modifying the state, no need for any extra logic to persist the change.    // Riverpod will automatically cache the new state and write it to the DB.    state = AsyncData([...await future, todo]);  }}\n```\n```\n@riverpodFuture<JsonSqFliteStorage> storage(Ref ref) async {  // Initialize SQFlite. We should share the Storage instance between providers.  return JsonSqFliteStorage.open(    join(await getDatabasesPath(), 'riverpod.db'),  );}/// A serializable Todo class. We're using Freezed for simple serialization.@freezedabstract class Todo with _$Todo {  const factory Todo({    required int id,    required String description,    required bool completed,  }) = _Todo;  factory Todo.fromJson(Map<String, dynamic> json) => _$TodoFromJson(json);}@riverpod@JsonPersist()class TodosNotifier extends _$TodosNotifier {  @override  FutureOr<List<Todo>> build() async {    // We call persist at the start of our 'build' method.    // This will:    // - Read the DB and update the state with the persisted value the first    //   time this method executes.    // - Listen to changes on this provider and write those changes to the DB.    persist(      // We pass our JsonSqFliteStorage instance. No need to \"await\" the Future.      // Riverpod will take care of that.      ref.watch(storageProvider.future),      // By default, state is cached offline only for 2 days.      // We can optionally uncomment the following line to change cache duration.      // options: const StorageOptions(cacheTime: StorageCacheTime.unsafe_forever),    );    // We asynchronously fetch todos from the server.    // During the await, the persisted todo list will be available.    // After the network request completes, the server state will take precedence    // over the persisted state.    final todos = await fetchTodos();    return todos;  }  Future<void> add(Todo todo) async {    // When modifying the state, no need for any extra logic to persist the change.    // Riverpod will automatically cache the new state and write it to the DB.    state = AsyncData([...await future, todo]);  }}\n```\n## Mutations (experimental)[​](#mutations-experimental \"Direct link to Mutations (experimental)\")\ninfo\nThis feature is experimental and not yet stable. It is usable, but the API may change in breaking ways without a major version bump.\nA new feature called \"mutations\" is introduced in Riverpod 3.0.\nThis feature solves two problems:\n-   It empowers the UI to react to \"side-effects\" (such as form submissions, button clicks, etc), to enable it to show loading/success/error messages. Think \"Show a toast when a form is submitted successfully\".\n-   It solves an issue where `onPressed` callbacks combined with [Ref.read](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Ref/read.html) and [Automatic disposal](https://riverpod.dev/docs/concepts2/auto_dispose) could cause providers to be disposed while a side-effect is still in progress.\nThe TL;DR is, a new [Mutation](https://pub.dev/documentation/riverpod/latest/experimental_mutation/Mutation-class.html) object is added. It is declared as a top-level final variable, like providers:\n```\nfinal addTodoMutation = Mutation<void>();\n```\nAfter that, your UI can use `ref.listen`/`ref.watch` to listen to the state of mutations:\n```\nclass AddTodoButton extends ConsumerWidget {  @override  Widget build(BuildContext context, WidgetRef ref) {    // Listen to the status of the \"addTodo\" side-effect    final addTodo = ref.watch(addTodoMutation);    return switch (addTodo) {      // No side-effect is in progress      // Let's show a submit button      MutationIdle() => ElevatedButton(        // Trigger the side-effect on click        onPressed: () {          // TODO see explanation after the code snippet        },        child: const Text('Submit'),      ),      // The side-effect is in progress. We show a spinner      MutationPending() => const CircularProgressIndicator(),      // The side-effect failed. We show a retry button      MutationError() => ElevatedButton(        onPressed: () {          // TODO see explanation after the code snippet        },        child: const Text('Retry'),      ),      // The side-effect was successful. We show a success message      MutationSuccess() => const Text('Todo added!'),    };  }}\n```\nLast but not least, inside our `onPressed` callback, we can trigger our side-effect as followed:\n```\nonPressed: () {  addTodoMutation.run(ref, (tsx) async {    // This is where we run our side-effect.    // Here, we typically obtain a Notifier and call a method on it.    await tsx.get(todoListProvider.notifier).addTodo('New Todo');  });}\n```\nnote\nNote how we called [tsx.get](https://pub.dev/documentation/riverpod/latest/experimental_mutation/MutationTransaction/get.html) here instead of [Ref.read](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Ref/read.html).\nThis is a feature unique to mutations. That [tsx.get](https://pub.dev/documentation/riverpod/latest/experimental_mutation/MutationTransaction/get.html) obtains the state of a provider, but keep it alive until the mutation is completed.\n## Automatic retry[​](#automatic-retry \"Direct link to Automatic retry\")\nStarting 3.0, providers that fail during initialization will automatically retry. The retry is done with an exponential backoff, and the provider will be retried until it succeeds or is disposed. This helps when an operation fails due to a temporary issue, such as a lack of network connection.\nThe default behavior retries any error, and starts with a 200ms delay that doubles after each retry up to 6.4 seconds.\nThis can be customized for all providers on [ProviderContainer](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderContainer-class.html)/[ProviderScope](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html) by passing a `retry` parameter:\n-   ProviderScope\n-   ProviderContainer\n```\nvoid main() {  runApp(    ProviderScope(      // You can customize the retry logic, such as to skip      // specific errors or add a limit to the number of retries      // or change the delay      retry: (retryCount, error) {        if (error is SomeSpecificError) return null;        if (retryCount > 5) return null;        return Duration(seconds: retryCount * 2);      },      child: MyApp(),    ),  );}\n```\n```\nvoid main() {  final container = ProviderContainer(    // You can customize the retry logic, such as to skip    // specific errors or add a limit to the number of retries    // or change the delay    retry: (retryCount, error) {      if (error is SomeSpecificError) return null;      if (retryCount > 5) return null;      return Duration(seconds: retryCount * 2);    },  );}\n```\nAlternatively, this can be configured on a per-provider basis by passing a `retry` parameter to the provider constructor:\n-   riverpod\n-   riverpod\\_generator\n```\nfinal todoListProvider = NotifierProvider<TodoList, List<Todo>>(  TodoList.new,  retry: (retryCount, error) {    if (error is SomeSpecificError) return null;    if (retryCount > 5) return null;      return Duration(seconds: retryCount * 2);  },);\n```\n```\nDuration retry(int retryCount, Object error) {  if (error is SomeSpecificError) return null;  if (retryCount > 5) return null;  return Duration(seconds: retryCount * 2);}@Riverpod(retry: retry)class TodoList extends _$TodoList {  @override  List<Todo> build() => [];}\n```\n## `Ref.mounted`[​](#refmounted \"Direct link to refmounted\")\nThe long-awaited `Ref.mounted` is finally here! It is similar to `BuildContext.mounted`, but for `Ref`.\nYou can use it to check if a provider is still mounted after an async operation:\n-   riverpod\n-   riverpod\\_generator\n```\nclass TodoList extends Notifier<List<Todo>> {  @override  List<Todo> build() => [];    Future<void> addTodo(String title) async {    // Post the new todo to the server    final newTodo = await api.addTodo(title);    // Check if the provider is still mounted    // after the async operation    if (!ref.mounted) return;      // If it is, update the state    state = [...state, newTodo];  }}\n```\n```\n@riverpodclass TodoList extends _$TodoList {  @override  List<Todo> build() => [];    Future<void> addTodo(String title) async {    // Post the new todo to the server    final newTodo = await api.addTodo(title);    // Check if the provider is still mounted    // after the async operation    if (!ref.mounted) return;      // If it is, update the state    state = [...state, newTodo];  }}\n```\nFor this to work, quite a few life-cycle changes were necessary.\nMake sure to read the [life-cycle changes](#provider-life-cycle-changes) section.\n## Generic support (code-generation)[​](#generic-support-code-generation \"Direct link to Generic support (code-generation)\")\nWhen using code generation, you can now define type parameters for your generated providers. Type parameters work like any other provider parameter, and need to be passed when watching the provider.\n```\n@riverpodT multiply<T extends num>(T a, T b) {  return a * b;}// ...int integer = ref.watch(multiplyProvider<int>(2, 3));double decimal = ref.watch(multiplyProvider<double>(2.5, 3.5));\n```\n## Pause/Resume support[​](#pauseresume-support \"Direct link to Pause/Resume support\")\nIn 2.0, Riverpod already had some form of pause/resume support, but it was fairly limited. With 3.0, all `ref.listen` listeners can be manually paused/resumed on demand:\n```\nfinal subscription = ref.listen(  todoListProvider,  (previous, next) {    // Do something with the new value  },);subscription.pause();subscription.resume();\n```\nAt the same time, Riverpod now pauses providers in various situations:\n-   When a provider is no-longer visible, it is paused (Based off [TickerMode](https://api.flutter.dev/flutter/widgets/TickerMode-class.html)).\n-   When a provider rebuilds, its subscriptions are paused until the rebuild completes.\n-   When a provider is paused, all of its subscriptions are paused too.\nSee the [life-cycle changes](#provider-life-cycle-changes) section for more details.\n## Unification of the Public APIs[​](#unification-of-the-public-apis \"Direct link to Unification of the Public APIs\")\nOne goal of Riverpod 3.0 is to simplify the API. This includes:\n-   Highlighting what is recommended and what is not\n-   Removing needless interface duplicates\n-   Making sure all functionalities function in a consistent way\nFor this sake, a few changes were made:\n### \\[StateProvider\\]/\\[StateNotifierProvider\\] and \\[ChangeNotifierProvider\\] are discouraged and moved to a different import[​](#stateproviderstatenotifierprovider-and-changenotifierprovider-are-discouraged-and-moved-to-a-different-import \"Direct link to stateproviderstatenotifierprovider-and-changenotifierprovider-are-discouraged-and-moved-to-a-different-import\")\nThose providers are not removed, but simply moved to a different import. Instead of:\n```\nimport 'package:riverpod/riverpod.dart';\n```\nYou should now use:\n```\nimport 'package:riverpod/legacy.dart';\n```\nThis is to highlight that those providers are not recommended anymore.\nAt the same time, those are preserved for backward compatibility.\n### AutoDispose interfaces are removed[​](#autodispose-interfaces-are-removed \"Direct link to AutoDispose interfaces are removed\")\nNo, the \"auto-dispose\" feature isn't removed. This only concerns the interfaces. In 2.0, all providers, Refs and Notifiers were duplicated for the sake of auto-dispose ( `Ref` vs `AutoDisposeRef`, `Notifier` vs `AutoDisposeNotifier`, etc). This was done for the sake of having a compilation error in some edge-cases, but came at the cost of a worse API.\nIn 3.0, the interfaces are unified, and the previous compilation error is now implemented as a lint rule (using [riverpod\\_lint](https://pub.dev/packages/riverpod_lint)). What this means concretely is that you can replace all references to `AutoDisposeNotifier` with `Notifier`. The behavior of your code should not change.\n```\nfinal provider = NotifierProvider.autoDispose<MyNotifier, int>(  MyNotifier.new,);- class MyNotifier extends AutoDisposeNotifier<int> {+ class MyNotifier extends Notifier<int> {}\n```\n### \"FamilyNotifier\" and \"Notifier\" are fused[​](#familynotifier-and-notifier-are-fused \"Direct link to \\\"FamilyNotifier\\\" and \\\"Notifier\\\" are fused\")\nSimilarly to the previous point, the `FamilyNotifier` and `Notifier` interfaces are now fused.\nLong story short, instead of:\n```\nfinal provider = NotifierProvider.family<CounterNotifier, int, Argument>(  MyNotifier.new,);class CounterNotifier extends FamilyNotifier<int, Argument> {  @override  int build(Argument arg) => 0;}\n```\nWe now do:\n```\nfinal provider = NotifierProvider.family<CounterNotifier, int, Argument>(  CounterNotifier.new,);class CounterNotifier extends Notifier<int> {  CounterNotifier(this.arg);  final Argument arg;  @override  int build() => 0;}\n```\nThis means that instead of `Notifier`+`FamilyNotifier`+`AutoDisposeNotifier`+`AutoDisposeFamilyNotifier`, we always use the `Notifier` class.\nThis change has no impact on code-generation.\n### One `Ref` to rule them all[​](#one-ref-to-rule-them-all \"Direct link to one-ref-to-rule-them-all\")\nIn Riverpod 2.0, each provider came with its own [Ref](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Ref-class.html) subclass (`FutureProviderRef`, `StreamProviderRef`, etc).\nSome `Ref` had `state` property, some a `future`, or a `notifier`, etc. Although useful, this was a lot of complexity for not much gain. One of the reasons for that is because [Notifier](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Notifier-class.html)s already have the extra properties it had, so the interfaces were redundant.\nIn 3.0, `Ref` is unified. No more generic parameter such as `Ref<T>`, no more `FutureProviderRef`. We only have one thing: `Ref`. What this means in practice is, the syntax for generated providers is simplified:\n```\n-Example example(ExampleRef ref) {+Example example(Ref ref) {  return Example();}\n```\ninfo\nThis does not concern [WidgetRef](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/WidgetRef-class.html), which is intact.\n[Ref](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Ref-class.html) and [WidgetRef](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/WidgetRef-class.html) are two different things.\n### All `updateShouldNotify` now use `==`[​](#all-updateshouldnotify-now-use- \"Direct link to all-updateshouldnotify-now-use-\")\n`updateShouldNotify` is a method that is used to determine if a provider should notify its listeners when a state change occurs. But in 2.0, the implementation of this method varied quite a bit between providers. Some providers used `==`, some `identical`, and some more complex logic.\nStarting 3.0, all providers use `==` to filter notifications.\nThis can impact you in a few ways:\n-   Some of your providers may not notify their listeners anymore in certain situations.\n-   Some listeners may be notified more often than before.\n-   If you have a large data class that overrides `==`, you may see a small performance impact.\nThe most common case where you will be impacted is when using [StreamProvider](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/StreamProvider-class.html)/[StreamNotifier](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/StreamNotifier-class.html), as events of the stream are now filtered using `==`.\nIf you are impacted by those changes, you can override `updateShouldNotify` to use a custom implementation:\n-   riverpod\n-   riverpod\\_generator\n```\nclass TodoList extends StreamNotifier<Todo> {  @override  Stream<Todo> build() => Stream(...);  @override  bool updateShouldNotify(AsyncValue<Todo> previous, AsyncValue<Todo> next) {    // Custom implementation    return true;  }}\n```\n```\n@riverpodclass TodoList extends _$TodoList {  @override  Stream<Todo> build() => Stream(...);  @override  bool updateShouldNotify(AsyncValue<Todo> previous, AsyncValue<Todo> next) {    // Custom implementation    return true;  }}\n```\n## Provider life-cycle changes[​](#provider-life-cycle-changes \"Direct link to Provider life-cycle changes\")\n### Refs and Notifiers can no-longer be interacted with after they have been disposed[​](#refs-and-notifiers-can-no-longer-be-interacted-with-after-they-have-been-disposed \"Direct link to Refs and Notifiers can no-longer be interacted with after they have been disposed\")\nIn 2.0, in some edge-cases you could still interact with things like [Ref](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Ref-class.html) or [Notifier](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Notifier-class.html) after they were disposed. This was not intended and caused various severe bugs.\nIn 3.0, Riverpod will throw an error if you try to interact with a disposed Ref/Notifier.\nYou can use [Ref.mounted](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Ref/mounted.html) to check if a Ref/Notifier is still usable.\n```\nfinal provider = FutureProvider<int>((ref) async {  await Future.delayed(Duration(seconds: 1));  // Abort the provider if it has been disposed during the await.  // You can throw whatever you want and ignore this exception in your error reporting tools.  if (!ref.mounted) throw MyException();  return 42;});\n```\n### When reading a provider results in an exception, the error is now wrapped in a ProviderException[​](#when-reading-a-provider-results-in-an-exception-the-error-is-now-wrapped-in-a-providerexception \"Direct link to When reading a provider results in an exception, the error is now wrapped in a ProviderException\")\nBefore, if a provider threw an error, Riverpod would sometimes rethrow that error directly:\n-   riverpod\n-   riverpod\\_generator\n```\nfinal exampleProvider = FutureProvider<int>((ref) async {  throw StateError('Error');});// ...ElevatedButton(  onPressed: () async {    // This will rethrow the StateError    ref.read(exampleProvider).requireValue;      // This also rethrows the StateError    await ref.read(exampleProvider.future);  },  child: Text('Click me'),);\n```\n```\n@riverpodFuture<int> example(Ref ref) async {  throw StateError('Error');}// ...ElevatedButton(  onPressed: () async {    // This will rethrow the StateError    ref.read(exampleProvider).requireValue;      // This also rethrows the StateError    await ref.read(exampleProvider.future);  },  child: Text('Click me'),);\n```\nIn 3.0, this is changed. Instead, the error will be encapsulated in a `ProviderException` that contains both the original error and its stack trace.\ninfo\n`AsyncValue.error`, `ref.listen(..., onError: ...)` and [ProviderObserver](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderObserver-class.html)s are unaffected by this change, and will still receive the unaltered error.\nThis has multiple benefits:\n-   Debugging is improved, as we have a much better stack trace\n-   It is now possible to determine if a provider failed, or if it is in error state because it depends on another provider that failed.\nFor example, a [ProviderObserver](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderObserver-class.html) can use this to avoid logging the same error twice:\n```\nclass MyObserver extends ProviderObserver {  @override  void providerDidFail(ProviderObserverContext context, Object error, StackTrace stackTrace) {    if (error is ProviderException) {      // The provider didn't fail directly, but instead depends on a failed provider.      // The error was therefore already logged.      return;    }    // Log the error    print('Provider failed: $error');  }}\n```\nThis is used internally by Riverpod in its automatic retry mechanism. The default automatic retry ignores `ProviderException`s:\n```\nProviderContainer(  // Example of the default retry behavior  retry: (retryCount, error) {    if (error is ProviderException) return null;    // ...  },);\n```\n### Listeners inside widgets that are not visible are now paused[​](#listeners-inside-widgets-that-are-not-visible-are-now-paused \"Direct link to Listeners inside widgets that are not visible are now paused\")\nNow that Riverpod has a way to [pause listeners](#pauseresume-support), Riverpod uses that to natively pauses listeners when the widget is not visible. In practice what this means is: Providers that are not used by the visible widget tree are paused.\nAs a concrete example, consider an application with two routes:\n-   A home page, listening to a websocket using a provider\n-   A settings page, which does not rely on that websocket\nIn typical applications, a user first opens the home page _and then_ opens the settings page. This means that while the settings page is open, the homepage is also open, but not visible.\nIn 2.0, the homepage would actively keep listening to the websocket.\nIn 3.0, the websocket provider will instead be paused, possibly saving resources.\n**How it works:**\nRiverpod relies on [TickerMode](https://api.flutter.dev/flutter/widgets/TickerMode-class.html) to determine if a widget is visible or not. And when false, all listeners of a [Consumer](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Consumer-class.html) are paused.\nIt also means that you can rely on [TickerMode](https://api.flutter.dev/flutter/widgets/TickerMode-class.html) yourself to manually control the pause behavior of your consumers. You can voluntarily set the value to true/false to forcibly resume/pause listeners:\n```\nclass MyWidget extends StatelessWidget {  @override  Widget build(BuildContext context) {    return TickerMode(      enabled: false, // This will pause the listeners      child: Consumer(        builder: (context, ref, child) {          // This \"watch\" will be paused          // until TickerMode is set to true          final value = ref.watch(myProvider);          return Text(value.toString());        },      ),    );  }}\n```\n### If a provider is only used by paused providers, it is paused too[​](#if-a-provider-is-only-used-by-paused-providers-it-is-paused-too \"Direct link to If a provider is only used by paused providers, it is paused too\")\nRiverpod 2.0 already had some form of pause/resume support. But it was limited and failed to cover some edge-cases.\nConsider:\n-   riverpod\n-   riverpod\\_generator\n```\nfinal exampleProvider = Provider<int>((ref) {  ref.onCancel(() => print('paused'));  ref.onResume(() => print('resumed'));  return 0;});\n```\n```\n@riverpodint example(Ref ref) {  ref.keepAlive();  ref.onCancel(() => print('paused'));  ref.onResume(() => print('resumed'));  return 0;}\n```\nIn 2.0, if you were to call `ref.read` once on this provider, the state of the provider would be maintained, but 'paused' will be printed. This is because calling `ref.read` does not \"listen\" to the provider. And since the provider is not \"listened\" to, it is paused.\nThis is useful to pause providers that are currently not used! The problem is that in many cases, this optimization does not work.\nFor example, your provider could be used indirectly through another provider.\n-   riverpod\n-   riverpod\\_generator\n```\nfinal anotherProvider = Provider<int>((ref) {  return ref.watch(exampleProvider);});  class MyWidget extends ConsumerWidget {  @override  Widget build(BuildContext context, WidgetRef ref) {    return Button(      onPressed: () {        ref.read(anotherProvider);      },      child: Text('Click me'),    );  }}\n```\n```\n@riverpodint another(Ref ref) {  ref.keepAlive();  return ref.watch(exampleProvider);}class MyWidget extends ConsumerWidget {  @override  Widget build(BuildContext context, WidgetRef ref) {    return Button(      onPressed: () {        ref.read(anotherProvider);      },      child: Text('Click me'),    );  }}\n```\nIn this scenario, if we click on the button once, then `anotherProvider` will start listening to our `exampleProvider`. But `anotherProvider` is no-longer used and will be paused. Yet `exampleProvider` will not be paused, because it thinks that it is still being used.\nAs such, clicking on the button will not print 'paused' anymore.\nIn 3.0, this is fixed. If a provider is only used by paused providers, it is paused too.\n### When a provider rebuilds, its previous subscriptions now are kept until the rebuild completes[​](#when-a-provider-rebuilds-its-previous-subscriptions-now-are-kept-until-the-rebuild-completes \"Direct link to When a provider rebuilds, its previous subscriptions now are kept until the rebuild completes\")\nIn 2.0, there was a known inconvenience when using asynchronous providers combined with 'auto-dispose'.\nSpecifically, when an asynchronous provider watches an auto-dispose provider after an `await`, the \"auto dispose\" could be triggered unexpectedly.\nConsider:\n-   riverpod\n-   riverpod\\_generator\n```\nfinal autoDisposeProvider = StreamProvider.autoDispose<int>((ref) {  ref.onDispose(() => print('disposed'));  ref.onCancel(() => print('paused'));  ref.onResume(() => print('resumed'));  // A stream that emits a value every second  return Stream.periodic(Duration(seconds: 1), (i) => i);});final asynchronousExampleProvider = FutureProvider<int>((ref) async {  print('Before async gap');  // An async gap inside a provider ; typically an API call.  // This will dispose the \"autoDispose\" provider  // before the async operation is completed  await null;    print('after async gap');  // We listen to our auto-dispose provider  // after the async operation  return ref.watch(autoDisposeProvider.future);});void main() {  final container = ProviderContainer();  // This will print 'disposed' every second,  // and will constantly print 0  container.listen(asynchronousExampleProvider, (_, value) {    if (value is AsyncData) print('${value.value}\\n----');  });}\n```\n```\n@riverpodStream<int> autoDispose(Ref ref) {  ref.onDispose(() => print('disposed'));  ref.onCancel(() => print('paused'));  ref.onResume(() => print('resumed'));  // A stream that emits a value every second  return Stream.periodic(Duration(seconds: 1), (i) => i);}@riverpodFuture<int> asynchronousExample(Ref ref) async {  print('Before async gap');  // An async gap inside a provider ; typically an API call.  // This will dispose the \"autoDispose\" provider  // before the async operation is completed  await null;    print('after async gap');  // We listen to our auto-dispose provider  // after the async operation  return ref.watch(autoDisposeProvider.future);}void main() {  final container = ProviderContainer();  // This will print 'disposed' every second,  // and will constantly print 0  container.listen(asynchronousExampleProvider, (_, value) {    if (value is AsyncData) print('${value.value}\\n----');  });}\n```\nIn you run this on [Dartpad](https://dartpad.dev/), you will see that its prints:\n```\n// First printBefore async gapafter async gap0---- // Second and after printspausedBefore async gapdisposed // The 'autoDispose' provider was disposed during the async gap!after async gap0----pausedBefore async gapdisposedafter async gap0----... // And so on every second\n```\nAs you can see, this consistently prints `0` every second, because the `autoDispose` provider repeatedly gets disposed during the async gap. A workaround was to move the `ref.watch` call before the `await` statement. But this is error prone, not very intuitive, and not always possible.\nIn 3.0, this is fixed by delaying the disposal of listeners.\nWhen a provider rebuilds, instead of immediately removing all of its listeners, it [pauses](#pauseresume-support) them.\nThe exact same code will now instead print:\n```\n// First printBefore async gapafter async gap0----pausedBefore async gapafter async gapresumed1----pausedBefore async gapafter async gapresumed2----... // And so on every second\n```\n### Exceptions in providers are rethrown as a `ProviderException`.[​](#exceptions-in-providers-are-rethrown-as-a-providerexception \"Direct link to exceptions-in-providers-are-rethrown-as-a-providerexception\")\nFor the sake of differentiating between \"a provider failed\" from \"a provider is depending on a failed provider\", Riverpod 3.0 now wraps exceptions in a `ProviderException` that contains the original.\nThis means that if you catch errors in your providers, you will need to update your try/catch to inspect the content of `ProviderException`:\n```\ntry {  ref.watch(failingProvider);} on ProviderException catch (e) {  switch (e.exception) {    case SomeSpecificError():      // Handle the specific error    default:      // Handle other errors      rethrow;  }}\n```\n## New testing utilities[​](#new-testing-utilities \"Direct link to New testing utilities\")\n### `ProviderContainer.test`[​](#providercontainertest \"Direct link to providercontainertest\")\nIn 2.0, typical testing code would rely on a custom-made utility called `createContainer`.\nIn 3.0, this utility is now part of Riverpod, and is called `ProviderContainer.test`. It creates a new container, and automatically disposes it after the test ends.\n```\nvoid main() {  test('My test', () {    final container = ProviderContainer.test();    // Use the container    // ...    // The container is automatically disposed after the test ends  });}\n```\nYou can safely do a global search-and-replace for `createContainer` to `ProviderContainer.test`.\n### `NotifierProvider.overrideWithBuild`[​](#notifierprovideroverridewithbuild \"Direct link to notifierprovideroverridewithbuild\")\nIt is now possible to mock only the `Notifier.build` method, without mocking the whole notifier. This is useful when you want to initialize your notifier with a specific state, but still want to use the original implementation of the notifier.\n-   riverpod\n-   riverpod\\_generator\n```\nclass MyNotifier extends Notifier<int> {  @override  int build() => 0;  void increment() {    state++;  }}final myProvider = NotifierProvider<MyNotifier, int>(MyNotifier.new);void main() {  final container = ProviderContainer.test(    overrides: [      myProvider.overrideWithBuild((ref) {        // Mock the build method to start at 42.        // The \"increment\" method is unaffected.        return 42;      }),    ],  );}\n```\n```\n@riverpodclass MyNotifier extends _$MyNotifier {  @override  int build() => 0;  void increment() {    state++;  }}void main() {  final container = ProviderContainer.test(    overrides: [      myProvider.overrideWithBuild((ref) {        // Mock the build method to start at 42.        // The \"increment\" method is unaffected.        return 42;      }),    ],  );}\n```\n### `Future/StreamProvider.overrideWithValue`[​](#futurestreamprovideroverridewithvalue \"Direct link to futurestreamprovideroverridewithvalue\")\nA while back, `FutureProvider.overrideWithValue` and `StreamProvider.overrideWithValue` were removed \"temporarily\" from Riverpod.\nThey are finally back!\n-   riverpod\n-   riverpod\\_generator\n```\nfinal myFutureProvider = FutureProvider<int>((ref) async {  return 42;});void main() {  final container = ProviderContainer.test(    overrides: [      // Initializes the provider with a value.      // Changing the override will update the value.      myFutureProvider.overrideWithValue(AsyncValue.data(42)),    ],  );}\n```\n```\n@riverpodFuture<int> myFutureProvider() async {  return 42;}void main() {  final container = ProviderContainer.test(    overrides: [      // Initializes the provider with a value.      // Changing the override will update the value.      myFutureProvider.overrideWithValue(AsyncValue.data(42)),    ],  );}\n```\n### `WidgetTester.container`[​](#widgettestercontainer \"Direct link to widgettestercontainer\")\nA simple way to access the `ProviderContainer` in your widget tree.\n```\nvoid main() {  testWidgets('can access a ProviderContainer', (tester) async {    await tester.pumpWidget(const ProviderScope(child: MyWidget()));    ProviderContainer container = tester.container();  });}\n```\nSee the [WidgetTester.container](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/RiverpodWidgetTesterX/container.html) extension for more information.\n## Custom ProviderListenables[​](#custom-providerlistenables \"Direct link to Custom ProviderListenables\")\nIt is now possible to create custom [ProviderListenable](https://pub.dev/documentation/riverpod/latest/misc/ProviderListenable-class.html)s in Riverpod 3.0. This is doable using [SyncProviderTransformerMixin](https://pub.dev/documentation/riverpod/latest/misc/SyncProviderTransformerMixin-mixin.html).\nThe following example implements a variable of `provider.select`, where the callback returns a boolean instead of the selected value.\n```\nfinal class Where<T> with SyncProviderTransformerMixin<T, T> {  Where(this.source, this.where);  @override  final ProviderListenable<T> source;  final bool Function(T previous, T value) where;  @override  ProviderTransformer<T, T> transform(    ProviderTransformerContext<T, T> context,  ) {     return ProviderTransformer(       initState: (_) => context.sourceState.requireValue,       listener: (self, previous, next) {         if (where(previous, next))           self.state = next;       },     );  }}extension<T> on ProviderListenable<T> {  ProviderListenable<T> where(    bool Function(T previous, T value) where,  ) => Where<T>(this, where);}\n```\nUsed as `ref.watch(provider.where((previous, value) => value > 0))`.\n## Statically safe scoping (code-generation only)[​](#statically-safe-scoping-code-generation-only \"Direct link to Statically safe scoping (code-generation only)\")\nThrough [riverpod\\_lint](https://pub.dev/packages/riverpod_lint), Riverpod now includes a way to detect when scoping is used incorrectly. This lints detects when an override is missing, to avoid runtime errors.\nConsider:\n```\n// A typical \"scoped provider\"@Riverpod(dependencies: [])Future<int> myFutureProvider() => throw UnimplementedError();\n```\nTo use this provider, you have two options.\nIf neither of the following options are used, the provider will throw an error at runtime.\n-   Override the provider using `ProviderScope` before using it:\n    ```\n    class MyWidget extends StatelessWidget {  @override  Widget build(BuildContext context) {    return ProviderScope(      overrides: [        myFutureProvider.overrideWithValue(AsyncValue.data(42)),      ],      // A consumer is necessary to access the overridden provider      child: Consumer(        builder: (context, ref, child) {          // Use the provider          final value = ref.watch(myFutureProvider);          return Text(value.toString());        },      ),    );  }}\n    ```\n-   Specify `@Dependencies` on whatever uses the scoped provider to indicate that it depends on it.\n    ```\n    @Dependencies([myFuture])class MyWidget extends ConsumerWidget {  @override  Widget build(BuildContext context, WidgetRef ref) {    // Use the provider    final value = ref.watch(myFutureProvider);    return Text(value.toString());  }}\n    ```\n    After specifying `@Dependencies`, all usages of `MyWidget` will require the same two options as above:\n    -   Either override the provider using `ProviderScope` before using `MyWidget`\n        ```\n        void main() {  runApp(    ProviderScope(      overrides: [        myFutureProvider.overrideWithValue(AsyncValue.data(42)),      ],      child: MyWidget(),    ),  );}\n        ```\n    -   Or specify `@Dependencies` on whatever uses `MyWidget` to indicate that it depends on it.\n        ```\n        @Dependencies([myFuture])class MyApp extends ConsumerWidget {  @override  Widget build(BuildContext context, WidgetRef ref) {     // MyApp indirectly uses scoped providers through MyWidget     return MyWidget();  }}\n        ```\n## Other changes[​](#other-changes \"Direct link to Other changes\")\n### AsyncValue[​](#asyncvalue \"Direct link to AsyncValue\")\n[AsyncValue](https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/AsyncValue-class.html) received various changes.\n-   It is now \"sealed\". This enables exhaustive pattern matching:\n    ```\n    AsyncValue<int> value;switch (value) {  case AsyncData():    print('data');  case AsyncError():    print('error');  case AsyncLoading():    print('loading');  // No default case needed}\n    ```\n-   `valueOrNull` has been renamed to `value`. The old `value` is removed, as its behavior related to errors was odd. To migrate, do a global search-and-replace of `valueOrNull` -> `value`.\n-   `AsyncValue.isFromCache` has been added.\n    This flag is set when a value is obtained through offline persistence. It enables your UI to differentiate state coming from the database and state from the server.\n-   An optional `progress` property is available on `AsyncLoading`. This enables your providers to define the current progress for a request:\n    -   riverpod\n    -   riverpod\\_generator\n    ```\n    class MyNotifier extends AsyncNotifier<User> {  @override  Future<User> build() async {    // You can optionally pass a \"progress\" to AsyncLoading    state = AsyncLoading(progress: .0);    await fetchSomething();    state = AsyncLoading(progress: 0.5);      return User();  }}\n    ```\n    ```\n    @riverpodclass MyNotifier extends _$MyNotifier {  @override  Future<User> build() async {    // You can optionally pass a \"progress\" to AsyncLoading    state = AsyncLoading(progress: .0);    await fetchSomething();    state = AsyncLoading(progress: 0.5);        return User();  }}\n    ```\n### All Ref listeners now return a way to remove the listener[​](#all-ref-listeners-now-return-a-way-to-remove-the-listener \"Direct link to All Ref listeners now return a way to remove the listener\")\nIt is now possible to \"unsubscribe\" to the various life-cycles listeners:\n-   riverpod\n-   riverpod\\_generator\n```\nfinal exampleProvider = FutureProvider<int>((ref) {  // onDispose and other life-cycle listeners return a function  // to remove the listener.  final removeListener = ref.onDispose(() => print('dispose));  // Simply call the function to remove the listener:  removeListener();     // ...});\n```\n```\n@riverpodFuture<int> example(Ref ref) {  // onDispose and other life-cycle listeners return a function  // to remove the listener.  final removeListener = ref.onDispose(() => print('dispose));  // Simply call the function to remove the listener:  removeListener();    // ...}\n```\n### Weak listeners - listen to a provider without preventing auto-dispose.[​](#weak-listeners---listen-to-a-provider-without-preventing-auto-dispose \"Direct link to Weak listeners - listen to a provider without preventing auto-dispose.\")\nWhen using `Ref.listen`, you can optionally specify `weak: true`:\n-   riverpod\n-   riverpod\\_generator\n```\nfinal exampleProvider = FutureProvider<int>((ref) {  ref.listen(    anotherProvider,    // Specify the flag    weak: true,    (previous, next) {},  );    // ...});\n```\n```\n@riverpodFuture<int> example(Ref ref) {  ref.listen(    anotherProvider,    // Specify the flag    weak: true,    (previous, next) {},  );    // ...}\n```\nSpecifying this flag will tell Riverpod that it can still dispose the listened provider if it stops being used.\nThis flag is an advanced feature to help with some niche use-cases regarding combining multiple \"sources of truth\" in a single provider.\n[Edit this page](https://github.com/rrousselGit/riverpod/edit/master/website/docs/whats_new.mdx)\n[\nNext\nMigrating from 2.0 to 3.0\n](https://riverpod.dev/docs/3.0_migration)\n-   [Offline persistence (experimental)](#offline-persistence-experimental)\n-   [Mutations (experimental)](#mutations-experimental)\n-   [Automatic retry](#automatic-retry)\n-   [`Ref.mounted`](#refmounted)\n-   [Generic support (code-generation)](#generic-support-code-generation)\n-   [Pause/Resume support](#pauseresume-support)\n-   [Unification of the Public APIs](#unification-of-the-public-apis)\n    -   [StateProvider/StateNotifierProvider and ChangeNotifierProvider are discouraged and moved to a different import](#stateproviderstatenotifierprovider-and-changenotifierprovider-are-discouraged-and-moved-to-a-different-import)\n    -   [AutoDispose interfaces are removed](#autodispose-interfaces-are-removed)\n    -   [\"FamilyNotifier\" and \"Notifier\" are fused](#familynotifier-and-notifier-are-fused)\n    -   [One `Ref` to rule them all](#one-ref-to-rule-them-all)\n    -   [All `updateShouldNotify` now use `==`](#all-updateshouldnotify-now-use-)\n-   [Provider life-cycle changes](#provider-life-cycle-changes)\n    -   [Refs and Notifiers can no-longer be interacted with after they have been disposed](#refs-and-notifiers-can-no-longer-be-interacted-with-after-they-have-been-disposed)\n    -   [When reading a provider results in an exception, the error is now wrapped in a ProviderException](#when-reading-a-provider-results-in-an-exception-the-error-is-now-wrapped-in-a-providerexception)\n    -   [Listeners inside widgets that are not visible are now paused](#listeners-inside-widgets-that-are-not-visible-are-now-paused)\n    -   [If a provider is only used by paused providers, it is paused too](#if-a-provider-is-only-used-by-paused-providers-it-is-paused-too)\n    -   [When a provider rebuilds, its previous subscriptions now are kept until the rebuild completes](#when-a-provider-rebuilds-its-previous-subscriptions-now-are-kept-until-the-rebuild-completes)\n    -   [Exceptions in providers are rethrown as a `ProviderException`.](#exceptions-in-providers-are-rethrown-as-a-providerexception)\n-   [New testing utilities](#new-testing-utilities)\n    -   [`ProviderContainer.test`](#providercontainertest)\n    -   [`NotifierProvider.overrideWithBuild`](#notifierprovideroverridewithbuild)\n    -   [`Future/StreamProvider.overrideWithValue`](#futurestreamprovideroverridewithvalue)\n    -   [`WidgetTester.container`](#widgettestercontainer)\n-   [Custom ProviderListenables](#custom-providerlistenables)\n-   [Statically safe scoping (code-generation only)](#statically-safe-scoping-code-generation-only)\n-   [Other changes](#other-changes)\n    -   [AsyncValue](#asyncvalue)\n    -   [All Ref listeners now return a way to remove the listener](#all-ref-listeners-now-return-a-way-to-remove-the-listener)\n    -   [Weak listeners - listen to a provider without preventing auto-dispose.](#weak-listeners---listen-to-a-provider-without-preventing-auto-dispose)\nDocs\n-   [Getting started](https://riverpod.dev/docs/introduction/getting_started)\n-   [What's new in Riverpod 3.0](https://riverpod.dev/docs/whats_new)\n-   [FAQ](https://riverpod.dev/docs/root/FAQ)\n-   [DO/DON'T](https://riverpod.dev/docs/root/do_dont)\nCommunity\n-   [Discord](https://discord.gg/GSt793j6eT)\n-   [GitHub](https://github.com/rrousselgit/riverpod)\n-   [Stack Overflow](https://stackoverflow.com/questions/tagged/riverpod)\n-   [Twitter](https://twitter.com/remi_rousselet)\n-   [Code of conduct](https://github.com/rrousselGit/riverpod/blob/master/CODE_OF_CONDUCT.md)\n-   [Contributing guide](https://github.com/rrousselGit/riverpod/blob/master/CONTRIBUTING.md)\nSponsors\n-   [![Deploys by Netlify](https://www.netlify.com/img/global/badges/netlify-color-bg.svg)](https://www.netlify.com)\n![Riverpod](https://riverpod.dev/img/full_logo.svg)![Riverpod](https://riverpod.dev/img/full_logo.svg)\nCopyright © 2026 Remi Rousselet.\nBuilt with Docusaurus.",
  "timestamp": 1769973709556,
  "title": "What's new in Riverpod 3.0 | Riverpod"
}