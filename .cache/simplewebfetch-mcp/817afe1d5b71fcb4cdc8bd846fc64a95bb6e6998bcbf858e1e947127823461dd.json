{
  "url": "https://riverpod.dev/docs/how_to/testing",
  "markdown": "# Testing your providers | Riverpod\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n[\n![Riverpod](https://riverpod.dev/img/logo.png)![Riverpod](https://riverpod.dev/img/logo.png)\n**Riverpod**](https://riverpod.dev/)\n[Docs](https://riverpod.dev/docs/introduction/getting_started)\n[English](#)\n-   [English](https://riverpod.dev/docs/how_to/testing)\n-   [Français](https://riverpod.dev/fr/docs/how_to/testing)\n-   [한국어](https://riverpod.dev/ko/docs/how_to/testing)\n-   [日本語](https://riverpod.dev/ja/docs/how_to/testing)\n-   [Español](https://riverpod.dev/es/docs/how_to/testing)\n-   [বাংলা](https://riverpod.dev/bn/docs/how_to/testing)\n-   [Deutsch](https://riverpod.dev/de/docs/how_to/testing)\n-   [Italiano](https://riverpod.dev/it/docs/how_to/testing)\n-   [Русский](https://riverpod.dev/ru/docs/how_to/testing)\n-   [Türkçe](https://riverpod.dev/tr/docs/how_to/testing)\n-   [简体中文](https://riverpod.dev/zh-Hans/docs/how_to/testing)\n[GitHub](https://github.com/rrousselGit/riverpod)\nSearch\n-   [What's new in Riverpod 3.0](https://riverpod.dev/docs/whats_new)\n-   [Migrating from 2.0 to 3.0](https://riverpod.dev/docs/3.0_migration)\n-   [FAQ](https://riverpod.dev/docs/root/faq)\n-   [DO/DON'T](https://riverpod.dev/docs/root/do_dont)\n-   [Getting started](https://riverpod.dev/docs/introduction/getting_started)\n-   Tutorials\n    -   [Your first Riverpod app](https://riverpod.dev/docs/tutorials/first_app)\n-   Concepts\n    -   [Providers](https://riverpod.dev/docs/concepts2/providers)\n    -   [Consumers](https://riverpod.dev/docs/concepts2/consumers)\n    -   [ProviderContainers/ProviderScopes](https://riverpod.dev/docs/concepts2/containers)\n    -   [Refs](https://riverpod.dev/docs/concepts2/refs)\n    -   [Automatic disposal](https://riverpod.dev/docs/concepts2/auto_dispose)\n    -   [Family](https://riverpod.dev/docs/concepts2/family)\n    -   [Mutations (experimental)](https://riverpod.dev/docs/concepts2/mutations)\n    -   [Offline persistence (experimental)](https://riverpod.dev/docs/concepts2/offline)\n    -   [Automatic retry](https://riverpod.dev/docs/concepts2/retry)\n    -   [ProviderObservers](https://riverpod.dev/docs/concepts2/observers)\n    -   [Provider overrides](https://riverpod.dev/docs/concepts2/overrides)\n    -   [Scoping providers](https://riverpod.dev/docs/concepts2/scoping)\n    -   [About code generation](https://riverpod.dev/docs/concepts/about_code_generation)\n    -   [About hooks](https://riverpod.dev/docs/concepts/about_hooks)\n-   Guides\n    -   [Testing your providers](https://riverpod.dev/docs/how_to/testing)\n    -   [How to reduce provider/widget rebuilds](https://riverpod.dev/docs/how_to/select)\n    -   [How to eagerly initialize providers](https://riverpod.dev/docs/how_to/eager_initialization)\n    -   [Implementing pull-to-refresh](https://riverpod.dev/docs/how_to/pull_to_refresh)\n    -   [How to debounce/cancel network requests](https://riverpod.dev/docs/how_to/cancel)\n-   References\n    -   [All Providers](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/Provider-class.html)\n    -   [Containers/Scopes](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/ProviderContainer-class.html)\n    -   [Refs](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/Ref-class.html)\n    -   [Consumers](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/ConsumerWidget-class.html)\n    -   [Offline persistence (experimental)](https://pub.dev/documentation/hooks_riverpod/latest/experimental_persist/Storage-class.html)\n    -   [Mutations (experimental)](https://pub.dev/documentation/hooks_riverpod/latest/experimental_mutation/Mutation-class.html)\n    -   [core](https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/AsyncValue-class.html)\n    -   [misc](https://pub.dev/documentation/hooks_riverpod/latest/misc/)\n-   Migration guides\n    -   [Riverpod for Provider Users](https://riverpod.dev/docs/from_provider/quickstart)\n    -   [From \\`StateNotifier\\`](https://riverpod.dev/docs/migration/from_state_notifier)\n    -   [From \\`ChangeNotifier\\`](https://riverpod.dev/docs/migration/from_change_notifier)\n    -   [^0.14.0 to ^1.0.0](https://riverpod.dev/docs/migration/0.14.0_to_1.0.0)\n    -   [^0.13.0 to ^0.14.0](https://riverpod.dev/docs/migration/0.13.0_to_0.14.0)\n-   [Official examples](https://github.com/rrousselGit/riverpod/tree/master/examples/counter)\n-   [Third party examples](https://github.com/dhafinrayhan/dummymart)\n-   [](https://riverpod.dev/)\n-   Guides\n-   Testing your providers\nOn this page\n# Testing your providers\nA core part of the Riverpod API is the ability to test your providers in isolation.\nFor a proper test suite, there are a few challenges to overcome:\n-   Tests should not share state. This means that new tests should not be affected by the previous tests.\n-   Tests should give us the ability to mock certain functionalities to achieve the desired state.\n-   The test environment should be as close as possible to the real environment.\nFortunately, Riverpod makes it easy to achieve all of these goals.\n## Setting up a test[​](#setting-up-a-test \"Direct link to Setting up a test\")\nWhen defining a test with Riverpod, there are two main scenarios:\n-   Unit tests, usually with no Flutter dependency. This can be useful for testing the behavior of a provider in isolation.\n-   Widget tests, usually with a Flutter dependency. This can be useful for testing the behavior of a widget that uses a provider.\n### Unit tests[​](#unit-tests \"Direct link to Unit tests\")\nUnit tests are defined using the `test` function from [package:test](https://pub.dev/packages/test).\nThe main difference with any other test is that we will want to create a `ProviderContainer` object. This object will enable our test to interact with providers.\nA typical test using `ProviderContainer` will look like:\n```\nvoid main() {  test('Some description', () {    // Create a ProviderContainer for this test.    // DO NOT share ProviderContainers between tests.    final container = ProviderContainer.test();    // TODO: use the container to test your application.    expect(      container.read(provider),      equals('some value'),    );  });}\n```\nNow that we have a ProviderContainer, we can use it to read providers using:\n-   `container.read`, to read the current value of a provider.\n-   `container.listen`, to listen to a provider and be notified of changes.\ncaution\nBe careful when using `container.read` when providers are automatically disposed.\nIf your provider is not listened to, chances are that its state will get destroyed in the middle of your test.\nIn that case, consider using `container.listen`.\nIts return value enables reading the current value of provider anyway, but will also ensure that the provider is not disposed in the middle of your test:\n```\nfinal subscription = container.listen<String>(provider, (_, _) {});expect(  // Equivalent to `container.read(provider)`  // But the provider will not be disposed unless \"subscription\" is disposed.  subscription.read(),  'Some value',);\n```\n### Widget tests[​](#widget-tests \"Direct link to Widget tests\")\nWidget tests are defined using the `testWidgets` function from [package:flutter\\_test](https://pub.dev/packages/flutter_test).\nIn this case, the main difference with usual Widget tests is that we must add a `ProviderScope` widget at the root of `tester.pumpWidget`:\n```\nvoid main() {  testWidgets('Some description', (tester) async {    await tester.pumpWidget(      const ProviderScope(child: YourWidgetYouWantToTest()),    );  });}\n```\nThis is similar to what we do when we enable Riverpod in our Flutter app.\nThen, we can use `tester` to interact with our widget. Alternatively if you want to interact with providers, you can obtain a `ProviderContainer`. One can be obtained using `tester.container()`.\nBy using `tester`, we can therefore write the following:\n```\nfinal container = tester.container();\n```\nWe can then use it to read providers. Here's a full example:\n```\nvoid main() {  testWidgets('Some description', (tester) async {    await tester.pumpWidget(      const ProviderScope(child: YourWidgetYouWantToTest()),    );    final container = tester.container();    // TODO interact with your providers    expect(      container.read(provider),      'some value',    );  });}\n```\n## Mocking providers[​](#mocking-providers \"Direct link to Mocking providers\")\nSo far, we've seen how to set up a test and basic interactions with providers. However, in some cases, we may want to mock a provider.\nThe cool part: All providers can be mocked by default, without any additional setup.\nThis is possible by specifying the `overrides` parameter on either `ProviderScope` or `ProviderContainer`.\nConsider the following provider:\n-   riverpod\n-   riverpod\\_generator\n```\n// An eagerly initialized provider.final exampleProvider = FutureProvider<String>((ref) async => 'Hello world');\n```\n```\n// An eagerly initialized provider.@riverpodFuture<String> example(Ref ref) async => 'Hello world';\n```\nWe can mock it using:\n```\n// In unit tests, by reusing our previous \"createContainer\" utility.final container = ProviderContainer.test(  // We can specify a list of providers to mock:  overrides: [    // In this case, we are mocking \"exampleProvider\".    exampleProvider.overrideWith((ref) {      // This function is the typical initialization function of a provider.      // This is where you normally call \"ref.watch\" and return the initial state.      // Let's replace the default \"Hello world\" with a custom value.      // Then, interacting with `exampleProvider` will return this value.      return 'Hello from tests';    }),  ],);// We can also do the same thing in widget tests using ProviderScope:await tester.pumpWidget(  ProviderScope(    // ProviderScopes have the exact same \"overrides\" parameter    overrides: [      // Same as before      exampleProvider.overrideWith((ref) => 'Hello from tests'),    ],    child: const YourWidgetYouWantToTest(),  ),);\n```\n## Spying on changes in a provider[​](#spying-on-changes-in-a-provider \"Direct link to Spying on changes in a provider\")\nSince we obtained a `ProviderContainer` in our tests, it is possible to use it to \"listen\" to a provider:\n```\ncontainer.listen<String>(  provider,  (previous, next) {    print('The provider changed from $previous to $next');  },);\n```\nYou can then combine this with packages such as [mockito](https://pub.dev/packages/mockito) or [mocktail](https://pub.dev/packages/mocktail) to use their `verify` API.\nOr more simply, you can add all changes in a list and assert on it.\n## Awaiting asynchronous providers[​](#awaiting-asynchronous-providers \"Direct link to Awaiting asynchronous providers\")\nIn Riverpod, it is very common for providers to return a Future/Stream.\nIn that case, chances are that our tests need to await for that asynchronous operation to be completed.\nOne way to do so is to read the `.future` of a provider:\n```\n// TODO: use the container to test your application.// Our expectation is asynchronous, so we should use \"expectLater\"await expectLater(  // We read \"provider.future\" instead of \"provider\".  // This is possible on asynchronous providers, and returns a future  // which will resolve with the value of the provider.  container.read(provider.future),  // We can verify that the future resolves with the expected value.  // Alternatively we can use \"throwsA\" for errors.  completion('some value'),);\n```\n## Mocking Notifiers[​](#mocking-notifiers \"Direct link to Mocking Notifiers\")\nIt is generally discouraged to mock Notifiers. This is because Notifiers cannot be instantiated on their own, and only work when used as part of a Provider.\nInstead, you should likely introduce a level of abstraction in the logic of your Notifier, such that you can mock that abstraction. For instance, rather than mocking a Notifier, you could mock a \"repository\" that the Notifier uses to fetch data from.\nIf you insist on mocking a Notifier, there is a special consideration to create such a mock: Your mock must subclass the original Notifier base class: You cannot \"implement\" Notifier, as this would break the interface.\nAs such, when mocking a Notifier, instead of writing the following mockito code:\n```\nclass MyNotifierMock with Mock implements MyNotifier {}\n```\nYou should instead write:\n-   riverpod\n-   riverpod\\_generator\n```\nclass MyNotifier extends Notifier<int> {  @override  int build() => throw UnimplementedError();}// Your mock needs to subclass the Notifier base-class corresponding// to whatever your notifier usesclass MyNotifierMock extends Notifier<int> with Mock implements MyNotifier {}\n```\n```\n@riverpodclass MyNotifier extends _$MyNotifier {  @override  int build() => throw UnimplementedError();}// Your mock needs to subclass the Notifier base-class corresponding// to whatever your notifier usesclass MyNotifierMock extends _$MyNotifier with Mock implements MyNotifier {}\n```\ninfo\nIf using code-generation, for the above to work, your mock will have to be placed in the same file as the Notifier you are mocking. Otherwise you would not have access to the `_$MyNotifier` class.\nThen, to use your notifier you could do:\n```\nvoid main() {  test('Some description', () {    final container = ProviderContainer.test(      // Override the provider to have it create our mock Notifier.      overrides: [myProvider.overrideWith(MyNotifierMock.new)],    );    // Then obtain the mocked notifier through the container:    final notifier = container.read(myProvider.notifier);    // You can then interact with the notifier as you would with the real one:    notifier.state = 42;  });}\n```\n[Edit this page](https://github.com/rrousselGit/riverpod/edit/master/website/docs/how_to/testing.mdx)\n[\nPrevious\nAbout hooks\n](https://riverpod.dev/docs/concepts/about_hooks)[\nNext\nHow to reduce provider/widget rebuilds\n](https://riverpod.dev/docs/how_to/select)\n-   [Setting up a test](#setting-up-a-test)\n    -   [Unit tests](#unit-tests)\n    -   [Widget tests](#widget-tests)\n-   [Mocking providers](#mocking-providers)\n-   [Spying on changes in a provider](#spying-on-changes-in-a-provider)\n-   [Awaiting asynchronous providers](#awaiting-asynchronous-providers)\n-   [Mocking Notifiers](#mocking-notifiers)\nDocs\n-   [Getting started](https://riverpod.dev/docs/introduction/getting_started)\n-   [What's new in Riverpod 3.0](https://riverpod.dev/docs/whats_new)\n-   [FAQ](https://riverpod.dev/docs/root/FAQ)\n-   [DO/DON'T](https://riverpod.dev/docs/root/do_dont)\nCommunity\n-   [Discord](https://discord.gg/GSt793j6eT)\n-   [GitHub](https://github.com/rrousselgit/riverpod)\n-   [Stack Overflow](https://stackoverflow.com/questions/tagged/riverpod)\n-   [Twitter](https://twitter.com/remi_rousselet)\n-   [Code of conduct](https://github.com/rrousselGit/riverpod/blob/master/CODE_OF_CONDUCT.md)\n-   [Contributing guide](https://github.com/rrousselGit/riverpod/blob/master/CONTRIBUTING.md)\nSponsors\n-   [![Deploys by Netlify](https://www.netlify.com/img/global/badges/netlify-color-bg.svg)](https://www.netlify.com)\n![Riverpod](https://riverpod.dev/img/full_logo.svg)![Riverpod](https://riverpod.dev/img/full_logo.svg)\nCopyright © 2026 Remi Rousselet.\nBuilt with Docusaurus.",
  "timestamp": 1769987713763,
  "title": "Testing your providers | Riverpod"
}