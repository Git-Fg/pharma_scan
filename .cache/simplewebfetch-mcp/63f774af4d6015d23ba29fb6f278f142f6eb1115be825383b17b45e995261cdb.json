{
  "url": "https://drift.simonbinder.eu/docs/dart-api/writes",
  "markdown": "# Writes (update, insert, delete)\n[Drift](https://drift.simonbinder.eu/)\n-   [Docs](https://drift.simonbinder.eu/)\n-   [Guides](https://drift.simonbinder.eu/guides/datetime-migrations)\n-   [Examples](https://drift.simonbinder.eu/examples/)\n-   [pub.dev](https://pub.dev/packages/drift)\n-   [Docs](https://drift.simonbinder.eu/)\n    -   -   [Home](https://drift.simonbinder.eu/)\n        -   [Setup guide](https://drift.simonbinder.eu/setup)\n        -   [FAQ](https://drift.simonbinder.eu/faq)\n    -   Dart reference\n        -   [Defining tables](https://drift.simonbinder.eu/dart_api/tables)\n        -   [Selects](https://drift.simonbinder.eu/dart_api/select)\n        -   [Writes (update, insert, delete)](https://drift.simonbinder.eu/dart_api/writes)\n        -   [Expressions](https://drift.simonbinder.eu/dart_api/expressions)\n        -   [Stream queries](https://drift.simonbinder.eu/dart_api/streams)\n        -   [Schema introspection](https://drift.simonbinder.eu/dart_api/schema_inspection)\n        -   [Views](https://drift.simonbinder.eu/dart_api/views)\n        -   [DAOs](https://drift.simonbinder.eu/dart_api/daos)\n        -   [Manager API](https://drift.simonbinder.eu/dart_api/manager)\n        -   [Transactions](https://drift.simonbinder.eu/dart_api/transactions)\n    -   SQL API reference\n        -   [Overview](https://drift.simonbinder.eu/sql_api)\n        -   [Drift files](https://drift.simonbinder.eu/sql_api/drift_files)\n        -   [SQLite extensions](https://drift.simonbinder.eu/sql_api/extensions)\n        -   [Custom queries](https://drift.simonbinder.eu/sql_api/custom_queries)\n    -   Migrations\n        -   [Overview](https://drift.simonbinder.eu/migrations)\n        -   [Migrator APIs](https://drift.simonbinder.eu/migrations/api)\n        -   [Testing](https://drift.simonbinder.eu/migrations/tests)\n        -   [Helpers](https://drift.simonbinder.eu/migrations/step_by_step)\n        -   [Schema exports](https://drift.simonbinder.eu/migrations/exports)\n    -   Platforms\n        -   [Overview](https://drift.simonbinder.eu/platforms)\n        -   [Native](https://drift.simonbinder.eu/platforms/vm)\n        -   [Web](https://drift.simonbinder.eu/platforms/web)\n        -   [Encryption](https://drift.simonbinder.eu/platforms/encryption)\n        -   [libsql](https://drift.simonbinder.eu/platforms/libsql)\n        -   [PostgreSQL](https://drift.simonbinder.eu/platforms/postgres)\n    -   Generation options\n        -   [Overview](https://drift.simonbinder.eu/generation_options)\n        -   [Modular code generation](https://drift.simonbinder.eu/generation_options/modular)\n        -   [Drift and other builders](https://drift.simonbinder.eu/generation_options/in_other_builders)\n    -   Tools\n        -   [Overview](https://drift.simonbinder.eu/tools)\n        -   [Devtools extension](https://drift.simonbinder.eu/tools/devtools)\n        -   [Community tools](https://drift.simonbinder.eu/community_tools)\n    -   Advanced topics\n        -   [Isolates](https://drift.simonbinder.eu/isolates)\n        -   [Testing](https://drift.simonbinder.eu/testing)\n        -   [Generated table rows](https://drift.simonbinder.eu/dart_api/rows)\n        -   [Type converters](https://drift.simonbinder.eu/type_converters)\n        -   [Custom SQL types](https://drift.simonbinder.eu/sql_api/types)\n[Edit this page](https://github.com/simolus3/drift/edit/develop/docs/content/dart_api/writes.md) [Create documentation issue](https://github.com/simolus3/drift/issues/new?template=docs.md&title=Documentation+issue%3A+Writes+%28update%2C+insert%2C+delete%29)\nOn this page[](# \"Top of the page\")\n-   [Updates and deletes](#updates-and-deletes)\n    -   [Updating with SQL expressions](#updating-with-sql-expressions)\n-   [Inserts](#inserts)\n    -   [Upserts](#upserts)\n    -   [Returning](#returning)\n# Writes (update, insert, delete)\nSelect rows or invidiual columns from tables in Dart\n## Updates and deletes[#](https://drift.simonbinder.eu/dart_api/writes#updates-and-deletes)\nYou can use the generated classes to update individual fields of any row:\n```\nFuture moveImportantTasksIntoCategory(Category target) {\n  // for updates, we use the \"companion\" version of a generated class. This wraps the\n  // fields in a \"Value\" type which can be set to be absent using \"Value.absent()\". This\n  // allows us to separate between \"SET category = NULL\" (`category: Value(null)`) and not\n  // updating the category at all: `category: Value.absent()`.\n  return (update(todos)\n      ..where((t) => t.title.like('%Important%'))\n    ).write(TodosCompanion(\n      category: Value(target.id),\n    ),\n  );\n}\nFuture updateTodo(Todo entry) {\n  // using replace will update all fields from the entry that are not marked as a primary key.\n  // it will also make sure that only the entry with the same primary key will be updated.\n  // Here, this means that the row that has the same id as entry will be updated to reflect\n  // the entry's title, content and category. As its where clause is set automatically, it\n  // cannot be used together with where.\n  return update(todos).replace(entry);\n}\nFuture feelingLazy() {\n  // delete the oldest nine tasks\n  return (delete(todos)..where((t) => t.id.isSmallerThanValue(10))).go();\n}\n```\n**⚠️ Caution:** If you don't explicitly add a `where` clause on updates or deletes, the statement will affect all rows in the table!\nEntries, companions - why do we need all of this?\nYou might have noticed that we used a `TodosCompanion` for the first update instead of just passing a `Todo`. Drift generates the `Todo` class (also called _data class_ for the table) to hold a **full** row with all its data. For _partial_ data, prefer to use companions. In the example above, we only set the the `category` column, so we used a companion. Why is that necessary? If a field was set to `null`, we wouldn't know whether we need to set that column back to null in the database or if we should just leave it unchanged. Fields in the companions have a special `Value.absent()` state which makes this explicit.\nCompanions also have a special constructor for inserts - all columns which don't have a default value and aren't nullable are marked `@required` on that constructor. This makes companions easier to use for inserts because you know which fields to set.\n### Updating with SQL expressions[#](https://drift.simonbinder.eu/dart_api/writes#updating-with-sql-expressions)\nIn some cases, you might want to update many rows based on their current value. One option would be to first select the affected rows into Dart objects, create companions based on those results and use them for updates. If the update can be described in SQL, a more efficient way is available with `Companion.custom`:\n```\nawait db\n    .update(db.users)\n    .write(UsersCompanion.custom(username: db.users.username.lower()));\n```\nHere, the `name` column in the `users` table is changed to lowercase for all existing rows. Since `.lower()` on columns is implemented in the database, the rows don't have to be loaded into Dart during the statement.\n## Inserts[#](https://drift.simonbinder.eu/dart_api/writes#inserts)\nYou can very easily insert any valid object into tables. As some values can be absent (like default values that we don't have to set explicitly), we again use the companion version.\n```\n// returns the generated id\nFuture<int> addTodo(TodosCompanion entry) {\n  return into(todos).insert(entry);\n}\n```\nAll row classes generated will have a constructor that can be used to create objects:\n```\naddTodo(\n  TodosCompanion(\n    title: Value('Important task'),\n    content: Value('Refactor persistence code'),\n  ),\n);\n```\nIf a column is nullable or has a default value (this includes auto-increments), the field can be omitted. All other fields must be set and non-null. The `insert` method will throw otherwise.\nMultiple insert statements can be run efficiently by using a batch. To do that, you can use the `insertAll` method inside a `batch`:\n```\nFuture<void> insertMultipleEntries() async{\n  await batch((batch) {\n    // functions in a batch don't have to be awaited - just\n    // await the whole batch afterwards.\n    batch.insertAll(todos, [\n      TodosCompanion.insert(\n        title: 'First entry',\n        content: 'My content',\n      ),\n      TodosCompanion.insert(\n        title: 'Another entry',\n        content: 'More content',\n        // columns that aren't required for inserts are still wrapped in a Value:\n        category: Value(3),\n      ),\n      // ...\n    ]);\n  });\n}\n```\nBatches are similar to transactions in the sense that all updates are happening atomically, but they enable further optimizations to avoid preparing the same SQL statement twice. This makes them suitable for bulk insert or update operations.\n### Upserts[#](https://drift.simonbinder.eu/dart_api/writes#upserts)\nUpserts are a feature from newer sqlite3 versions that allows an insert to behave like an update if a conflicting row already exists.\nThis allows us to create or override an existing row when its primary key is part of its data:\n```\nclass Users extends Table {\n  TextColumn get email => text()();\n  TextColumn get name => text()();\n  @override\n  Set<Column> get primaryKey => {email};\n}\nFuture<int> createOrUpdateUser(User user) {\n  return into(users).insertOnConflictUpdate(user);\n}\n```\nWhen calling `createOrUpdateUser()` with an email address that already exists, that user's name will be updated. Otherwise, a new user will be inserted into the database.\nInserts can also be used with more advanced queries. For instance, let's say we're building a dictionary and want to keep track of how many times we encountered a word. A table for that might look like\n```\nclass Words extends Table {\n  TextColumn get word => text()();\n  IntColumn get usages => integer().withDefault(const Constant(1))();\n  @override\n  Set<Column> get primaryKey => {word};\n}\n```\nBy using a custom upserts, we can insert a new word or increment its `usages` counter if it already exists:\n```\nFuture<void> trackWord(String word) {\n  return into(words).insert(\n    WordsCompanion.insert(word: word),\n    onConflict: DoUpdate(\n      (old) => WordsCompanion.custom(usages: old.usages + Constant(1)),\n    ),\n  );\n}\n```\nUnique constraints and conflict targets\nBoth `insertOnConflictUpdate` and `onConflict: DoUpdate` use an `DO UPDATE` upsert in sql. This requires us to provide a so-called \"conflict target\", a set of columns to check for uniqueness violations. By default, drift will use the table's primary key as conflict target. That works in most cases, but if you have custom `UNIQUE` constraints on some columns, you'll need to use the `target` parameter on `DoUpdate` in Dart to include those columns:\n```\nclass MatchResults extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get teamA => text()();\n  TextColumn get teamB => text()();\n  BoolColumn get teamAWon => boolean()();\n  @override\n  List<Set<Column<Object>>>? get uniqueKeys => [\n    {teamA, teamB},\n  ];\n}\nFuture<void> insertMatch(String teamA, String teamB, bool teamAWon) {\n  final data = MatchResultsCompanion.insert(\n    teamA: teamA,\n    teamB: teamB,\n    teamAWon: teamAWon,\n  );\n  return into(matches).insert(\n    data,\n    onConflict: DoUpdate(\n      (old) => data,\n      target: [matches.teamA, matches.teamB],\n    ),\n  );\n}\n```\nNote that this requires a fairly recent sqlite3 version (3.24.0) that might not be available on older Android devices when using `drift_sqflite`. `NativeDatabases` and `sqlite3_flutter_libs` includes the latest sqlite on Android, so consider using it if you want to support upserts.\nAlso note that the returned rowid may not be accurate when an upsert took place.\n### Returning[#](https://drift.simonbinder.eu/dart_api/writes#returning)\nYou can use `insertReturning` to insert a row or companion and immediately get the row it inserts. The returned row contains all the default values and incrementing ids that were generated.\n**Note:** This uses the `RETURNING` syntax added in sqlite3 version 3.35, which is not available on most operating systems by default. When using this method, make sure that you have a recent sqlite3 version available. This is the case with `sqlite3_flutter_libs`.\nFor instance, consider this snippet using the tables from the [getting started guide](https://drift.simonbinder.eu/setup):\n```\nfinal row = await into(todos).insertReturning(TodosCompanion.insert(\n  title: 'A todo entry',\n  content: 'A description',\n));\n```\nThe `row` returned has the proper `id` set. If a table has further default values, including dynamic values like `CURRENT_TIME`, then those would also be set in a row returned by `insertReturning`.\n-   [](https://github.com/simolus3/drift)\n[](https://jaspr.site \"Built with the Jaspr web framework for Dart.\")\n©2019–2025Simon Binder, Drift authors. Documentation licensed under [CC0 1.0](https://creativecommons.org/publicdomain/zero/1.0/), Drift itself is [MIT-licensed](https://github.com/simolus3/drift/blob/develop/LICENSE)",
  "timestamp": 1769963231227,
  "title": "Writes (update, insert, delete)"
}