{
  "url": "https://drift.simonbinder.eu/dart_api/manager",
  "markdown": "# Manager\n[Drift](https://drift.simonbinder.eu/)\n-   [Docs](https://drift.simonbinder.eu/)\n-   [Guides](https://drift.simonbinder.eu/guides/datetime-migrations)\n-   [Examples](https://drift.simonbinder.eu/examples/)\n-   [pub.dev](https://pub.dev/packages/drift)\n-   [Docs](https://drift.simonbinder.eu/)\n    -   -   [Home](https://drift.simonbinder.eu/)\n        -   [Setup guide](https://drift.simonbinder.eu/setup)\n        -   [FAQ](https://drift.simonbinder.eu/faq)\n    -   Dart reference\n        -   [Defining tables](https://drift.simonbinder.eu/dart_api/tables)\n        -   [Selects](https://drift.simonbinder.eu/dart_api/select)\n        -   [Writes (update, insert, delete)](https://drift.simonbinder.eu/dart_api/writes)\n        -   [Expressions](https://drift.simonbinder.eu/dart_api/expressions)\n        -   [Stream queries](https://drift.simonbinder.eu/dart_api/streams)\n        -   [Schema introspection](https://drift.simonbinder.eu/dart_api/schema_inspection)\n        -   [Views](https://drift.simonbinder.eu/dart_api/views)\n        -   [DAOs](https://drift.simonbinder.eu/dart_api/daos)\n        -   [Manager API](https://drift.simonbinder.eu/dart_api/manager)\n        -   [Transactions](https://drift.simonbinder.eu/dart_api/transactions)\n    -   SQL API reference\n        -   [Overview](https://drift.simonbinder.eu/sql_api)\n        -   [Drift files](https://drift.simonbinder.eu/sql_api/drift_files)\n        -   [SQLite extensions](https://drift.simonbinder.eu/sql_api/extensions)\n        -   [Custom queries](https://drift.simonbinder.eu/sql_api/custom_queries)\n    -   Migrations\n        -   [Overview](https://drift.simonbinder.eu/migrations)\n        -   [Migrator APIs](https://drift.simonbinder.eu/migrations/api)\n        -   [Testing](https://drift.simonbinder.eu/migrations/tests)\n        -   [Helpers](https://drift.simonbinder.eu/migrations/step_by_step)\n        -   [Schema exports](https://drift.simonbinder.eu/migrations/exports)\n    -   Platforms\n        -   [Overview](https://drift.simonbinder.eu/platforms)\n        -   [Native](https://drift.simonbinder.eu/platforms/vm)\n        -   [Web](https://drift.simonbinder.eu/platforms/web)\n        -   [Encryption](https://drift.simonbinder.eu/platforms/encryption)\n        -   [libsql](https://drift.simonbinder.eu/platforms/libsql)\n        -   [PostgreSQL](https://drift.simonbinder.eu/platforms/postgres)\n    -   Generation options\n        -   [Overview](https://drift.simonbinder.eu/generation_options)\n        -   [Modular code generation](https://drift.simonbinder.eu/generation_options/modular)\n        -   [Drift and other builders](https://drift.simonbinder.eu/generation_options/in_other_builders)\n    -   Tools\n        -   [Overview](https://drift.simonbinder.eu/tools)\n        -   [Devtools extension](https://drift.simonbinder.eu/tools/devtools)\n        -   [Community tools](https://drift.simonbinder.eu/community_tools)\n    -   Advanced topics\n        -   [Isolates](https://drift.simonbinder.eu/isolates)\n        -   [Testing](https://drift.simonbinder.eu/testing)\n        -   [Generated table rows](https://drift.simonbinder.eu/dart_api/rows)\n        -   [Type converters](https://drift.simonbinder.eu/type_converters)\n        -   [Custom SQL types](https://drift.simonbinder.eu/sql_api/types)\n[Edit this page](https://github.com/simolus3/drift/edit/develop/docs/content/dart_api/manager.md) [Create documentation issue](https://github.com/simolus3/drift/issues/new?template=docs.md&title=Documentation+issue%3A+Manager)\nOn this page[](# \"Top of the page\")\n-   [Select](#select)\n    -   [Referencing other tables](#referencing-other-tables)\n    -   [Filtering across tables](#filtering-across-tables)\n    -   [Ordering](#ordering)\n    -   [Count and exists](#count-and-exists)\n-   [Updates](#updates)\n-   [Creating rows](#creating-rows)\n-   [Deleting rows](#deleting-rows)\n-   [Computed Fields](#computed-fields)\n# Manager\nUse easier bindings for common queries.\nDrift provides two ways to write queries in Dart: A [query builder](https://drift.simonbinder.eu/dart_api/select) that closely mirrors SQL in Dart, and a new generated manager interface, described on this page. The manager interfaces are designed to make the most common queries much easier to write. In particular, they should be helpful if you're coming from another persistence library to drift or don't have much SQL experience.\nThe examples on this page use a database schema similar to the one from the [setup](https://drift.simonbinder.eu/setup) instructions:\n```\nclass TodoItems extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get title => text().withLength(min: 6, max: 32)();\n  TextColumn get content => text().named('body')();\n  IntColumn get category =>\n      integer().nullable().references(TodoCategory, #id)();\n  DateTimeColumn get createdAt => dateTime().nullable()();\n}\nclass TodoCategory extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get description => text()();\n  IntColumn get user => integer().nullable().references(Users, #id)();\n}\n```\n## Select[#](https://drift.simonbinder.eu/dart_api/manager#select)\nWhen manager generation is enabled (which it is by default), drift will generate a manager for each table in the database. A collection of these managers are accessed by a getter `managers` on the database class. Each table will have a manager generated for it unless it uses a custom row class.\nThe manager simplifies the process of retrieving rows from a table. Use it to read rows from the table or watch for changes.\n```\nFuture<void> selectTodoItems() async {\n  // Get all items\n  managers.todoItems.get();\n  // A stream of all the todo items, updated in real-time\n  managers.todoItems.watch();\n  // To get a single item, apply a filter and call `getSingle`\n  await managers.todoItems.filter((f) => f.id(1)).getSingle();\n}\n```\nThe manager provides a really easy to use API for selecting rows from a table. These can be combined with `|` and `&` and parenthesis to construct more complex queries. Use `.not` to negate a condition.\n```\nFuture<void> filterTodoItems() async {\n  // All items with a title of \"Title\"\n  managers.todoItems.filter((f) => f.title(\"Title\"));\n  // All items with a title of \"Title\" and content of \"Content\"\n  managers.todoItems.filter((f) => f.title(\"Title\") & f.content(\"Content\"));\n  // All items with a title of \"Title\" or content that is not null\n  managers.todoItems.filter((f) => f.title(\"Title\") | f.content.not.isNull());\n}\n```\nEvery column has filters for equality, inequality and nullability. Type specific filters for `int`, `double`, `Int64`, `DateTime` and `String` are included out of the box.\n```\nFuture<void> filterWithType() async {\n  // Filter all items created since 7 days ago\n  managers.todoItems.filter(\n    (f) => f.createdAt.isAfter(DateTime.now().subtract(Duration(days: 7))),\n  );\n  // Filter all items with a title that starts with \"Title\"\n  managers.todoItems.filter((f) => f.title.startsWith('Title'));\n}\n```\n### Referencing other tables[#](https://drift.simonbinder.eu/dart_api/manager#referencing-other-tables)\nThe manager also makes it easy to query an entity's referenced fields by using the `withReferences` method. This will return a record with the entity and a `refs` object which contains the referenced fields.\n```\nFuture<void> references() async {\n  /// Get each todo, along with a its categories\n  final todosWithRefs = await managers.todoItems.withReferences().get();\n  for (final (todo, refs) in todosWithRefs) {\n    final category = await refs.category?.getSingle();\n  }\n  /// This also works in the reverse\n  final categoriesWithRefs = await managers.todoCategory\n      .withReferences()\n      .get();\n  for (final (category, refs) in categoriesWithRefs) {\n    final todos = await refs.todoItemsRefs.get();\n  }\n}\n```\nThe problem with the above approach is that it will issue a separate query for each row in the result set. This can be very inefficient if you have a large number of rows. If there were 1000 todos, this would issue 1000 queries to fetch the category for each todo.\nFilter on foreign keys\nWhen filtering on a reference column, drift will apply the filter to the column itself instead of joining the referenced table. For example, `todos.filter((f) => f.category.id(1))` will filter on the `category` column on the `todos` table, instead of joining the two tables and filtering on the `id` column of the `categories` table.\n#### How does this affect me?\nIf you have foreign keys contraints enabled (`PRAGMA foreign_keys = ON`) this won't affect you. The database will enfore that the `id` column on the `categories` table is the same as the `category` column on the `todos` table.\nIf you don't have foreign key constraints enabled, you should be aware that the above query will not check that the category with `id` 1 exists. It will only check that the `category` column on the `todos` table is 1.\n#### Prefetching references\nDrift provides a way to prefetch references in a single query to avoid inefficient queries. This is done by using the callback in the `withReferences` method. The referenced item will then be available in the referenced managers `prefetchedData` field.\n```\nFuture<void> referencesPrefetch() async {\n  /// Get each todo, along with a its categories\n  final todosWithRefs = await managers.todoItems\n      .withReferences((prefetch) => prefetch(category: true))\n      .get();\n  for (final (todo, refs) in todosWithRefs) {\n    final category = refs.category?.prefetchedData?.firstOrNull;\n    // No longer needed\n    // final category = await refs.category?.getSingle();\n  }\n  /// This also works in the reverse\n  final categoriesWithRefs = await managers.todoCategory\n      .withReferences((prefetch) => prefetch(todoItemsRefs: true))\n      .get();\n  for (final (category, refs) in categoriesWithRefs) {\n    final todos = refs.todoItemsRefs.prefetchedData;\n    // No longer needed\n    //final todos = await refs.todoItemsRefs.get();\n  }\n}\n```\n### Filtering across tables[#](https://drift.simonbinder.eu/dart_api/manager#filtering-across-tables)\nYou can filter across references to other tables by using the generated reference filters. You can nest these as deep as you'd like and the manager will take care of adding the aliased joins behind the scenes.\n```\nFuture<void> relationalFilter() async {\n  // Get all items with a category description of \"School\"\n  managers.todoItems.filter((f) => f.category.description(\"School\"));\n  // These can be combined with other filters\n  // For example, get all items with a title of \"Title\" or a category description of \"School\"\n  await managers.todoItems\n      .filter((f) => f.title(\"Title\") | f.category.description(\"School\"))\n      .exists();\n}\n```\nYou can also filter across back references. This is useful when you have a one-to-many relationship and want to filter the parent table based on the child table.\n```\nFuture<void> reverseRelationalFilter() async {\n  // Get the category that has a todo item with an id of 1\n  managers.todoCategory.filter((f) => f.todoItemsRefs((f) => f.id(1)));\n  // These can be combined with other filters\n  // For example, get all categories with a description of \"School\" or a todo item with an id of 1\n  managers.todoCategory.filter(\n    (f) => f.description(\"School\") | f.todoItemsRefs((f) => f.id(1)),\n  );\n}\n```\nThe code generator will name this filterset using the name of the table that is being referenced. In the above example, the filterset is named `todoItemsRefs`, because the `TodoItems` table is being referenced. However, you can also specify a custom name for the filterset using the `@ReferenceName(...)` annotation on the foreign key. This may be necessary if you have multiple references to the same table, take the following example:\n```\nclass Users extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get name => text()();\n}\nclass Groups extends Table {\n  IntColumn get id => integer().autoIncrement()();\n  TextColumn get name => text()();\n  @ReferenceName(\"administeredGroups\")\n  IntColumn get admin => integer().nullable().references(Users, #id)();\n  @ReferenceName(\"ownedGroups\")\n  IntColumn get owner => integer().references(Users, #id)();\n}\n```\nWe can now use them in a query like this:\n```\nFuture<void> reverseNamedRelationalFilter() async {\n  // Get all users who are administrators of a group with a name containing \"Business\"\n  // or who own a group with an id of 1, 2, 4, or 5\n  managers.users.filter(\n    (f) =>\n        f.administeredGroups((f) => f.name.contains(\"Business\")) |\n        f.ownedGroups((f) => f.id.isIn([1, 2, 4, 5])),\n  );\n}\n```\nIn this example, had we not specified a custom name for the reference, the code generator would have named both filtersets `userRefs` for both references to the `User` table. This would have caused a conflict. By specifying a custom name, we can avoid this issue.\n#### Name Clashes\nDrift auto-generates filters and orderings based on the names of your tables and fields. However, many times, there will be duplicates. When this happens, you will see a warning message from the generator. To fix this issue, use the `@ReferenceName()` annotation to specify what we should name the filter/orderings.\n### Ordering[#](https://drift.simonbinder.eu/dart_api/manager#ordering)\nYou can also order the results of a query using the `orderBy` method. The syntax is similar to the `filter` method. Use the `&` to combine multiple orderings. Orderings are applied in the order they are added. You can also use ordering across multiple tables just like with filters.\n```\nFuture<void> orderWithType() async {\n  // Order all items by their creation date in ascending order\n  managers.todoItems.orderBy((o) => o.createdAt.asc());\n  // Order all items by their title in ascending order and then by their content in ascending order\n  managers.todoItems.orderBy((o) => o.title.asc() & o.content.asc());\n}\n```\nWhen including nullable columns in `orderBy`, you might want to control whether `NULL` values are placed at the start or end of the results. This is possible with the `nulls` parameter on `asc()` and `desc()`. For instance, you could write `o.title.asc(nulls: NullsOrder.first)` to request that todo items without a title appear before those that have one.\n### Count and exists[#](https://drift.simonbinder.eu/dart_api/manager#count-and-exists)\nThe manager makes it easy to check if a row exists or to count the number of rows that match a certain condition.\n```\nFuture<void> count() async {\n  // Count all items\n  await managers.todoItems.count();\n  // Count all items with a title of \"Title\"\n  await managers.todoItems.filter((f) => f.title(\"Title\")).count();\n}\n```\n```\nFuture<void> exists() async {\n  // Check if any items exist\n  await managers.todoItems.exists();\n  // Check if any items with a title of \"Title\" exist\n  await managers.todoItems.filter((f) => f.title(\"Title\")).exists();\n}\n```\n## Updates[#](https://drift.simonbinder.eu/dart_api/manager#updates)\nWe can use the manager to update rows in bulk or individual rows that meet a certain condition.\n```\nFuture<void> updateTodoItems() async {\n  // Update all items\n  await managers.todoItems.update((o) => o(content: Value('New Content')));\n  // Update multiple items\n  await managers.todoItems\n      .filter((f) => f.id.isIn([1, 2, 3]))\n      .update((o) => o(content: Value('New Content')));\n}\n```\nWe can also replace an entire row with a new one. Or even replace multiple rows at once.\n```\nFuture<void> replaceTodoItems() async {\n  // Replace a single item\n  var obj = await managers.todoItems.filter((o) => o.id(1)).getSingle();\n  obj = obj.copyWith(content: 'New Content');\n  await managers.todoItems.replace(obj);\n  // Replace multiple items\n  var objs = await managers.todoItems\n      .filter((o) => o.id.isIn([1, 2, 3]))\n      .get();\n  objs = objs.map((o) => o.copyWith(content: 'New Content')).toList();\n  await managers.todoItems.bulkReplace(objs);\n}\n```\n## Creating rows[#](https://drift.simonbinder.eu/dart_api/manager#creating-rows)\nThe manager includes a method for quickly inserting rows into a table. We can insert a single row or multiple rows at once.\n```\nFuture<void> createTodoItem() async {\n  // Create a new item\n  await managers.todoItems.create(\n    (o) => o(title: 'Title', content: 'Content'),\n  );\n  // We can also use `mode` and `onConflict` parameters, just\n  // like in the `[InsertStatement.insert]` method on the table\n  await managers.todoItems.create(\n    (o) => o(title: 'Title', content: 'New Content'),\n    mode: InsertMode.replace,\n  );\n  // We can also create multiple items at once\n  await managers.todoItems.bulkCreate(\n    (o) => [\n      o(title: 'Title 1', content: 'Content 1'),\n      o(title: 'Title 2', content: 'Content 2'),\n    ],\n  );\n}\n```\n## Deleting rows[#](https://drift.simonbinder.eu/dart_api/manager#deleting-rows)\nWe may also delete rows from a table using the manager. Any rows that meet the specified condition will be deleted.\n```\nFuture<void> deleteTodoItems() async {\n  // Delete all items\n  await managers.todoItems.delete();\n  // Delete a single item\n  await managers.todoItems.filter((f) => f.id(5)).delete();\n}\n```\n## Computed Fields[#](https://drift.simonbinder.eu/dart_api/manager#computed-fields)\nManager queries are great when you need to select entire rows from a database table along with their related data. However, there are situations where you might want to perform more complex operations directly within the database for better efficiency.\nDrift offers strong support for writing SQL expressions. These expressions can be used to filter data, sort results, and perform various calculations directly within your SQL queries. This means you can leverage the full power of SQL to handle complex logic right in the database, making your queries more efficient and your code cleaner.\nIf you want to learn more about how to write these SQL expressions, please refer to the [expression](https://drift.simonbinder.eu/dart_api/expressions) documentation.\n```\n// First create an computed field with an expression you want to use\nfinal titleLengthField = db.managers.todoItems.computedField(\n  (o) => o.title.length,\n);\n/// Create a copy of the manager with the computed fields you want to use\nfinal manager = db.managers.todoItems.withFields([titleLengthField]);\n// Then use the computed field in a filter\n// This will filter all items whose title has exactly 10 characters\nmanager.filter((f) => titleLengthField.filter(10));\n// You can also use the computed field in an ordering\n// This will order all items by the length of their title in ascending order\nmanager.orderBy((o) => titleLengthField.order.asc());\n/// You can read the result of the computed field too\nfor (final (item, refs) in await manager.get()) {\n  final titleLength = titleLengthField.read(refs);\n  print('Item ${item.id} has a title length of $titleLength');\n}\n```\nYou can write expressions which reference other columns in the same table or even other tables. The joins will be created automatically by the manager.\n```\n// This computed field will get the name of the user of this todo\nfinal todoUserName = db.managers.todoItems.computedField(\n  (o) => o.category.user.name,\n);\n/// Create a copy of the manager with the computed fields you want to use\nfinal manager = db.managers.todoItems.withFields([todoUserName]);\n/// You can read the result of the computed field too\nfor (final (item, refs) in await manager.get()) {\n  final userName = todoUserName.read(refs);\n  print('Item ${item.id} has a user with the name $userName');\n}\n```\nYou can also use [aggregate](https://drift.simonbinder.eu/dart_api/expressions#aggregate-functions-like-count-and-sum) functions too.\n```\n// You can aggregate over multiple rows in a related table\n// to perform calculations on them\nfinal todoCountcomputedField = db.managers.todoCategory.computedField(\n  (o) => o.todoItemsRefs((o) => o.id).count(),\n);\n/// Create a copy of the manager with the computed fields you want to use\nfinal manager = db.managers.todoCategory.withFields([todoCountcomputedField]);\n/// Read the result of the computed field\nfor (final (category, refs) in await manager.get()) {\n  final todoCount = todoCountcomputedField.read(refs);\n  print('Category ${category.id} has $todoCount todos');\n}\n```\n-   [](https://github.com/simolus3/drift)\n[](https://jaspr.site \"Built with the Jaspr web framework for Dart.\")\n©2019–2025Simon Binder, Drift authors. Documentation licensed under [CC0 1.0](https://creativecommons.org/publicdomain/zero/1.0/), Drift itself is [MIT-licensed](https://github.com/simolus3/drift/blob/develop/LICENSE)",
  "timestamp": 1769987748038,
  "title": "Manager"
}