{
  "url": "https://riverpod.dev/",
  "markdown": "# Riverpod\n[Skip to main content](#__docusaurus_skipToContent_fallback)\n[\n![Riverpod](https://riverpod.dev/img/logo.png)![Riverpod](https://riverpod.dev/img/logo.png)\n**Riverpod**](https://riverpod.dev/)\n[Docs](https://riverpod.dev/docs/introduction/getting_started)\n[English](#)\n-   [English](https://riverpod.dev/)\n-   [Français](https://riverpod.dev/fr/)\n-   [한국어](https://riverpod.dev/ko/)\n-   [日本語](https://riverpod.dev/ja/)\n-   [Español](https://riverpod.dev/es/)\n-   [বাংলা](https://riverpod.dev/bn/)\n-   [Deutsch](https://riverpod.dev/de/)\n-   [Italiano](https://riverpod.dev/it/)\n-   [Русский](https://riverpod.dev/ru/)\n-   [Türkçe](https://riverpod.dev/tr/)\n-   [简体中文](https://riverpod.dev/zh-Hans/)\n[GitHub](https://github.com/rrousselGit/riverpod)\nSearch\n# ![Riverpod](https://riverpod.dev/img/logo.svg)Riverpod\n# A Reactive Caching and Data-binding Framework\n[Get Started](https://riverpod.dev/docs/introduction/getting_started)\nCreate a network request\n```\n@riverpodFuture<String> boredSuggestion(Ref ref) async {  final response = await http.get(    Uri.https('boredapi.com', '/api/activity'),  );  final json = jsonDecode(response.body) as Map;  return json['activity']! as String;}\n```\nListen to the network request in your UI\n```\nclass Home extends ConsumerWidget {  @override  Widget build(BuildContext context, WidgetRef ref) {    final boredSuggestion = ref.watch(boredSuggestionProvider);    // Perform a switch-case on the result to handle loading/error states    return switch (boredSuggestion) {      AsyncData(:final value) => Text('data: $value'),      AsyncError(:final error) => Text('error: $error'),      _ => const Text('loading'),    };  }}\n```\n![Declarative programming](https://riverpod.dev/img/highlights/compile.svg)\n## Declarative programming\nWrite business logic in a manner similar to Stateless widgets.\nHave your network requests to automatically recompute when necessary and make your logic easily reusable/composable/maintainable.\n![Easily implement common UI patterns](https://riverpod.dev/img/highlights/provider.svg)\n## Easily implement common UI patterns\nUsing Riverpod, common yet complex UI patterns such as \"pull to refresh\"/ \"search as we type\"/etc... are only a few lines of code away.\n![Tooling ready](https://riverpod.dev/img/highlights/flutter.svg)\n## Tooling ready\nRiverpod enhances the compiler by having common mistakes be a compilation-error. It also provides custom lint rules and refactoring options. It even has a command line for generating docs.\n## Features\n-   ✅ Declarative programming\n-   ✅ Native network requests support\n-   ✅ Automatic loading/error handling\n-   ✅ Compile safety\n-   ✅ Type-safe query parameters\n-   ✅ Test ready\n-   ✅ Work in plain Dart (servers/CLI/...)\n-   ✅ Easily combinable states\n-   ✅ Built-in support for pull-to-refresh\n-   ✅ Custom lint rules\n-   ✅ Built-in refactorings\n-   ✅ Hot-reload support\n-   ✅ Logging\n-   ✅ Websocket support\n-   ✅ Documentation generator\n# Declare shared state from anywhere\nNo need to jump between your `main.dart` and your UI files anymore.\nPlace the code of your shared state where it belongs, be it in a separate package or right next to the Widget that needs it, without losing testability.\n```\n// A shared state that can be accessed by multiple widgets at the same time.@riverpodclass Count extends _$Count {  @override  int build() => 0;  void increment() => state++;}// Consumes the shared state and rebuild when it changesclass Title extends ConsumerWidget {  @override  Widget build(BuildContext context, WidgetRef ref) {    final count = ref.watch(countProvider);    return Text('$count');  }}\n```\n# Recompute states/rebuild UI only when needed\nWe no longer have to sort/filter lists inside the `build` method or have to resort to advanced cache mechanism.\nWith `[Provider](https://riverpod.dev/docs/concepts/combining_providers)` and [\"families\"](https://riverpod.dev/docs/concepts/modifiers/family), sort your lists or do HTTP requests only when you **truly** need it.\n```\n@riverpodList<Todo> filteredTodos(Ref ref) {  // Providers can consume other providers using the \"ref\" object.  // With ref.watch, providers will automatically update if the watched values changes.  final List<Todo> todos = ref.watch(todosProvider);  final Filter filter = ref.watch(filterProvider);  switch (filter) {    case Filter.all:      return todos;    case Filter.completed:      return todos.where((todo) => todo.completed).toList();    case Filter.uncompleted:      return todos.where((todo) => !todo.completed).toList();  }}\n```\n# Simplify day-to-day work with refactors\nRiverpod offers various refactors, such as \"Wrap widget in a Consumer\" and many more. See the [list of refactorings](https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_lint#all-assists).\n![Simplify day-to-day work with refactors](https://riverpod.dev/img/intro/convert_to_class_provider.gif)\n# Keep your code maintainable with lint rules\nNew lint-rules specific to Riverpod are implemented and more are continuously added. This ensures your code stays in the best conditions. See the [list of lint rules](https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_lint#all-the-lints).\n![Keep your code maintainable with lint rules](https://riverpod.dev/img/intro/lint.gif)\n# Safely read providers\nReading a provider will never result in a bad state. If you can write the code needed to read a provider, you will obtain a valid value.\nThis even applies to asynchronously loaded values. As opposed to with provider, Riverpod allows cleanly handling loading/error cases.\n```\n@riverpodFuture<Configuration> configurations(Ref ref) async {  final uri = Uri.parse('configs.json');  final rawJson = await File.fromUri(uri).readAsString();  return Configuration.fromJson(json.decode(rawJson));}class Example extends ConsumerWidget {  @override  Widget build(BuildContext context, WidgetRef ref) {    final configs = ref.watch(configurationsProvider);    // Use pattern matching to safely handle loading/error states    return switch (configs) {      AsyncData(:final value) => Text('data: ${value.host}'),      AsyncError(:final error) => Text('error: $error'),      _ => const CircularProgressIndicator(),    };  }}\n```\n# Inspect your state in the devtool\nUsing Riverpod, your state is visible out of the box inside Flutter's devtool.\nFurthermore, a full-blown state-inspector is in progress.\n![ Inspect your state in the devtool](https://riverpod.dev/img/intro/devtool.png)\nDocs\n-   [Getting started](https://riverpod.dev/docs/introduction/getting_started)\n-   [What's new in Riverpod 3.0](https://riverpod.dev/docs/whats_new)\n-   [FAQ](https://riverpod.dev/docs/root/FAQ)\n-   [DO/DON'T](https://riverpod.dev/docs/root/do_dont)\nCommunity\n-   [Discord](https://discord.gg/GSt793j6eT)\n-   [GitHub](https://github.com/rrousselgit/riverpod)\n-   [Stack Overflow](https://stackoverflow.com/questions/tagged/riverpod)\n-   [Twitter](https://twitter.com/remi_rousselet)\n-   [Code of conduct](https://github.com/rrousselGit/riverpod/blob/master/CODE_OF_CONDUCT.md)\n-   [Contributing guide](https://github.com/rrousselGit/riverpod/blob/master/CONTRIBUTING.md)\nSponsors\n-   [![Deploys by Netlify](https://www.netlify.com/img/global/badges/netlify-color-bg.svg)](https://www.netlify.com)\n![Riverpod](https://riverpod.dev/img/full_logo.svg)![Riverpod](https://riverpod.dev/img/full_logo.svg)\nCopyright © 2026 Remi Rousselet.\nBuilt with Docusaurus.",
  "timestamp": 1769987712388,
  "title": "Riverpod"
}