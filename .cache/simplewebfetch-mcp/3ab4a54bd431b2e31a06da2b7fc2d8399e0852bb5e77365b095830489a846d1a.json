{
  "url": "https://dart.dev/libraries/async/async-await",
  "markdown": "# Asynchronous programming: futures, async, await\n[Skip to main content](#site-content-title)\ndart.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic.\n[Learn more](https://policies.google.com/technologies/cookies) OK, got it\n [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg) Dart](https://dart.dev/ \"Go to the Dart homepage\")\n-   [Overview](https://dart.dev/overview)\n-   [Docs](https://dart.dev/docs)\n-   [Blog](https://blog.dart.dev)\n-   [Community](https://dart.dev/community)\n-   [Learn](https://dart.dev/learn)\n-   [Try Dart](https://dart.dev/#try-dart)\n-   [Get Dart](https://dart.dev/get-dart)\n[search](https://dart.dev/search \"Navigate to the dart.dev search page.\")\nroutine\n-   light\\_modeLight\n-   dark\\_modeDark\n-   night\\_sight\\_autoAutomatic\napps\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)Dart](https://dart.dev/ \"Navigate to the Dart website.\")\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)DartAPI](https://api.dart.dev \"Navigate to the Dart API website.\")\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)DartBlog](https://blog.dart.dev \"Navigate to the Dart Blog website.\")\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)DartPad](https://dartpad.dev \"Navigate to the DartPad website.\")\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)pub.dev](https://pub.dev \"Navigate to the pub.dev website.\")\nmenu close\n-   [asteriskOverview](https://dart.dev/overview)\n-   [docsDocs](https://dart.dev/docs)\n-   [newsmodeBlog](https://blog.dart.dev)\n-   [publicCommunity](https://dart.dev/community)\n-   [code\\_blocksTry Dart](https://dart.dev)\n-   [downloadGet Dart](https://dart.dev/get-dart)\n-   Languageexpand\\_more\n    -   [\n        Introduction\n        ](https://dart.dev/language)\n    -   [\n        Variables\n        ](https://dart.dev/language/variables)\n    -   [\n        Operators\n        ](https://dart.dev/language/operators)\n    -   [\n        Comments\n        ](https://dart.dev/language/comments)\n    -   [\n        Language versioning\n        ](https://dart.dev/language/versions)\n    -   Typesexpand\\_more\n        -   [\n            Built-in types\n            ](https://dart.dev/language/built-in-types)\n        -   [\n            Records\n            ](https://dart.dev/language/records)\n        -   [\n            Collections\n            ](https://dart.dev/language/collections)\n        -   [\n            Generics\n            ](https://dart.dev/language/generics)\n        -   [\n            Typedefs\n            ](https://dart.dev/language/typedefs)\n        -   [\n            Type system\n            ](https://dart.dev/language/type-system)\n    -   Patternsexpand\\_more\n        -   [\n            Overview & usage\n            ](https://dart.dev/language/patterns)\n        -   [\n            Pattern types\n            ](https://dart.dev/language/pattern-types)\n        -   [\n            Applied tutorialopen\\_in\\_new\n            ](https://codelabs.developers.google.com/codelabs/dart-patterns-records)\n    -   Control flowexpand\\_more\n        -   [\n            Loops\n            ](https://dart.dev/language/loops)\n        -   [\n            Branches\n            ](https://dart.dev/language/branches)\n        -   [\n            Error handling\n            ](https://dart.dev/language/error-handling)\n    -   [\n        Functions\n        ](https://dart.dev/language/functions)\n    -   [\n        Metadata\n        ](https://dart.dev/language/metadata)\n    -   [\n        Libraries & imports\n        ](https://dart.dev/language/libraries)\n    -   Classes & objectsexpand\\_more\n        -   [\n            Classes\n            ](https://dart.dev/language/classes)\n        -   [\n            Constructors\n            ](https://dart.dev/language/constructors)\n        -   [\n            Methods\n            ](https://dart.dev/language/methods)\n        -   [\n            Extend a class\n            ](https://dart.dev/language/extend)\n        -   [\n            Mixins\n            ](https://dart.dev/language/mixins)\n        -   [\n            Enums\n            ](https://dart.dev/language/enums)\n        -   [\n            Dot shorthands\n            ](https://dart.dev/language/dot-shorthands)\n        -   [\n            Extension methods\n            ](https://dart.dev/language/extension-methods)\n        -   [\n            Extension types\n            ](https://dart.dev/language/extension-types)\n        -   [\n            Callable objects\n            ](https://dart.dev/language/callable-objects)\n    -   Class modifiersexpand\\_more\n        -   [\n            Overview & usage\n            ](https://dart.dev/language/class-modifiers)\n        -   [\n            Class modifiers for API maintainers\n            ](https://dart.dev/language/class-modifiers-for-apis)\n        -   [\n            Reference\n            ](https://dart.dev/language/modifier-reference)\n    -   Concurrencyexpand\\_more\n        -   [\n            Overview\n            ](https://dart.dev/language/concurrency)\n        -   [\n            Asynchronous programming\n            ](https://dart.dev/language/async)\n        -   [\n            Isolates\n            ](https://dart.dev/language/isolates)\n    -   Null safetyexpand\\_more\n        -   [\n            Sound null safety\n            ](https://dart.dev/null-safety)\n        -   [\n            Migrating to null safety\n            ](https://dart.dev/null-safety/migration-guide)\n        -   [\n            Understanding null safety\n            ](https://dart.dev/null-safety/understanding-null-safety)\n        -   [\n            Unsound null safety\n            ](https://dart.dev/null-safety/unsound-null-safety)\n        -   [\n            FAQ\n            ](https://dart.dev/null-safety/faq)\n    -   [\n        Keywords\n        ](https://dart.dev/language/keywords)\n-   Core librariesexpand\\_more\n    -   [\n        Overview\n        ](https://dart.dev/libraries)\n    -   [\n        dart:core\n        ](https://dart.dev/libraries/dart-core)\n    -   [\n        dart:async\n        ](https://dart.dev/libraries/dart-async)\n    -   [\n        dart:math\n        ](https://dart.dev/libraries/dart-math)\n    -   [\n        dart:convert\n        ](https://dart.dev/libraries/dart-convert)\n    -   [\n        dart:io\n        ](https://dart.dev/libraries/dart-io)\n    -   [\n        dart:js\\_interop\n        ](https://dart.dev/interop/js-interop)\n    -   [\n        Iterable collections\n        ](https://dart.dev/libraries/collections/iterables)\n    -   Asynchronous programmingexpand\\_more\n        -   [\n            Tutorial\n            ](https://dart.dev/libraries/async/async-await)\n        -   [\n            Futures and error handling\n            ](https://dart.dev/libraries/async/futures-error-handling)\n        -   [\n            Using streams\n            ](https://dart.dev/libraries/async/using-streams)\n        -   [\n            Creating streams\n            ](https://dart.dev/libraries/async/creating-streams)\n-   Effective Dartexpand\\_more\n    -   [\n        Overview\n        ](https://dart.dev/effective-dart)\n    -   [\n        Style\n        ](https://dart.dev/effective-dart/style)\n    -   [\n        Documentation\n        ](https://dart.dev/effective-dart/documentation)\n    -   [\n        Usage\n        ](https://dart.dev/effective-dart/usage)\n    -   [\n        Design\n        ](https://dart.dev/effective-dart/design)\n-   Packagesexpand\\_more\n    -   [\n        How to use packages\n        ](https://dart.dev/tools/pub/packages)\n    -   [\n        Commonly used packages\n        ](https://dart.dev/resources/useful-packages)\n    -   [\n        Creating packages\n        ](https://dart.dev/tools/pub/create-packages)\n    -   [\n        Publishing packages\n        ](https://dart.dev/tools/pub/publishing)\n    -   [\n        Writing package pages\n        ](https://dart.dev/tools/pub/writing-package-pages)\n    -   [\n        Workspaces (monorepo support)\n        ](https://dart.dev/tools/pub/workspaces)\n    -   [\n        Hooks\n        ](https://dart.dev/tools/hooks)\n    -   Package referenceexpand\\_more\n        -   [\n            Dependencies\n            ](https://dart.dev/tools/pub/dependencies)\n        -   [\n            Package layout conventions\n            ](https://dart.dev/tools/pub/package-layout)\n        -   [\n            Pub environment variables\n            ](https://dart.dev/tools/pub/environment-variables)\n        -   [\n            Pubspec file\n            ](https://dart.dev/tools/pub/pubspec)\n        -   [\n            Troubleshooting pub\n            ](https://dart.dev/tools/pub/troubleshoot)\n        -   [\n            Verified publishers\n            ](https://dart.dev/tools/pub/verified-publishers)\n        -   [\n            Security advisories\n            ](https://dart.dev/tools/pub/security-advisories)\n        -   [\n            Versioning\n            ](https://dart.dev/tools/pub/versioning)\n        -   [\n            Custom package repositories\n            ](https://dart.dev/tools/pub/custom-package-repositories)\n    -   [\n        What not to commit\n        ](https://dart.dev/tools/pub/private-files)\n-   Developmentexpand\\_more\n    -   [\n        JSON serialization\n        ](https://dart.dev/libraries/serialization/json)\n    -   [\n        Number representation\n        ](https://dart.dev/resources/language/number-representation)\n    -   [\n        Google APIs\n        ](https://dart.dev/resources/google-apis)\n    -   [\n        Multi-platform apps\n        ](https://dart.dev/multiplatform-apps)\n    -   Command-line & server appsexpand\\_more\n        -   [\n            Overview\n            ](https://dart.dev/server)\n        -   [\n            Get started\n            ](https://dart.dev/tutorials/server/get-started)\n        -   [\n            Write command-line apps\n            ](https://dart.dev/tutorials/server/cmdline)\n        -   [\n            Fetch data from the internet\n            ](https://dart.dev/tutorials/server/fetch-data)\n        -   [\n            Write HTTP servers\n            ](https://dart.dev/tutorials/server/httpserver)\n        -   [\n            Libraries & packages\n            ](https://dart.dev/server/libraries)\n        -   [\n            Google Cloud\n            ](https://dart.dev/server/google-cloud)\n    -   Web appsexpand\\_more\n        -   [\n            Overview\n            ](https://dart.dev/web)\n        -   [\n            Get started\n            ](https://dart.dev/web/get-started)\n        -   [\n            Deployment\n            ](https://dart.dev/web/deployment)\n        -   [\n            Libraries & packages\n            ](https://dart.dev/web/libraries)\n        -   [\n            Wasm compilation\n            ](https://dart.dev/web/wasm)\n    -   [\n        Environment declarations\n        ](https://dart.dev/libraries/core/environment-declarations)\n-   Interoperabilityexpand\\_more\n    -   [\n        C interop\n        ](https://dart.dev/interop/c-interop)\n    -   [\n        Objective-C & Swift interop\n        ](https://dart.dev/interop/objective-c-interop)\n    -   [\n        Java & Kotlin interop\n        ](https://dart.dev/interop/java-interop)\n    -   JavaScript interopexpand\\_more\n        -   [\n            Overview\n            ](https://dart.dev/interop/js-interop)\n        -   [\n            Usage\n            ](https://dart.dev/interop/js-interop/usage)\n        -   [\n            JS types\n            ](https://dart.dev/interop/js-interop/js-types)\n        -   [\n            Tutorials\n            ](https://dart.dev/interop/js-interop/tutorials)\n        -   [\n            Past JS interop\n            ](https://dart.dev/interop/js-interop/past-js-interop)\n        -   [\n            Web interop\n            ](https://dart.dev/interop/js-interop/package-web)\n-   Tools & techniquesexpand\\_more\n    -   [\n        Overview\n        ](https://dart.dev/tools)\n    -   AIexpand\\_more\n        -   [\n            Dart and Flutter MCP Serveropen\\_in\\_new\n            ](https://docs.flutter.dev/ai/mcp-server)\n    -   Editors & debuggersexpand\\_more\n        -   [\n            IntelliJ & Android Studio\n            ](https://dart.dev/tools/jetbrains-plugin)\n        -   [\n            VS Code\n            ](https://dart.dev/tools/vs-code)\n        -   [\n            Troubleshoot analyzer performance\n            ](https://dart.dev/tools/analyzer-performance)\n        -   [\n            Dart DevTools\n            ](https://dart.dev/tools/dart-devtools)\n        -   DartPadexpand\\_more\n            -   [\n                Overview\n                ](https://dart.dev/tools/dartpad)\n            -   [\n                Troubleshooting DartPad\n                ](https://dart.dev/tools/dartpad/troubleshoot)\n    -   Command-line toolsexpand\\_more\n        -   Dart SDKexpand\\_more\n            -   [\n                Overview\n                ](https://dart.dev/tools/sdk)\n            -   [\n                dart\n                ](https://dart.dev/tools/dart-tool)\n            -   [\n                dart analyze\n                ](https://dart.dev/tools/dart-analyze)\n            -   [\n                dart build\n                ](https://dart.dev/tools/dart-build)\n            -   [\n                dart compile\n                ](https://dart.dev/tools/dart-compile)\n            -   [\n                dart create\n                ](https://dart.dev/tools/dart-create)\n            -   [\n                dart doc\n                ](https://dart.dev/tools/dart-doc)\n            -   [\n                dart fix\n                ](https://dart.dev/tools/dart-fix)\n            -   [\n                dart format\n                ](https://dart.dev/tools/dart-format)\n            -   [\n                dart info\n                ](https://dart.dev/tools/dart-info)\n            -   [\n                dart install\n                ](https://dart.dev/tools/dart-install)\n            -   [\n                dart pub\n                ](https://dart.dev/tools/pub/cmd)\n            -   [\n                dart run\n                ](https://dart.dev/tools/dart-run)\n            -   [\n                dart test\n                ](https://dart.dev/tools/dart-test)\n            -   [\n                dartaotruntime\n                ](https://dart.dev/tools/dartaotruntime)\n            -   [\n                Experiment flags\n                ](https://dart.dev/tools/experiment-flags)\n        -   Other command-line toolsexpand\\_more\n            -   [\n                build\\_runner\n                ](https://dart.dev/tools/build_runner)\n            -   [\n                webdev\n                ](https://dart.dev/tools/webdev)\n    -   Static analysisexpand\\_more\n        -   [\n            Customizing static analysis\n            ](https://dart.dev/tools/analysis)\n        -   [\n            Fixing type promotion failures\n            ](https://dart.dev/tools/non-promotion-reasons)\n        -   [\n            Linter rules\n            ](https://dart.dev/tools/linter-rules)\n        -   [\n            Analyzer plugins\n            ](https://dart.dev/tools/analyzer-plugins)\n        -   [\n            Diagnostic messages\n            ](https://dart.dev/tools/diagnostics)\n    -   Testing & optimizationexpand\\_more\n        -   [\n            Testing\n            ](https://dart.dev/tools/testing)\n        -   [\n            Debugging web apps\n            ](https://dart.dev/web/debugging)\n-   Learn Dartexpand\\_more\n    -   [\n        Overview\n        ](https://dart.dev/learn)\n    -   [\n        Tutorial\n        ](https://dart.dev/learn/tutorial)\n-   Stay up to dateexpand\\_more\n    -   [\n        Dart Blogopen\\_in\\_new\n        ](https://blog.dart.dev)\n    -   [\n        Changelog\n        ](https://dart.dev/changelog)\n    -   [\n        What's new in the docs\n        ](https://dart.dev/resources/whats-new)\n-   Resourcesexpand\\_more\n    -   [\n        Language cheatsheet\n        ](https://dart.dev/resources/dart-cheatsheet)\n    -   [\n        Language specification\n        ](https://dart.dev/resources/language/spec)\n    -   [\n        Dart 3 migration guide\n        ](https://dart.dev/resources/dart-3-migration)\n    -   [\n        From JavaScript to Dart\n        ](https://dart.dev/resources/coming-from/js-to-dart)\n    -   [\n        From Swift to Dart\n        ](https://dart.dev/resources/coming-from/swift-to-dart)\n    -   [\n        FAQ\n        ](https://dart.dev/resources/faq)\n    -   [\n        Glossary\n        ](https://dart.dev/resources/glossary)\n    -   [\n        Books\n        ](https://dart.dev/resources/books)\n    -   [\n        Videos\n        ](https://dart.dev/resources/videos)\n    -   [\n        Tutorials\n        ](https://dart.dev/tutorials)\n-   Related sitesexpand\\_more\n    -   [\n        API referenceopen\\_in\\_new\n        ](https://api.dart.dev)\n    -   [\n        DartPad (online editor)open\\_in\\_new\n        ](https://dartpad.dev)\n    -   [\n        Flutteropen\\_in\\_new\n        ](https://flutter.dev)\n    -   [\n        Package siteopen\\_in\\_new\n        ](https://pub.dev)\nlistOn this page chevron\\_rightAsynchronous programming: futures, async, await\n[vertical\\_align\\_top Asynchronous programming: futures, async, await](#site-content-title)\n-   [Why asynchronous code matters](#why-asynchronous-code-matters)\n    -   [Example: Incorrectly using an asynchronous function](#example-incorrectly-using-an-asynchronous-function)\n-   [What is a future?](#what-is-a-future)\n    -   [Uncompleted](#uncompleted)\n    -   [Completed](#completed)\n    -   [Example: Introducing futures](#example-introducing-futures)\n    -   [Example: Completing with an error](#example-completing-with-an-error)\n-   [Working with futures: async and await](#working-with-futures-async-and-await)\n    -   [Execution flow with async and await](#execution-flow-with-async-and-await)\n    -   [Example: Execution within async functions](#example-execution-within-async-functions)\n    -   [Exercise: Practice using async and await](#exercise-practice-using-async-and-await)\n-   [Handling errors](#handling-errors)\n    -   [Example: async and await with try-catch](#example-async-and-await-with-try-catch)\n    -   [Exercise: Practice handling errors](#exercise-practice-handling-errors)\n-   [Exercise: Putting it all together](#exercise-putting-it-all-together)\n-   [Which lints work for futures?](#which-lints-work-for-futures)\n-   [What's next?](#whats-next)\nDart 3.10 is taking off with dot shorthands, stable build hooks, nuanced deprecation annotations, and more! [Learn more](https://blog.dart.dev/announcing-dart-3-10-ea8b952b6088)\nlist On this page\n-   [Why asynchronous code matters](#why-asynchronous-code-matters)\n    -   [Example: Incorrectly using an asynchronous function](#example-incorrectly-using-an-asynchronous-function)\n-   [What is a future?](#what-is-a-future)\n    -   [Uncompleted](#uncompleted)\n    -   [Completed](#completed)\n    -   [Example: Introducing futures](#example-introducing-futures)\n    -   [Example: Completing with an error](#example-completing-with-an-error)\n-   [Working with futures: async and await](#working-with-futures-async-and-await)\n    -   [Execution flow with async and await](#execution-flow-with-async-and-await)\n    -   [Example: Execution within async functions](#example-execution-within-async-functions)\n    -   [Exercise: Practice using async and await](#exercise-practice-using-async-and-await)\n-   [Handling errors](#handling-errors)\n    -   [Example: async and await with try-catch](#example-async-and-await-with-try-catch)\n    -   [Exercise: Practice handling errors](#exercise-practice-handling-errors)\n-   [Exercise: Putting it all together](#exercise-putting-it-all-together)\n-   [Which lints work for futures?](#which-lints-work-for-futures)\n-   [What's next?](#whats-next)\n1.  [Core libraries](https://dart.dev/libraries)chevron\\_right\n2.  [Async](https://dart.dev/libraries/async)chevron\\_right\n3.  [Futures, async, and await](https://dart.dev/libraries/async/async-await)\n# Asynchronous programming: futures, async, await\nLearn about and practice writing asynchronous code in DartPad!\nmore\\_vert\n-   copyCopy link\n-   [docsView source](https://github.com/dart-lang/site-www/blob/main/src/content/libraries/async/async-await.md)\n-   [bug\\_reportReport issue](https://github.com/dart-lang/site-www/issues/new?template=1_page_issue.yml&page-url=https://dart.dev/libraries/async/async-await&page-source=https://github.com/dart-lang/site-www/blob/main/src/content/libraries/async/async-await.md)\nThis tutorial teaches you how to write asynchronous code using futures and the `async` and `await` keywords. Using embedded DartPad editors, you can test your knowledge by running example code and completing exercises.\nTo get the most out of this tutorial, you should have the following:\n-   Knowledge of [basic Dart syntax](https://dart.dev/language).\n-   Some experience writing asynchronous code in another language.\n-   The [`discarded_futures`](https://dart.dev/tools/linter-rules/discarded_futures) and [`unawaited_futures`](https://dart.dev/tools/linter-rules/unawaited_futures) lints enabled.\nThis tutorial covers the following material:\n-   How and when to use the `async` and `await` keywords.\n-   How using `async` and `await` affects execution order.\n-   How to handle errors from an asynchronous call using `try-catch` expressions in `async` functions.\nEstimated time to complete this tutorial: 40-60 minutes.\ninfoNote\nThis page uses embedded DartPads to display examples and exercises. If you see empty boxes instead of DartPads, go to the [DartPad troubleshooting page](https://dart.dev/tools/dartpad/troubleshoot).\nThe exercises in this tutorial have partially completed code snippets. You can use DartPad to test your knowledge by completing the code and clicking the **Run** button. **Don't edit the test code in the `main` function or below**.\nIf you need help, expand the **Hint** or **Solution** dropdown after each exercise.\n## Why asynchronous code matters\n[#](#why-asynchronous-code-matters)\nAsynchronous operations let your program complete work while waiting for another operation to finish. Here are some common asynchronous operations:\n-   Fetching data over a network.\n-   Writing to a database.\n-   Reading data from a file.\nSuch asynchronous computations usually provide their result as a `Future` or, if the result has multiple parts, as a `Stream`. These computations introduce asynchrony into a program. To accommodate that initial asynchrony, other plain Dart functions also need to become asynchronous.\nTo interact with these asynchronous results, you can use the `async` and `await` keywords. Most asynchronous functions are just async Dart functions that depend, possibly deep down, on an inherently asynchronous computation.\n### Example: Incorrectly using an asynchronous function\n[#](#example-incorrectly-using-an-asynchronous-function)\nThe following example shows the wrong way to use an asynchronous function (`fetchUserOrder()`). Later you'll fix the example using `async` and `await`. Before running this example, try to spot the issue -- what do you think the output will be?\n```\n// This example shows how *not* to write asynchronous Dart code.\nString createOrderMessage() {\n  var order = fetchUserOrder();\n  return 'Your order is: $order';\n}\nFuture<String> fetchUserOrder() =>\n    // Imagine that this function is more complex and slow.\n    Future.delayed(const Duration(seconds: 2), () => 'Large Latte');\nvoid main() {\n  print(createOrderMessage());\n}\n```\nHere's why the example fails to print the value that `fetchUserOrder()` eventually produces:\n-   `fetchUserOrder()` is an asynchronous function that, after a delay, provides a string that describes the user's order: a \"Large Latte\".\n-   To get the user's order, `createOrderMessage()` should call `fetchUserOrder()` and wait for it to finish. Because `createOrderMessage()` does _not_ wait for `fetchUserOrder()` to finish, `createOrderMessage()` fails to get the string value that `fetchUserOrder()` eventually provides.\n-   Instead, `createOrderMessage()` gets a representation of pending work to be done: an uncompleted future. You'll learn more about futures in the next section.\n-   Because `createOrderMessage()` fails to get the value describing the user's order, the example fails to print \"Large Latte\" to the console, and instead prints \"Your order is: Instance of '\\_Future<String>'\".\nIn the next sections you'll learn about futures and about working with futures (using `async` and `await`) so that you'll be able to write the code necessary to make `fetchUserOrder()` print the desired value (\"Large Latte\") to the console.\nKey terms\n-   **synchronous operation**: A synchronous operation blocks other operations from executing until it completes.\n-   **synchronous function**: A synchronous function only performs synchronous operations.\n-   **asynchronous operation**: Once initiated, an asynchronous operation allows other operations to execute before it completes.\n-   **asynchronous function**: An asynchronous function performs at least one asynchronous operation and can also perform _synchronous_ operations.\n## What is a future?\n[#](#what-is-a-future)\nA future (lower case \"f\") is an instance of the [Future](https://api.dart.dev/dart-async/Future-class.html) (capitalized \"F\") class. A future represents the result of an asynchronous operation, and can have two states: uncompleted or completed.\ninfoNote\n_Uncompleted_ is a Dart term referring to the state of a future before it has produced a value.\n### Uncompleted\n[#](#uncompleted)\nWhen you call an asynchronous function, it returns an uncompleted future. That future is waiting for the function's asynchronous operation to finish or to throw an error.\n### Completed\n[#](#completed)\nIf the asynchronous operation succeeds, the future completes with a value. Otherwise, it completes with an error.\n#### Completing with a value\n[#](#completing-with-a-value)\nA future of type `Future<T>` completes with a value of type `T`. For example, a future with type `Future<String>` produces a string value. If a future doesn't produce a usable value, then the future's type is `Future<void>`.\n#### Completing with an error\n[#](#completing-with-an-error)\nIf the asynchronous operation performed by the function fails for any reason, the future completes with an error.\n### Example: Introducing futures\n[#](#example-introducing-futures)\nIn the following example, `fetchUserOrder()` returns a future that completes after printing to the console. Because it doesn't return a usable value, `fetchUserOrder()` has the type `Future<void>`. Before you run the example, try to predict which will print first: \"Large Latte\" or \"Fetching user order...\".\n```\nFuture<void> fetchUserOrder() {\n  // Imagine that this function is fetching user info from another service or database.\n  return Future.delayed(const Duration(seconds: 2), () => print('Large Latte'));\n}\nvoid main() {\n  fetchUserOrder();\n  print('Fetching user order...');\n}\n```\nIn the preceding example, even though `fetchUserOrder()` executes before the `print()` call on line 8, the console shows the output from line 8(\"Fetching user order...\") before the output from `fetchUserOrder()` (\"Large Latte\"). This is because `fetchUserOrder()` delays before it prints \"Large Latte\".\n### Example: Completing with an error\n[#](#example-completing-with-an-error)\nRun the following example to see how a future completes with an error. A bit later you'll learn how to handle the error.\n```\nFuture<void> fetchUserOrder() {\n  // Imagine that this function is fetching user info but encounters a bug.\n  return Future.delayed(\n    const Duration(seconds: 2),\n    () => throw Exception('Logout failed: user ID is invalid'),\n  );\n}\nvoid main() {\n  fetchUserOrder();\n  print('Fetching user order...');\n}\n```\nIn this example, `fetchUserOrder()` completes with an error indicating that the user ID is invalid.\nYou've learned about futures and how they complete, but how do you use the results of asynchronous functions? In the next section you'll learn how to get results with the `async` and `await` keywords.\nQuick review\n-   A [Future<T>](https://api.dart.dev/dart-async/Future-class.html) instance produces a value of type `T`.\n-   If a future doesn't produce a usable value, then the future's type is `Future<void>`.\n-   A future can be in one of two states: uncompleted or completed.\n-   When you call a function that returns a future, the function queues up work to be done and returns an uncompleted future.\n-   When a future's operation finishes, the future completes with a value or with an error.\n**Key terms:**\n-   **Future**: the Dart [Future](https://api.dart.dev/dart-async/Future-class.html) class.\n-   **future**: an instance of the Dart `Future` class.\n## Working with futures: async and await\n[#](#working-with-futures-async-and-await)\nThe `async` and `await` keywords provide a declarative way to define asynchronous functions and use their results. Remember these two basic guidelines when using `async` and `await`:\n-   **To define an async function, add `async` before the function body:**\n-   **The `await` keyword works only in `async` functions.**\nHere's an example that converts `main()` from a synchronous to asynchronous function.\nFirst, add the `async` keyword before the function body:\ndart\n```\nvoid main() async { ··· }\n```\ncontent\\_copy\nIf the function has a declared return type, then update the type to be `Future<T>`, where `T` is the type of the value that the function returns. If the function doesn't explicitly return a value, then the return type is `Future<void>`:\ndart\n```\nFuture<void> main() async { ··· }\n```\ncontent\\_copy\nNow that you have an `async` function, you can use the `await` keyword to wait for a future to complete:\ndart\n```\nprint(await createOrderMessage());\n```\ncontent\\_copy\nAs the following two examples show, the `async` and `await` keywords result in asynchronous code that looks a lot like synchronous code. The only differences are highlighted in the asynchronous example, which—if your window is wide enough—is to the right of the synchronous example.\n#### Example: synchronous functions\n[#](#example-synchronous-functions)\ndart\n```\nString createOrderMessage() {\n  var order = fetchUserOrder();\n  return 'Your order is: $order';\n}\n​\nFuture<String> fetchUserOrder() =>\n    // Imagine that this function is\n    // more complex and slow.\n    Future.delayed(const Duration(seconds: 2), () => 'Large Latte');\n​\nvoid main() {\n  print('Fetching user order...');\n  print(createOrderMessage());\n}\n```\ncontent\\_copy\n```\nFetching user order...\nYour order is: Instance of 'Future<String>'\n```\ncontent\\_copy\nAs shown in following two examples, it operates like synchronous code.\n#### Example: asynchronous functions\n[#](#example-asynchronous-functions)\ndart\n```\nFuture<String> createOrderMessage() async {\n  var order = await fetchUserOrder();\n  return 'Your order is: $order';\n}\n​\nFuture<String> fetchUserOrder() =>\n    // Imagine that this function is\n    // more complex and slow.\n    Future.delayed(const Duration(seconds: 2), () => 'Large Latte');\n​\nFuture<void> main() async {\n  print('Fetching user order...');\n  print(await createOrderMessage());\n}\n```\ncontent\\_copy\n```\nFetching user order...\nYour order is: Large Latte\n```\ncontent\\_copy\nThe asynchronous example is different in three ways:\n-   The return type for `createOrderMessage()` changes from `String` to `Future<String>`.\n-   The **`async`** keyword appears before the function bodies for `createOrderMessage()` and `main()`.\n-   The **`await`** keyword appears before calling the asynchronous functions `fetchUserOrder()` and `createOrderMessage()`.\nKey terms\n-   **async**: You can use the `async` keyword before a function's body to mark it as asynchronous.\n-   **async function**: An `async` function is a function labeled with the `async` keyword.\n-   **await**: You can use the `await` keyword to get the completed result of an asynchronous expression. The `await` keyword only works within an `async` function.\n### Execution flow with async and await\n[#](#execution-flow-with-async-and-await)\nAn `async` function runs synchronously until the first `await` keyword. This means that within an `async` function body, all synchronous code before the first `await` keyword executes immediately.\n### Example: Execution within async functions\n[#](#example-execution-within-async-functions)\nRun the following example to see how execution proceeds within an `async` function body. What do you think the output will be?\n```\nFuture<void> printOrderMessage() async {\n  print('Awaiting user order...');\n  var order = await fetchUserOrder();\n  print('Your order is: $order');\n}\nFuture<String> fetchUserOrder() {\n  // Imagine that this function is more complex and slow.\n  return Future.delayed(const Duration(seconds: 4), () => 'Large Latte');\n}\nvoid main() async {\n  countSeconds(4);\n  await printOrderMessage();\n}\n// You can ignore this function - it's here to visualize delay time in this example.\nvoid countSeconds(int s) {\n  for (var i = 1; i <= s; i++) {\n    Future.delayed(Duration(seconds: i), () => print(i));\n  }\n}\n```\nAfter running the code in the preceding example, try reversing lines 2 and 3:\ndart\n```\nvar order = await fetchUserOrder();\nprint('Awaiting user order...');\n```\ncontent\\_copy\nNotice that timing of the output shifts, now that `print('Awaiting user order')` appears after the first `await` keyword in `printOrderMessage()`.\n### Exercise: Practice using async and await\n[#](#exercise-practice-using-async-and-await)\nThe following exercise is a failing unit test that contains partially completed code snippets. Your task is to complete the exercise by writing code to make the tests pass. You don't need to implement `main()`.\nTo simulate asynchronous operations, call the following functions, which are provided for you:\n| Function | Type signature | Description |\n| --- | --- | --- |\n| fetchRole() | `Future<String> fetchRole()` | Gets a short description of the user's role. |\n| fetchLoginAmount() | `Future<int> fetchLoginAmount()` | Gets the number of times a user has logged in. |\n#### Part 1: `reportUserRole()`\n[#](#part-1-reportuserrole)\nAdd code to the `reportUserRole()` function so that it does the following:\n-   Returns a future that completes with the following string: `\"User role: <user role>\"`\n    -   Note: You must use the actual value returned by `fetchRole()`; copying and pasting the example return value won't make the test pass.\n    -   Example return value: `\"User role: tester\"`\n-   Gets the user role by calling the provided function `fetchRole()`.\n#### Part 2: `reportLogins()`\n[#](#part-2-reportlogins)\nImplement an `async` function `reportLogins()` so that it does the following:\n-   Returns the string `\"Total number of logins: <# of logins>\"`.\n    -   Note: You must use the actual value returned by `fetchLoginAmount()`; copying and pasting the example return value won't make the test pass.\n    -   Example return value from `reportLogins()`: `\"Total number of logins: 57\"`\n-   Gets the number of logins by calling the provided function `fetchLoginAmount()`.\n```\n// Part 1\n// Call the provided async function fetchRole()\n// to return the user role.\nFuture<String> reportUserRole() async {\n  // TODO: Implement the reportUserRole function here.\n}\n// Part 2\n// TODO: Implement the reportLogins function here.\n// Call the provided async function fetchLoginAmount()\n// to return the number of times that the user has logged in.\nreportLogins() {}\n// The following functions those provided to you to simulate\n// asynchronous operations that could take a while.\nFuture<String> fetchRole() => Future.delayed(_halfSecond, () => _role);\nFuture<int> fetchLoginAmount() => Future.delayed(_halfSecond, () => _logins);\n// The following code is used to test and provide feedback on your solution.\n// There is no need to read or modify it.\nvoid main() async {\n  print('Testing...');\n  List<String> messages = [];\n  const passed = 'PASSED';\n  const testFailedMessage = 'Test failed for the function:';\n  const typoMessage = 'Test failed! Check for typos in your return value';\n  try {\n    messages\n      ..add(_makeReadable(\n          testLabel: 'Part 1',\n          testResult: await _asyncEquals(\n            expected: 'User role: administrator',\n            actual: await reportUserRole(),\n            typoKeyword: _role,\n          ),\n          readableErrors: {\n            typoMessage: typoMessage,\n            'null':\n                'Test failed! Did you forget to implement or return from reportUserRole?',\n            'User role: Instance of \\'Future<String>\\'':\n                '$testFailedMessage reportUserRole. Did you use the await keyword?',\n            'User role: Instance of \\'_Future<String>\\'':\n                '$testFailedMessage reportUserRole. Did you use the await keyword?',\n            'User role:':\n                '$testFailedMessage reportUserRole. Did you return a user role?',\n            'User role: ':\n                '$testFailedMessage reportUserRole. Did you return a user role?',\n            'User role: tester':\n                '$testFailedMessage reportUserRole. Did you invoke fetchRole to fetch the user\\'s role?',\n          }))\n      ..add(_makeReadable(\n          testLabel: 'Part 2',\n          testResult: await _asyncEquals(\n            expected: 'Total number of logins: 42',\n            actual: await reportLogins(),\n            typoKeyword: _logins.toString(),\n          ),\n          readableErrors: {\n            typoMessage: typoMessage,\n            'null':\n                'Test failed! Did you forget to implement or return from reportLogins?',\n            'Total number of logins: Instance of \\'Future<int>\\'':\n                '$testFailedMessage reportLogins. Did you use the await keyword?',\n            'Total number of logins: Instance of \\'_Future<int>\\'':\n                '$testFailedMessage reportLogins. Did you use the await keyword?',\n            'Total number of logins: ':\n                '$testFailedMessage reportLogins. Did you return the number of logins?',\n            'Total number of logins:':\n                '$testFailedMessage reportLogins. Did you return the number of logins?',\n            'Total number of logins: 57':\n                '$testFailedMessage reportLogins. Did you invoke fetchLoginAmount to fetch the number of user logins?',\n          }))\n      ..removeWhere((m) => m.contains(passed))\n      ..toList();\n    if (messages.isEmpty) {\n      print('Success. All tests passed!');\n    } else {\n      messages.forEach(print);\n    }\n  } on UnimplementedError {\n    print(\n        'Test failed! Did you forget to implement or return from reportUserRole?');\n  } catch (e) {\n    print('Tried to run solution, but received an exception: $e');\n  }\n}\nconst _role = 'administrator';\nconst _logins = 42;\nconst _halfSecond = Duration(milliseconds: 500);\n// Test helpers.\nString _makeReadable({\n  required String testResult,\n  required Map<String, String> readableErrors,\n  required String testLabel,\n}) {\n  if (readableErrors.containsKey(testResult)) {\n    var readable = readableErrors[testResult];\n    return '$testLabel $readable';\n  } else {\n    return '$testLabel $testResult';\n  }\n}\n// Assertions used in tests.\nFuture<String> _asyncEquals({\n  required String expected,\n  required dynamic actual,\n  required String typoKeyword,\n}) async {\n  var strActual = actual is String ? actual : actual.toString();\n  try {\n    if (expected == actual) {\n      return 'PASSED';\n    } else if (strActual.contains(typoKeyword)) {\n      return 'Test failed! Check for typos in your return value';\n    } else {\n      return strActual;\n    }\n  } catch (e) {\n    return e.toString();\n  }\n}\n```\nHint\nDid you remember to add the `async` keyword to the `reportUserRole` function?\nDid you remember to use the `await` keyword before invoking `fetchRole()`?\nRemember: `reportUserRole` needs to return a `Future`.\nSolution\ndart\n```\nFuture<String> reportUserRole() async {\n  final username = await fetchRole();\n  return 'User role: $username';\n}\n​\nFuture<String> reportLogins() async {\n  final logins = await fetchLoginAmount();\n  return 'Total number of logins: $logins';\n}\n```\ncontent\\_copy\n## Handling errors\n[#](#handling-errors)\nTo handle errors in an `async` function, use try-catch:\ndart\n```\ntry {\n  print('Awaiting user order...');\n  var order = await fetchUserOrder();\n} catch (err) {\n  print('Caught error: $err');\n}\n```\ncontent\\_copy\nWithin an `async` function, you can write [try-catch clauses](https://dart.dev/language/error-handling#catch) the same way you would in synchronous code.\n### Example: async and await with try-catch\n[#](#example-async-and-await-with-try-catch)\nRun the following example to see how to handle an error from an asynchronous function. What do you think the output will be?\n```\nFuture<void> printOrderMessage() async {\n  try {\n    print('Awaiting user order...');\n    var order = await fetchUserOrder();\n    print(order);\n  } catch (err) {\n    print('Caught error: $err');\n  }\n}\nFuture<String> fetchUserOrder() {\n  // Imagine that this function is more complex.\n  var str = Future.delayed(\n    const Duration(seconds: 4),\n    () => throw 'Cannot locate user order',\n  );\n  return str;\n}\nvoid main() async {\n  await printOrderMessage();\n}\n```\n### Exercise: Practice handling errors\n[#](#exercise-practice-handling-errors)\nThe following exercise provides practice handling errors with asynchronous code, using the approach described in the previous section. To simulate asynchronous operations, your code will call the following function, which is provided for you:\n| Function | Type signature | Description |\n| --- | --- | --- |\n| fetchNewUsername() | `Future<String> fetchNewUsername()` | Returns the new username that you can use to replace an old one. |\nUse `async` and `await` to implement an asynchronous `changeUsername()` function that does the following:\n-   Calls the provided asynchronous function `fetchNewUsername()` and returns its result.\n    -   Example return value from `changeUsername()`: `\"jane_smith_92\"`\n-   Catches any error that occurs and returns the string value of the error.\n    -   You can use the [toString()](https://api.dart.dev/dart-core/ArgumentError/toString.html) method to stringify both [Exceptions](https://api.dart.dev/dart-core/Exception-class.html) and [Errors.](https://api.dart.dev/dart-core/Error-class.html)\n```\n// TODO: Implement changeUsername here.\nchangeUsername() {}\n// The following function is provided to you to simulate\n// an asynchronous operation that could take a while and\n// potentially throw an exception.\nFuture<String> fetchNewUsername() =>\n    Future.delayed(const Duration(milliseconds: 500), () => throw UserError());\nclass UserError implements Exception {\n  @override\n  String toString() => 'New username is invalid';\n}\n// The following code is used to test and provide feedback on your solution.\n// There is no need to read or modify it.\nvoid main() async {\n  final List<String> messages = [];\n  const typoMessage = 'Test failed! Check for typos in your return value';\n  print('Testing...');\n  try {\n    messages\n      ..add(_makeReadable(\n          testLabel: '',\n          testResult: await _asyncDidCatchException(changeUsername),\n          readableErrors: {\n            typoMessage: typoMessage,\n            _noCatch:\n                'Did you remember to call fetchNewUsername within a try/catch block?',\n          }))\n      ..add(_makeReadable(\n          testLabel: '',\n          testResult: await _asyncErrorEquals(changeUsername),\n          readableErrors: {\n            typoMessage: typoMessage,\n            _noCatch:\n                'Did you remember to call fetchNewUsername within a try/catch block?',\n          }))\n      ..removeWhere((m) => m.contains(_passed))\n      ..toList();\n    if (messages.isEmpty) {\n      print('Success. All tests passed!');\n    } else {\n      messages.forEach(print);\n    }\n  } catch (e) {\n    print('Tried to run solution, but received an exception: $e');\n  }\n}\n// Test helpers.\nString _makeReadable({\n  required String testResult,\n  required Map<String, String> readableErrors,\n  required String testLabel,\n}) {\n  if (readableErrors.containsKey(testResult)) {\n    final readable = readableErrors[testResult];\n    return '$testLabel $readable';\n  } else {\n    return '$testLabel $testResult';\n  }\n}\nFuture<String> _asyncErrorEquals(Function fn) async {\n  final result = await fn();\n  if (result == UserError().toString()) {\n    return _passed;\n  } else {\n    return 'Test failed! Did you stringify and return the caught error?';\n  }\n}\nFuture<String> _asyncDidCatchException(Function fn) async {\n  var caught = true;\n  try {\n    await fn();\n  } on UserError catch (_) {\n    caught = false;\n  }\n  if (caught == false) {\n    return _noCatch;\n  } else {\n    return _passed;\n  }\n}\nconst _passed = 'PASSED';\nconst _noCatch = 'NO_CATCH';\n```\nHint\nImplement `changeUsername` to return the string from `fetchNewUsername` or, if that fails, the string value of any error that occurs.\nRemember: You can use a [try-catch statement](https://dart.dev/language/error-handling#catch) to catch and handle errors.\nSolution\ndart\n```\nFuture<String> changeUsername() async {\n  try {\n    return await fetchNewUsername();\n  } catch (err) {\n    return err.toString();\n  }\n}\n```\ncontent\\_copy\n## Exercise: Putting it all together\n[#](#exercise-putting-it-all-together)\nIt's time to practice what you've learned in one final exercise. To simulate asynchronous operations, this exercise provides the asynchronous functions `fetchUsername()` and `logoutUser()`:\n| Function | Type signature | Description |\n| --- | --- | --- |\n| fetchUsername() | `Future<String> fetchUsername()` | Returns the name associated with the current user. |\n| logoutUser() | `Future<String> logoutUser()` | Performs logout of current user and returns the username that was logged out. |\nWrite the following:\n#### Part 1: `addHello()`\n[#](#part-1-addhello)\n-   Write a function `addHello()` that takes a single `String` argument.\n-   `addHello()` returns its `String` argument preceded by `'Hello '`.\n    Example: `addHello('Jon')` returns `'Hello Jon'`.\n#### Part 2: `greetUser()`\n[#](#part-2-greetuser)\n-   Write a function `greetUser()` that takes no arguments.\n-   To get the username, `greetUser()` calls the provided asynchronous function `fetchUsername()`.\n-   `greetUser()` creates a greeting for the user by calling `addHello()`, passing it the username, and returning the result.\n    Example: If `fetchUsername()` returns `'Jenny'`, then `greetUser()` returns `'Hello Jenny'`.\n#### Part 3: `sayGoodbye()`\n[#](#part-3-saygoodbye)\n-   Write a function `sayGoodbye()` that does the following:\n    -   Takes no arguments.\n    -   Catches any errors.\n    -   Calls the provided asynchronous function `logoutUser()`.\n-   If `logoutUser()` fails, `sayGoodbye()` returns any string you like.\n-   If `logoutUser()` succeeds, `sayGoodbye()` returns the string `'<result> Thanks, see you next time'`, where `<result>` is the string value returned by calling `logoutUser()`.\n```\n// Part 1\naddHello(String user) {}\n// Part 2\n// Call the provided async function fetchUsername()\n// to return the username.\ngreetUser() {}\n// Part 3\n// Call the provided async function logoutUser()\n// to log out the user.\nsayGoodbye() {}\n// The following functions are provided to you to use in your solutions.\nFuture<String> fetchUsername() => Future.delayed(_halfSecond, () => 'Jean');\nFuture<String> logoutUser() => Future.delayed(_halfSecond, _failOnce);\n// The following code is used to test and provide feedback on your solution.\n// There is no need to read or modify it.\nvoid main() async {\n  const didNotImplement =\n      'Test failed! Did you forget to implement or return from';\n  final List<String> messages = [];\n  print('Testing...');\n  try {\n    messages\n      ..add(_makeReadable(\n          testLabel: 'Part 1',\n          testResult: await _asyncEquals(\n              expected: 'Hello Jerry',\n              actual: addHello('Jerry'),\n              typoKeyword: 'Jerry'),\n          readableErrors: {\n            _typoMessage: _typoMessage,\n            'null': '$didNotImplement addHello?',\n            'Hello Instance of \\'Future<String>\\'':\n                'Looks like you forgot to use the \\'await\\' keyword!',\n            'Hello Instance of \\'_Future<String>\\'':\n                'Looks like you forgot to use the \\'await\\' keyword!',\n          }))\n      ..add(_makeReadable(\n          testLabel: 'Part 2',\n          testResult: await _asyncEquals(\n              expected: 'Hello Jean',\n              actual: await greetUser(),\n              typoKeyword: 'Jean'),\n          readableErrors: {\n            _typoMessage: _typoMessage,\n            'null': '$didNotImplement greetUser?',\n            'HelloJean':\n                'Looks like you forgot the space between \\'Hello\\' and \\'Jean\\'',\n            'Hello Instance of \\'Future<String>\\'':\n                'Looks like you forgot to use the \\'await\\' keyword!',\n            'Hello Instance of \\'_Future<String>\\'':\n                'Looks like you forgot to use the \\'await\\' keyword!',\n            '{Closure: (String) => dynamic from Function \\'addHello\\': static.(await fetchUsername())}':\n                'Did you place the \\'\\$\\' character correctly?',\n            '{Closure \\'addHello\\'(await fetchUsername())}':\n                'Did you place the \\'\\$\\' character correctly?',\n          }))\n      ..add(_makeReadable(\n          testLabel: 'Part 3',\n          testResult: await _asyncDidCatchException(sayGoodbye),\n          readableErrors: {\n            _typoMessage:\n                '$_typoMessage. Did you add the text \\'Thanks, see you next time\\'?',\n            'null': '$didNotImplement sayGoodbye?',\n            _noCatch:\n                'Did you remember to call logoutUser within a try/catch block?',\n            'Instance of \\'Future<String>\\' Thanks, see you next time':\n                'Did you remember to use the \\'await\\' keyword in the sayGoodbye function?',\n            'Instance of \\'_Future<String>\\' Thanks, see you next time':\n                'Did you remember to use the \\'await\\' keyword in the sayGoodbye function?',\n          }))\n      ..add(_makeReadable(\n          testLabel: 'Part 3',\n          testResult: await _asyncEquals(\n              expected: 'Success! Thanks, see you next time',\n              actual: await sayGoodbye(),\n              typoKeyword: 'Success'),\n          readableErrors: {\n            _typoMessage:\n                '$_typoMessage. Did you add the text \\'Thanks, see you next time\\'?',\n            'null': '$didNotImplement sayGoodbye?',\n            _noCatch:\n                'Did you remember to call logoutUser within a try/catch block?',\n            'Instance of \\'Future<String>\\' Thanks, see you next time':\n                'Did you remember to use the \\'await\\' keyword in the sayGoodbye function?',\n            'Instance of \\'_Future<String>\\' Thanks, see you next time':\n                'Did you remember to use the \\'await\\' keyword in the sayGoodbye function?',\n            'Instance of \\'_Exception\\'':\n                'CAUGHT Did you remember to return a string?',\n          }))\n      ..removeWhere((m) => m.contains(_passed))\n      ..toList();\n    if (messages.isEmpty) {\n      print('Success. All tests passed!');\n    } else {\n      messages.forEach(print);\n    }\n  } catch (e) {\n    print('Tried to run solution, but received an exception: $e');\n  }\n}\n// Test helpers.\nString _makeReadable({\n  required String testResult,\n  required Map<String, String> readableErrors,\n  required String testLabel,\n}) {\n  String? readable;\n  if (readableErrors.containsKey(testResult)) {\n    readable = readableErrors[testResult];\n    return '$testLabel $readable';\n  } else if ((testResult != _passed) && (testResult.length < 18)) {\n    readable = _typoMessage;\n    return '$testLabel $readable';\n  } else {\n    return '$testLabel $testResult';\n  }\n}\nFuture<String> _asyncEquals({\n  required String expected,\n  required dynamic actual,\n  required String typoKeyword,\n}) async {\n  final strActual = actual is String ? actual : actual.toString();\n  try {\n    if (expected == actual) {\n      return _passed;\n    } else if (strActual.contains(typoKeyword)) {\n      return _typoMessage;\n    } else {\n      return strActual;\n    }\n  } catch (e) {\n    return e.toString();\n  }\n}\nFuture<String> _asyncDidCatchException(Function fn) async {\n  var caught = true;\n  try {\n    await fn();\n  } on Exception catch (_) {\n    caught = false;\n  }\n  if (caught == true) {\n    return _passed;\n  } else {\n    return _noCatch;\n  }\n}\nconst _typoMessage = 'Test failed! Check for typos in your return value';\nconst _passed = 'PASSED';\nconst _noCatch = 'NO_CATCH';\nconst _halfSecond = Duration(milliseconds: 500);\nString _failOnce() {\n  if (_logoutSucceeds) {\n    return 'Success!';\n  } else {\n    _logoutSucceeds = true;\n    throw Exception('Logout failed');\n  }\n}\nbool _logoutSucceeds = false;\n```\nHint\nThe `greetUser` and `sayGoodbye` functions should be asynchronous, while `addHello` should be a normal, synchronous function.\nRemember: You can use a [try-catch statement](https://dart.dev/language/error-handling#catch) to catch and handle errors.\nSolution\ndart\n```\nString addHello(String user) => 'Hello $user';\n​\nFuture<String> greetUser() async {\n  final username = await fetchUsername();\n  return addHello(username);\n}\n​\nFuture<String> sayGoodbye() async {\n  try {\n    final result = await logoutUser();\n    return '$result Thanks, see you next time';\n  } catch (e) {\n    return 'Failed to logout user: $e';\n  }\n}\n```\ncontent\\_copy\n## Which lints work for futures?\n[#](#which-lints-work-for-futures)\nTo catch common mistakes that arise while working with async and futures, [enable](https://dart.dev/tools/analysis#individual-rules) the following lints:\n-   [`discarded_futures`](https://dart.dev/tools/linter-rules/discarded_futures)\n-   [`unawaited_futures`](https://dart.dev/tools/linter-rules/unawaited_futures)\n## What's next?\n[#](#whats-next)\nCongratulations, you've finished the tutorial! If you'd like to learn more, here are some suggestions for where to go next:\n-   Play with [DartPad](https://dartpad.dev).\n-   Try another [tutorial](https://dart.dev/tutorials).\n-   Learn more about futures and asynchronous code in Dart:\n    -   [Streams tutorial](https://dart.dev/libraries/async/using-streams): Learn how to work with a sequence of asynchronous events.\n    -   [Concurrency in Dart](https://dart.dev/language/concurrency): Understand and learn how to implement concurrency in Dart.\n    -   [Asynchronous programming](https://dart.dev/language/async): Dive in to Dart's language and library support for asynchronous coding.\n    -   [Dart videos from Google](https://www.youtube.com/playlist?list=PLjxrf2q8roU0Net_g1NT5_vOO3s_FR02J): Watch one or more of the videos about asynchronous coding.\n-   Get the [Dart SDK](https://dart.dev/get-dart)!\nWas this page's content helpful?\nthumb\\_up thumb\\_down\nUnless stated otherwise, the documentation on this site reflects Dart 3.10.3. Page last updated on 2025-10-18. [View source](https://github.com/dart-lang/site-www/blob/main/src/content/libraries/async/async-await.md) or [report an issue](https://github.com/dart-lang/site-www/issues/new?template=1_page_issue.yml&page-url=https://dart.dev/libraries/async/async-await&page-source=https://github.com/dart-lang/site-www/blob/main/src/content/libraries/async/async-await.md \"Report an issue with this page\").\n[![Dart](https://dart.dev/assets/img/logo/logo-white-text.svg)](https://dart.dev/ \"Dart\")\n[](https://blog.dart.dev \"Dart's Medium publication\")[](https://github.com/dart-lang \"Dart's GitHub organization\")[](https://bsky.app/profile/dart.dev \"Dart's Bluesky (Twitter) profile\")[](https://twitter.com/dart_lang \"Dart's X (Twitter) profile\")\nExcept as otherwise noted, this site is licensed under a [Creative Commons Attribution 4.0 International License,](https://creativecommons.org/licenses/by/4.0/) and code samples are licensed under the [3-Clause BSD License.](https://opensource.org/licenses/BSD-3-Clause)\n-   [Terms](https://dart.dev/terms \"Terms of use\")\n-   [Privacy](https://policies.google.com/privacy \"Privacy policy\")\n-   [Security](https://dart.dev/security \"Security philosophy and practices\")\n[](https://jaspr.site \"This site is built with the Jaspr web framework for Dart.\")",
  "timestamp": 1769987719519,
  "title": "Asynchronous programming: futures, async, await"
}