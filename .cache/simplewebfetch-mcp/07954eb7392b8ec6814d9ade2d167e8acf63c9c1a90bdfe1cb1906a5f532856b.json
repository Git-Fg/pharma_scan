{
  "url": "https://dart.dev/language/isolates",
  "markdown": "# Isolates\n[Skip to main content](#site-content-title)\ndart.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic.\n[Learn more](https://policies.google.com/technologies/cookies) OK, got it\n [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg) Dart](https://dart.dev/ \"Go to the Dart homepage\")\n-   [Overview](https://dart.dev/overview)\n-   [Docs](https://dart.dev/docs)\n-   [Blog](https://blog.dart.dev)\n-   [Community](https://dart.dev/community)\n-   [Learn](https://dart.dev/learn)\n-   [Try Dart](https://dart.dev/#try-dart)\n-   [Get Dart](https://dart.dev/get-dart)\n[search](https://dart.dev/search \"Navigate to the dart.dev search page.\")\nroutine\n-   light\\_modeLight\n-   dark\\_modeDark\n-   night\\_sight\\_autoAutomatic\napps\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)Dart](https://dart.dev/ \"Navigate to the Dart website.\")\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)DartAPI](https://api.dart.dev \"Navigate to the Dart API website.\")\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)DartBlog](https://blog.dart.dev \"Navigate to the Dart Blog website.\")\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)DartPad](https://dartpad.dev \"Navigate to the DartPad website.\")\n-   [![Dart logo](https://dart.dev/assets/img/logo/dart-192.svg)pub.dev](https://pub.dev \"Navigate to the pub.dev website.\")\nmenu close\n-   [asteriskOverview](https://dart.dev/overview)\n-   [docsDocs](https://dart.dev/docs)\n-   [newsmodeBlog](https://blog.dart.dev)\n-   [publicCommunity](https://dart.dev/community)\n-   [code\\_blocksTry Dart](https://dart.dev)\n-   [downloadGet Dart](https://dart.dev/get-dart)\n-   Languageexpand\\_more\n    -   [\n        Introduction\n        ](https://dart.dev/language)\n    -   [\n        Variables\n        ](https://dart.dev/language/variables)\n    -   [\n        Operators\n        ](https://dart.dev/language/operators)\n    -   [\n        Comments\n        ](https://dart.dev/language/comments)\n    -   [\n        Language versioning\n        ](https://dart.dev/language/versions)\n    -   Typesexpand\\_more\n        -   [\n            Built-in types\n            ](https://dart.dev/language/built-in-types)\n        -   [\n            Records\n            ](https://dart.dev/language/records)\n        -   [\n            Collections\n            ](https://dart.dev/language/collections)\n        -   [\n            Generics\n            ](https://dart.dev/language/generics)\n        -   [\n            Typedefs\n            ](https://dart.dev/language/typedefs)\n        -   [\n            Type system\n            ](https://dart.dev/language/type-system)\n    -   Patternsexpand\\_more\n        -   [\n            Overview & usage\n            ](https://dart.dev/language/patterns)\n        -   [\n            Pattern types\n            ](https://dart.dev/language/pattern-types)\n        -   [\n            Applied tutorialopen\\_in\\_new\n            ](https://codelabs.developers.google.com/codelabs/dart-patterns-records)\n    -   Control flowexpand\\_more\n        -   [\n            Loops\n            ](https://dart.dev/language/loops)\n        -   [\n            Branches\n            ](https://dart.dev/language/branches)\n        -   [\n            Error handling\n            ](https://dart.dev/language/error-handling)\n    -   [\n        Functions\n        ](https://dart.dev/language/functions)\n    -   [\n        Metadata\n        ](https://dart.dev/language/metadata)\n    -   [\n        Libraries & imports\n        ](https://dart.dev/language/libraries)\n    -   Classes & objectsexpand\\_more\n        -   [\n            Classes\n            ](https://dart.dev/language/classes)\n        -   [\n            Constructors\n            ](https://dart.dev/language/constructors)\n        -   [\n            Methods\n            ](https://dart.dev/language/methods)\n        -   [\n            Extend a class\n            ](https://dart.dev/language/extend)\n        -   [\n            Mixins\n            ](https://dart.dev/language/mixins)\n        -   [\n            Enums\n            ](https://dart.dev/language/enums)\n        -   [\n            Dot shorthands\n            ](https://dart.dev/language/dot-shorthands)\n        -   [\n            Extension methods\n            ](https://dart.dev/language/extension-methods)\n        -   [\n            Extension types\n            ](https://dart.dev/language/extension-types)\n        -   [\n            Callable objects\n            ](https://dart.dev/language/callable-objects)\n    -   Class modifiersexpand\\_more\n        -   [\n            Overview & usage\n            ](https://dart.dev/language/class-modifiers)\n        -   [\n            Class modifiers for API maintainers\n            ](https://dart.dev/language/class-modifiers-for-apis)\n        -   [\n            Reference\n            ](https://dart.dev/language/modifier-reference)\n    -   Concurrencyexpand\\_more\n        -   [\n            Overview\n            ](https://dart.dev/language/concurrency)\n        -   [\n            Asynchronous programming\n            ](https://dart.dev/language/async)\n        -   [\n            Isolates\n            ](https://dart.dev/language/isolates)\n    -   Null safetyexpand\\_more\n        -   [\n            Sound null safety\n            ](https://dart.dev/null-safety)\n        -   [\n            Migrating to null safety\n            ](https://dart.dev/null-safety/migration-guide)\n        -   [\n            Understanding null safety\n            ](https://dart.dev/null-safety/understanding-null-safety)\n        -   [\n            Unsound null safety\n            ](https://dart.dev/null-safety/unsound-null-safety)\n        -   [\n            FAQ\n            ](https://dart.dev/null-safety/faq)\n    -   [\n        Keywords\n        ](https://dart.dev/language/keywords)\n-   Core librariesexpand\\_more\n    -   [\n        Overview\n        ](https://dart.dev/libraries)\n    -   [\n        dart:core\n        ](https://dart.dev/libraries/dart-core)\n    -   [\n        dart:async\n        ](https://dart.dev/libraries/dart-async)\n    -   [\n        dart:math\n        ](https://dart.dev/libraries/dart-math)\n    -   [\n        dart:convert\n        ](https://dart.dev/libraries/dart-convert)\n    -   [\n        dart:io\n        ](https://dart.dev/libraries/dart-io)\n    -   [\n        dart:js\\_interop\n        ](https://dart.dev/interop/js-interop)\n    -   [\n        Iterable collections\n        ](https://dart.dev/libraries/collections/iterables)\n    -   Asynchronous programmingexpand\\_more\n        -   [\n            Tutorial\n            ](https://dart.dev/libraries/async/async-await)\n        -   [\n            Futures and error handling\n            ](https://dart.dev/libraries/async/futures-error-handling)\n        -   [\n            Using streams\n            ](https://dart.dev/libraries/async/using-streams)\n        -   [\n            Creating streams\n            ](https://dart.dev/libraries/async/creating-streams)\n-   Effective Dartexpand\\_more\n    -   [\n        Overview\n        ](https://dart.dev/effective-dart)\n    -   [\n        Style\n        ](https://dart.dev/effective-dart/style)\n    -   [\n        Documentation\n        ](https://dart.dev/effective-dart/documentation)\n    -   [\n        Usage\n        ](https://dart.dev/effective-dart/usage)\n    -   [\n        Design\n        ](https://dart.dev/effective-dart/design)\n-   Packagesexpand\\_more\n    -   [\n        How to use packages\n        ](https://dart.dev/tools/pub/packages)\n    -   [\n        Commonly used packages\n        ](https://dart.dev/resources/useful-packages)\n    -   [\n        Creating packages\n        ](https://dart.dev/tools/pub/create-packages)\n    -   [\n        Publishing packages\n        ](https://dart.dev/tools/pub/publishing)\n    -   [\n        Writing package pages\n        ](https://dart.dev/tools/pub/writing-package-pages)\n    -   [\n        Workspaces (monorepo support)\n        ](https://dart.dev/tools/pub/workspaces)\n    -   [\n        Hooks\n        ](https://dart.dev/tools/hooks)\n    -   Package referenceexpand\\_more\n        -   [\n            Dependencies\n            ](https://dart.dev/tools/pub/dependencies)\n        -   [\n            Package layout conventions\n            ](https://dart.dev/tools/pub/package-layout)\n        -   [\n            Pub environment variables\n            ](https://dart.dev/tools/pub/environment-variables)\n        -   [\n            Pubspec file\n            ](https://dart.dev/tools/pub/pubspec)\n        -   [\n            Troubleshooting pub\n            ](https://dart.dev/tools/pub/troubleshoot)\n        -   [\n            Verified publishers\n            ](https://dart.dev/tools/pub/verified-publishers)\n        -   [\n            Security advisories\n            ](https://dart.dev/tools/pub/security-advisories)\n        -   [\n            Versioning\n            ](https://dart.dev/tools/pub/versioning)\n        -   [\n            Custom package repositories\n            ](https://dart.dev/tools/pub/custom-package-repositories)\n    -   [\n        What not to commit\n        ](https://dart.dev/tools/pub/private-files)\n-   Developmentexpand\\_more\n    -   [\n        JSON serialization\n        ](https://dart.dev/libraries/serialization/json)\n    -   [\n        Number representation\n        ](https://dart.dev/resources/language/number-representation)\n    -   [\n        Google APIs\n        ](https://dart.dev/resources/google-apis)\n    -   [\n        Multi-platform apps\n        ](https://dart.dev/multiplatform-apps)\n    -   Command-line & server appsexpand\\_more\n        -   [\n            Overview\n            ](https://dart.dev/server)\n        -   [\n            Get started\n            ](https://dart.dev/tutorials/server/get-started)\n        -   [\n            Write command-line apps\n            ](https://dart.dev/tutorials/server/cmdline)\n        -   [\n            Fetch data from the internet\n            ](https://dart.dev/tutorials/server/fetch-data)\n        -   [\n            Write HTTP servers\n            ](https://dart.dev/tutorials/server/httpserver)\n        -   [\n            Libraries & packages\n            ](https://dart.dev/server/libraries)\n        -   [\n            Google Cloud\n            ](https://dart.dev/server/google-cloud)\n    -   Web appsexpand\\_more\n        -   [\n            Overview\n            ](https://dart.dev/web)\n        -   [\n            Get started\n            ](https://dart.dev/web/get-started)\n        -   [\n            Deployment\n            ](https://dart.dev/web/deployment)\n        -   [\n            Libraries & packages\n            ](https://dart.dev/web/libraries)\n        -   [\n            Wasm compilation\n            ](https://dart.dev/web/wasm)\n    -   [\n        Environment declarations\n        ](https://dart.dev/libraries/core/environment-declarations)\n-   Interoperabilityexpand\\_more\n    -   [\n        C interop\n        ](https://dart.dev/interop/c-interop)\n    -   [\n        Objective-C & Swift interop\n        ](https://dart.dev/interop/objective-c-interop)\n    -   [\n        Java & Kotlin interop\n        ](https://dart.dev/interop/java-interop)\n    -   JavaScript interopexpand\\_more\n        -   [\n            Overview\n            ](https://dart.dev/interop/js-interop)\n        -   [\n            Usage\n            ](https://dart.dev/interop/js-interop/usage)\n        -   [\n            JS types\n            ](https://dart.dev/interop/js-interop/js-types)\n        -   [\n            Tutorials\n            ](https://dart.dev/interop/js-interop/tutorials)\n        -   [\n            Past JS interop\n            ](https://dart.dev/interop/js-interop/past-js-interop)\n        -   [\n            Web interop\n            ](https://dart.dev/interop/js-interop/package-web)\n-   Tools & techniquesexpand\\_more\n    -   [\n        Overview\n        ](https://dart.dev/tools)\n    -   AIexpand\\_more\n        -   [\n            Dart and Flutter MCP Serveropen\\_in\\_new\n            ](https://docs.flutter.dev/ai/mcp-server)\n    -   Editors & debuggersexpand\\_more\n        -   [\n            IntelliJ & Android Studio\n            ](https://dart.dev/tools/jetbrains-plugin)\n        -   [\n            VS Code\n            ](https://dart.dev/tools/vs-code)\n        -   [\n            Troubleshoot analyzer performance\n            ](https://dart.dev/tools/analyzer-performance)\n        -   [\n            Dart DevTools\n            ](https://dart.dev/tools/dart-devtools)\n        -   DartPadexpand\\_more\n            -   [\n                Overview\n                ](https://dart.dev/tools/dartpad)\n            -   [\n                Troubleshooting DartPad\n                ](https://dart.dev/tools/dartpad/troubleshoot)\n    -   Command-line toolsexpand\\_more\n        -   Dart SDKexpand\\_more\n            -   [\n                Overview\n                ](https://dart.dev/tools/sdk)\n            -   [\n                dart\n                ](https://dart.dev/tools/dart-tool)\n            -   [\n                dart analyze\n                ](https://dart.dev/tools/dart-analyze)\n            -   [\n                dart build\n                ](https://dart.dev/tools/dart-build)\n            -   [\n                dart compile\n                ](https://dart.dev/tools/dart-compile)\n            -   [\n                dart create\n                ](https://dart.dev/tools/dart-create)\n            -   [\n                dart doc\n                ](https://dart.dev/tools/dart-doc)\n            -   [\n                dart fix\n                ](https://dart.dev/tools/dart-fix)\n            -   [\n                dart format\n                ](https://dart.dev/tools/dart-format)\n            -   [\n                dart info\n                ](https://dart.dev/tools/dart-info)\n            -   [\n                dart install\n                ](https://dart.dev/tools/dart-install)\n            -   [\n                dart pub\n                ](https://dart.dev/tools/pub/cmd)\n            -   [\n                dart run\n                ](https://dart.dev/tools/dart-run)\n            -   [\n                dart test\n                ](https://dart.dev/tools/dart-test)\n            -   [\n                dartaotruntime\n                ](https://dart.dev/tools/dartaotruntime)\n            -   [\n                Experiment flags\n                ](https://dart.dev/tools/experiment-flags)\n        -   Other command-line toolsexpand\\_more\n            -   [\n                build\\_runner\n                ](https://dart.dev/tools/build_runner)\n            -   [\n                webdev\n                ](https://dart.dev/tools/webdev)\n    -   Static analysisexpand\\_more\n        -   [\n            Customizing static analysis\n            ](https://dart.dev/tools/analysis)\n        -   [\n            Fixing type promotion failures\n            ](https://dart.dev/tools/non-promotion-reasons)\n        -   [\n            Linter rules\n            ](https://dart.dev/tools/linter-rules)\n        -   [\n            Analyzer plugins\n            ](https://dart.dev/tools/analyzer-plugins)\n        -   [\n            Diagnostic messages\n            ](https://dart.dev/tools/diagnostics)\n    -   Testing & optimizationexpand\\_more\n        -   [\n            Testing\n            ](https://dart.dev/tools/testing)\n        -   [\n            Debugging web apps\n            ](https://dart.dev/web/debugging)\n-   Learn Dartexpand\\_more\n    -   [\n        Overview\n        ](https://dart.dev/learn)\n    -   [\n        Tutorial\n        ](https://dart.dev/learn/tutorial)\n-   Stay up to dateexpand\\_more\n    -   [\n        Dart Blogopen\\_in\\_new\n        ](https://blog.dart.dev)\n    -   [\n        Changelog\n        ](https://dart.dev/changelog)\n    -   [\n        What's new in the docs\n        ](https://dart.dev/resources/whats-new)\n-   Resourcesexpand\\_more\n    -   [\n        Language cheatsheet\n        ](https://dart.dev/resources/dart-cheatsheet)\n    -   [\n        Language specification\n        ](https://dart.dev/resources/language/spec)\n    -   [\n        Dart 3 migration guide\n        ](https://dart.dev/resources/dart-3-migration)\n    -   [\n        From JavaScript to Dart\n        ](https://dart.dev/resources/coming-from/js-to-dart)\n    -   [\n        From Swift to Dart\n        ](https://dart.dev/resources/coming-from/swift-to-dart)\n    -   [\n        FAQ\n        ](https://dart.dev/resources/faq)\n    -   [\n        Glossary\n        ](https://dart.dev/resources/glossary)\n    -   [\n        Books\n        ](https://dart.dev/resources/books)\n    -   [\n        Videos\n        ](https://dart.dev/resources/videos)\n    -   [\n        Tutorials\n        ](https://dart.dev/tutorials)\n-   Related sitesexpand\\_more\n    -   [\n        API referenceopen\\_in\\_new\n        ](https://api.dart.dev)\n    -   [\n        DartPad (online editor)open\\_in\\_new\n        ](https://dartpad.dev)\n    -   [\n        Flutteropen\\_in\\_new\n        ](https://flutter.dev)\n    -   [\n        Package siteopen\\_in\\_new\n        ](https://pub.dev)\nlistOn this page chevron\\_rightIsolates\n[vertical\\_align\\_top Isolates](#site-content-title)\n-   [Implementing a simple worker isolate](#implementing-a-simple-worker-isolate)\n    -   [Running an existing method in a new isolate](#running-an-existing-method-in-a-new-isolate)\n    -   [Sending closures with isolates](#sending-closures-with-isolates)\n-   [Sending multiple messages between isolates with ports](#sending-multiple-messages-between-isolates-with-ports)\n    -   [ReceivePort and SendPort](#receiveport-and-sendport)\n    -   [Basic ports example](#basic-ports-example)\n    -   [Robust ports example](#robust-ports-example)\nDart 3.10 is taking off with dot shorthands, stable build hooks, nuanced deprecation annotations, and more! [Learn more](https://blog.dart.dev/announcing-dart-3-10-ea8b952b6088)\nlist On this page\n-   [Implementing a simple worker isolate](#implementing-a-simple-worker-isolate)\n    -   [Running an existing method in a new isolate](#running-an-existing-method-in-a-new-isolate)\n    -   [Sending closures with isolates](#sending-closures-with-isolates)\n-   [Sending multiple messages between isolates with ports](#sending-multiple-messages-between-isolates-with-ports)\n    -   [ReceivePort and SendPort](#receiveport-and-sendport)\n    -   [Basic ports example](#basic-ports-example)\n    -   [Robust ports example](#robust-ports-example)\n1.  [Language](https://dart.dev/language)chevron\\_right\n2.  [Isolates](https://dart.dev/language/isolates)\n# Isolates\nInformation on writing isolates in Dart.\nmore\\_vert\n-   copyCopy link\n-   [docsView source](https://github.com/dart-lang/site-www/blob/main/src/content/language/isolates.md)\n-   [bug\\_reportReport issue](https://github.com/dart-lang/site-www/issues/new?template=1_page_issue.yml&page-url=https://dart.dev/language/isolates&page-source=https://github.com/dart-lang/site-www/blob/main/src/content/language/isolates.md)\nThis page discusses some examples that use the `Isolate` API to implement isolates.\nYou should use isolates whenever your application is handling computations that are large enough to temporarily block other computations. The most common example is in [Flutter](https://docs.flutter.dev/perf/isolates) applications, when you need to perform large computations that might otherwise cause the UI to become unresponsive.\nflutter Flutter note\nMultiple Isolates not supported by Flutter web See also: [Concurrency on the web](https://dart.dev/language/concurrency#concurrency-on-the-web)\nThere aren't any rules about when you _must_ use isolates, but here are some more situations where they can be useful:\n-   Parsing and decoding exceptionally large JSON blobs.\n-   Processing and compressing photos, audio and video.\n-   Converting audio and video files.\n-   Performing complex searching and filtering on large lists or within file systems.\n-   Performing I/O, such as communicating with a database.\n-   Handling a large volume of network requests.\n## Implementing a simple worker isolate\n[#](#implementing-a-simple-worker-isolate)\nThese examples implement a main isolate that spawns a simple worker isolate. [`Isolate.run()`](https://api.dart.dev/dart-isolate/Isolate/run.html) simplifies the steps behind setting up and managing worker isolates:\n1.  Spawns (starts and creates) an isolate.\n2.  Runs a function on the spawned isolate.\n3.  Captures the result.\n4.  Returns the result to the main isolate.\n5.  Terminates the isolate once work is complete.\n6.  Checks, captures, and throws exceptions and errors back to the main isolate.\nflutter Flutter note\nIf you're using Flutter, you can use [Flutter's `compute` function](https://api.flutter.dev/flutter/foundation/compute.html) instead of `Isolate.run()`.\n### Running an existing method in a new isolate\n[#](#running-an-existing-method-in-a-new-isolate)\n1.  Call `run()` to spawn a new isolate (a [background worker](https://dart.dev/language/concurrency#background-workers)), directly in the [main isolate](https://dart.dev/language/concurrency#the-main-isolate) while `main()` waits for the result:\ndart\n```\nconst String filename = 'with_keys.json';\n​\nvoid main() async {\n  // Read some data.\n  final jsonData = await Isolate.run(_readAndParseJson);\n​\n  // Use that data.\n  print('Number of JSON keys: ${jsonData.length}');\n}\n```\ncontent\\_copy\n2.  Pass the worker isolate the function you want it to execute as its first argument. In this example, it's the existing function `_readAndParseJson()`:\ndart\n```\nFuture<Map<String, dynamic>> _readAndParseJson() async {\n  final fileData = await File(filename).readAsString();\n  final jsonData = jsonDecode(fileData) as Map<String, dynamic>;\n  return jsonData;\n}\n```\ncontent\\_copy\n3.  `Isolate.run()` takes the result `_readAndParseJson()` returns and sends the value back to the main isolate, shutting down the worker isolate.\n4.  The worker isolate _transfers_ the memory holding the result to the main isolate. It _does not copy_ the data. The worker isolate performs a verification pass to ensure the objects are allowed to be transferred.\n`_readAndParseJson()` is an existing, asynchronous function that could just as easily run directly in the main isolate. Using `Isolate.run()` to run it instead enables concurrency. The worker isolate completely abstracts the computations of `_readAndParseJson()`. It can complete without blocking the main isolate.\nThe result of `Isolate.run()` is always a Future, because code in the main isolate continues to run. Whether the computation the worker isolate executes is synchronous or asynchronous doesn't impact the main isolate, because it's running concurrently either way.\nFor the complete program, check out the [send\\_and\\_receive.dart](https://github.com/dart-lang/samples/blob/main/isolates/bin/send_and_receive.dart) sample.\n### Sending closures with isolates\n[#](#sending-closures-with-isolates)\nYou can also create a simple worker isolate with `run()` using a function literal, or closure, directly in the main isolate.\ndart\n```\nconst String filename = 'with_keys.json';\n​\nvoid main() async {\n  // Read some data.\n  final jsonData = await Isolate.run(() async {\n    final fileData = await File(filename).readAsString();\n    final jsonData = jsonDecode(fileData) as Map<String, dynamic>;\n    return jsonData;\n  });\n​\n  // Use that data.\n  print('Number of JSON keys: ${jsonData.length}');\n}\n```\ncontent\\_copy\nThis example accomplishes the same as the previous. A new isolate spawns, computes something, and sends back the result.\nHowever, now the isolate sends a [closure](https://dart.dev/language/functions#anonymous-functions). Closures are less limited than typical named functions, both in how they function and how they're written into the code. In this example, `Isolate.run()` executes what looks like local code, concurrently. In that sense, you can imagine `run()` to work like a control flow operator for \"run in parallel\".\n## Sending multiple messages between isolates with ports\n[#](#sending-multiple-messages-between-isolates-with-ports)\nShort-lived isolates are convenient to use, but require performance overhead to spawn new isolates and to copy objects from one isolate to another. If your code relies on repeatedly running the same computation using `Isolate.run`, you might improve performance by instead creating long-lived isolates that don’t exit immediately.\nTo do this, you can use some of the low-level isolate APIs that `Isolate.run` abstracts:\n-   [`Isolate.spawn()`](https://api.dart.dev/dart-isolate/Isolate/spawn.html) and [`Isolate.exit()`](https://api.dart.dev/dart-isolate/Isolate/exit.html)\n-   [`ReceivePort`](https://api.dart.dev/dart-isolate/ReceivePort-class.html) and [`SendPort`](https://api.dart.dev/dart-isolate/SendPort-class.html)\n-   [`SendPort.send()` method](https://api.dart.dev/dart-isolate/SendPort/send.html)\nThis section goes over the steps required to establish 2-way communication between a newly spawned isolate and the [main isolate](https://dart.dev/language/concurrency#the-main-isolate). The first example, [Basic ports](#basic-ports-example), introduces the process at a high-level. The second example, [Robust ports](#robust-ports-example), gradually adds more practical, real-world functionality to the first.\n### `ReceivePort` and `SendPort`\n[#](#receiveport-and-sendport)\nSetting up long-lived communication between isolates requires two classes (in addition to `Isolate`): `ReceivePort` and `SendPort`. These ports are the only way isolates can communicate with each other.\nA `ReceivePort` is an object that handles messages that are sent from other isolates. Those messages are sent via a `SendPort`.\ninfoNote\nA `SendPort` object is associated with exactly one `ReceivePort`, but a single `ReceivePort` can have many `SendPorts`. When you create a `ReceivePort`, it creates a `SendPort` for itself. You can create additional `SendPorts` that can send messages to an existing `ReceivePort`.\nPorts behave similarly to [`Stream`](https://api.dart.dev/dart-async/Stream-class.html) objects (in fact, receive ports implement `Stream`!) You can think of a `SendPort` and `ReceivePort` like Stream's `StreamController` and listeners, respectively. A `SendPort` is like a `StreamController` because you \"add\" messages to them with the [`SendPort.send()` method](https://api.dart.dev/dart-isolate/SendPort/send.html), and those messages are handled by a listener, in this case the `ReceivePort`. The `ReceivePort` then handles the messages it receives by passing them as arguments to a callback that you provide.\n#### Setting up ports\n[#](#setting-up-ports)\nA newly spawned isolate only has the information it receives through the `Isolate.spawn` call. If you need the main isolate to continue to communicate with a spawned isolate past its initial creation, you must set up a communication channel where the spawned isolate can send messages to the main isolate. Isolates can only communicate via message passing. They can’t “see” inside each others’ memory, which is where the name “isolate” comes from.\nTo set up this 2-way communication, first create a [`ReceivePort`](https://api.dart.dev/dart-isolate/ReceivePort-class.html) in the main isolate, then pass its [`SendPort`](https://api.dart.dev/dart-isolate/SendPort-class.html) as an argument to the new isolate when spawning it with `Isolate.spawn`. The new isolate then creates its own `ReceivePort`, and sends _its_ `SendPort` back on the `SendPort` it was passed by the main isolate. The main isolate receives this `SendPort`, and now both sides have an open channel to send and receive messages.\ninfoNote\nThe diagrams in this section are high-level and intended to convey the _concept_ of using ports for isolates. Actual implementation requires a bit more code, which you will find [later on this page](#basic-ports-example).\n![A figure showing events being fed, one by one, into the event loop](https://dart.dev/assets/img/language/concurrency/ports-setup.png)\n1.  Create a `ReceivePort` in the main isolate. The `SendPort` is created automatically as a property on the `ReceivePort`.\n2.  Spawn the worker isolate with `Isolate.spawn()`\n3.  Pass a reference to `ReceivePort.sendPort` as the first message to the worker isolate.\n4.  Create another new `ReceivePort` in the worker isolate.\n5.  Pass a reference to the worker isolate's `ReceivePort.sendPort` as the first message _back_ to the main isolate.\nAlong with creating the ports and setting up communication, you’ll also need to tell the ports what to do when they receive messages. This is done using the `listen` method on each respective `ReceivePort`.\n![A figure showing events being fed, one by one, into the event loop](https://dart.dev/assets/img/language/concurrency/ports-passing-messages.png)\n1.  Send a message via the main isolate’s reference to the worker isolate's `SendPort`.\n2.  Receive and handle the message via a listener on the worker isolate's `ReceivePort`. This is where the computation you want to move off the main isolate is executed.\n3.  Send a return message via the worker isolate's reference to the main isolate's `SendPort`.\n4.  Receive the message via a listener on the main isolate's `ReceivePort`.\n### Basic ports example\n[#](#basic-ports-example)\nThis example demonstrates how you can set up a long-lived worker isolate with 2-way communication between it and the main isolate. The code uses the example of sending JSON text to a new isolate, where the JSON will be parsed and decoded, before being sent back to the main isolate.\nwarningWarning\nThis example is meant to teach the _bare minimum_ needed to spawn a new isolate that can send and receive multiple messages over time.\nIt does not cover important pieces of functionality that are expected in production software, like error handling, shutting down ports, and message sequencing.\nThe [Robust ports example](#robust-ports-example) in the next section covers this functionality and discusses some of the issues that can arise without it.\n#### Step 1: Define the worker class\n[#](#step-1-define-the-worker-class)\nFirst, create a class for your background worker isolate. This class contains all the functionality you need to:\n-   Spawn an isolate.\n-   Send messages to that isolate.\n-   Have the isolate decode some JSON.\n-   Send the decoded JSON back to the main isolate.\nThe class exposes two public methods: one that spawns the worker isolate, and one that handles sending messages to that worker isolate.\nThe remaining sections in this example will show you how to fill in the class methods, one-by-one.\ndart\n```\nclass Worker {\n  Future<void> spawn() async {\n    // TODO: Add functionality to spawn a worker isolate.\n  }\n​\n  void _handleResponsesFromIsolate(dynamic message) {\n    // TODO: Handle messages sent back from the worker isolate.\n  }\n​\n  static void _startRemoteIsolate(SendPort port) {\n    // TODO: Define code that should be executed on the worker isolate.\n  }\n​\n  Future<void> parseJson(String message) async {\n    // TODO: Define a public method that can\n    // be used to send messages to the worker isolate.\n  }\n}\n```\ncontent\\_copy\n#### Step 2: Spawn a worker isolate\n[#](#step-2-spawn-a-worker-isolate)\nThe `Worker.spawn` method is where you will group the code for creating the worker isolate and ensuring it can receive and send messages.\n-   First, create a `ReceivePort`. This allows the main isolate to receive messages sent from the newly spawned worker isolate.\n-   Next, add a listener to the receive port to handle messages the worker isolate will send back. The callback passed to the listener, `_handleResponsesFromIsolate`, will be covered in [step 4](#step-4-handle-messages-on-the-main-isolate).\n-   Finally, spawn the worker isolate with `Isolate.spawn`. It expects two arguments: a function to be executed on the worker isolate (covered in [step 3](#step-3-execute-code-on-the-worker-isolate)), and the `sendPort` property of the receive port.\ndart\n```\nFuture<void> spawn() async {\n  final receivePort = ReceivePort();\n  receivePort.listen(_handleResponsesFromIsolate);\n  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);\n}\n```\ncontent\\_copy\nThe `receivePort.sendPort` argument will be passed to the callback (`_startRemoteIsolate`) as an argument when it’s called on the worker isolate. This is the first step in ensuring that the worker isolate has a way to send messages back to the main isolate.\n#### Step 3: Execute code on the worker isolate\n[#](#step-3-execute-code-on-the-worker-isolate)\nIn this step, you define the method `_startRemoteIsolate` that is sent to the worker isolate to be executed when it spawns. This method is like the “main” method for the worker isolate.\n-   First, create another new `ReceivePort`. This port receives future messages from the main isolate.\n-   Next, send that port’s `SendPort` back to the main isolate.\n-   Finally, add a listener to the new `ReceivePort`. This listener handles messages the main isolate sends to the worker isolate.\ndart\n```\nstatic void _startRemoteIsolate(SendPort port) {\n  final receivePort = ReceivePort();\n  port.send(receivePort.sendPort);\n​\n  receivePort.listen((dynamic message) async {\n    if (message is String) {\n      final transformed = jsonDecode(message);\n      port.send(transformed);\n    }\n  });\n}\n```\ncontent\\_copy\nThe listener on the worker’s `ReceivePort` decodes the JSON passed from the main isolate, and then sends the decoded JSON back to the main isolate.\nThis listener is the entry point for messages sent from the main isolate to the worker isolate. **This is the only chance you have to tell the worker isolate what code to execute in the future.**\n#### Step 4: Handle messages on the main isolate\n[#](#step-4-handle-messages-on-the-main-isolate)\nFinally, you need to tell the main isolate how to handle messages sent from the worker isolate back to the main isolate. To do so, you need to fill in the `_handleResponsesFromIsolate` method. Recall that this method is passed to the `receivePort.listen` method, as described in [step 2](#step-2-spawn-a-worker-isolate):\ndart\n```\nFuture<void> spawn() async {\n  final receivePort = ReceivePort();\n  receivePort.listen(_handleResponsesFromIsolate);\n  await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);\n}\n```\ncontent\\_copy\nAlso recall that you sent a `SendPort` back to the main isolate in [step 3](#step-3-execute-code-on-the-worker-isolate). This method handles the receipt of that `SendPort`, as well as handling future messages (which will be decoded JSON).\n-   First, check if the message is a `SendPort`. If so, assign that port to the class's `_sendPort` property so it can be used to send messages later.\n-   Next, check if the message is of type `Map<String, dynamic>`, the expected type of decoded JSON. If so, handle that message with your application-specific logic. In this example, the message is printed.\ndart\n```\nvoid _handleResponsesFromIsolate(dynamic message) {\n  if (message is SendPort) {\n    _sendPort = message;\n    _isolateReady.complete();\n  } else if (message is Map<String, dynamic>) {\n    print(message);\n  }\n}\n```\ncontent\\_copy\n#### Step 5: Add a completer to ensure your isolate is set-up\n[#](#step-5-add-a-completer-to-ensure-your-isolate-is-set-up)\nTo complete the class, define a public method called `parseJson`, which is responsible for sending messages to the worker isolate. It also needs to ensure that messages can be sent before the isolate is fully set up. To handle this, use a [`Completer`](https://api.dart.dev/dart-async/Completer-class.html).\n-   First, add a class-level property called a `Completer` and name it `_isolateReady`.\n-   Next, add a call to `complete()` on the completer in the `_handleResponsesFromIsolate` method (created in [step 4](#step-4-handle-messages-on-the-main-isolate)) if the message is a `SendPort`.\n-   Finally, in the `parseJson` method, add `await _isolateReady.future` before adding `_sendPort.send`. This ensures that no message can be sent to the worker isolate until it is spawned _and_ has sent its `SendPort` back to the main isolate.\ndart\n```\nFuture<void> parseJson(String message) async {\n  await _isolateReady.future;\n  _sendPort.send(message);\n}\n```\ncontent\\_copy\n#### Complete example\n[#](#complete-example)\nExpand to see the complete example\ndart\n```\nimport 'dart:async';\nimport 'dart:convert';\nimport 'dart:isolate';\n​\nvoid main() async {\n  final worker = Worker();\n  await worker.spawn();\n  await worker.parseJson('{\"key\":\"value\"}');\n}\n​\nclass Worker {\n  late SendPort _sendPort;\n  final Completer<void> _isolateReady = Completer.sync();\n​\n  Future<void> spawn() async {\n    final receivePort = ReceivePort();\n    receivePort.listen(_handleResponsesFromIsolate);\n    await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort);\n  }\n​\n  void _handleResponsesFromIsolate(dynamic message) {\n    if (message is SendPort) {\n      _sendPort = message;\n      _isolateReady.complete();\n    } else if (message is Map<String, dynamic>) {\n      print(message);\n    }\n  }\n​\n  static void _startRemoteIsolate(SendPort port) {\n    final receivePort = ReceivePort();\n    port.send(receivePort.sendPort);\n​\n    receivePort.listen((dynamic message) async {\n      if (message is String) {\n        final transformed = jsonDecode(message);\n        port.send(transformed);\n      }\n    });\n  }\n​\n  Future<void> parseJson(String message) async {\n    await _isolateReady.future;\n    _sendPort.send(message);\n  }\n​\n}\n```\ncontent\\_copy\n### Robust ports example\n[#](#robust-ports-example)\nThe [previous example](#basic-ports-example) explained the basic building blocks needed to set up a long-lived isolate with two-way communication. As mentioned, that example lacks some important features, such as error handling, the ability to close the ports when they’re no longer in use, and inconsistencies around message ordering in some situations.\nThis example expands on the information in the first example by creating a long-lived worker isolate that has these additional features and more, and follows better design patterns. Although this code has similarities to the first example, it is not an extension of that example.\ninfoNote\nThis example assumes that you are already familiar with establishing communication between isolates with `Isolate.spawn` and ports, which was covered in the [previous example](#basic-ports-example).\n#### Step 1: Define the worker class\n[#](#step-1-define-the-worker-class)\nFirst, create a class for your background worker isolate. This class contains all the functionality you need to:\n-   Spawn an isolate.\n-   Send messages to that isolate.\n-   Have the isolate decode some JSON.\n-   Send the decoded JSON back to the main isolate.\nThe class exposes three public methods: one that creates the worker isolate, one that handles sending messages to that worker isolate, and one that can shut down the ports when they’re no longer in use.\ndart\n```\nclass Worker {\n  final SendPort _commands;\n  final ReceivePort _responses;\n​\n  Future<Object?> parseJson(String message) async {\n    // TODO: Ensure the port is still open.\n    _commands.send(message);\n  }\n​\n  static Future<Worker> spawn() async {\n    // TODO: Add functionality to create a new Worker object with a\n    //  connection to a spawned isolate.\n    throw UnimplementedError();\n  }\n​\n  Worker._(this._responses, this._commands) {\n    // TODO: Initialize main isolate receive port listener.\n  }\n​\n  void _handleResponsesFromIsolate(dynamic message) {\n    // TODO: Handle messages sent back from the worker isolate.\n  }\n​\n  static void _handleCommandsToIsolate(ReceivePort rp, SendPort sp) async {\n    // TODO: Handle messages sent back from the worker isolate.\n  }\n​\n  static void _startRemoteIsolate(SendPort sp) {\n    // TODO: Initialize worker isolate's ports.\n  }\n}\n```\ncontent\\_copy\ninfoNote\nIn this example, `SendPort` and `ReceivePort` instances follow a best practice naming convention, in which they are named in relation to the main isolate. The messages sent through the `SendPort` from the main isolate to the worker isolate are called _commands_, and the messages sent back to the main isolate are called _responses_.\n#### Step 2: Create a `RawReceivePort` in the `Worker.spawn` method\n[#](#step-2-create-a-rawreceiveport-in-the-worker-spawn-method)\nBefore spawning an isolate, you need to create a [`RawReceivePort`](https://api.dart.dev/dart-isolate/RawReceivePort-class.html), which is a lower-level `ReceivePort`. Using `RawReceivePort` is a preferred pattern because it allows you to separate your isolate startup logic from logic that handles message passing on the isolate.\nIn the `Worker.spawn` method:\n-   First, create the `RawReceivePort`. This `ReceivePort` is only responsible for receiving the initial message from the worker isolate, which will be a `SendPort`.\n-   Next, create a `Completer` that will indicate when the isolate is ready to receive messages. When this completes, it will return a record with a `ReceivePort` and a `SendPort`.\n-   Next, define the `RawReceivePort.handler` property. This property is a `Function?` that behaves like `ReceivePort.listener`. The function is called when a message is received by this port.\n-   Within the handler function, call `connection.complete()`. This method expects a [record](https://dart.dev/language/records) with a `ReceivePort` and a `SendPort` as an argument. The `SendPort` is the initial message sent from the worker isolate, which will be assigned in the next step to the class level `SendPort` named `_commands`.\n-   Then, create a new `ReceivePort` with the `ReceivePort.fromRawReceivePort` constructor, and pass in the `initPort`.\ndart\n```\nclass Worker {\n  final SendPort _commands;\n  final ReceivePort _responses;\n​\n  static Future<Worker> spawn() async {\n    // Create a receive port and add its initial message handler.\n    final initPort = RawReceivePort();\n    final connection = Completer<(ReceivePort, SendPort)>.sync();\n    initPort.handler = (initialMessage) {\n      final commandPort = initialMessage as SendPort;\n      connection.complete((\n        ReceivePort.fromRawReceivePort(initPort),\n        commandPort,\n      ));\n    };\n  }\n}\n```\ncontent\\_copy\nBy creating a `RawReceivePort` first, and then a `ReceivePort`, you’ll be able to add a new callback to `ReceivePort.listen` later on. Conversely, if you were to create a `ReceivePort` straight away, you’d only be able to add one `listener`, because `ReceivePort` implements [`Stream`](https://api.dart.dev/dart-async/Stream-class.html), rather than [`BroadcastStream`](https://api.dart.dev/dart-async/BroadcastStream-class.html).\nEffectively, this allows you to separate your isolate start-up logic from the logic that handles receiving messages after setting up communication is complete. This benefit will become more obvious as the logic in the other methods grows.\n#### Step 3: Spawn a worker isolate with `Isolate.spawn`\n[#](#step-3-spawn-a-worker-isolate-with-isolate-spawn)\nThis step continues to fill in the `Worker.spawn` method. You’ll add the code needed to spawn an isolate, and return an instance of `Worker` from this class. In this example, the call to `Isolate.spawn` is wrapped in a [`try`/`catch` block](https://dart.dev/language/error-handling#catch), which ensures that, if the isolate fails to start up, the `initPort` will be closed, and the `Worker` object won’t be created.\n-   First, attempt to spawn a worker isolate in a `try`/`catch` block. If spawning a worker isolate fails, close the receive port that was created in the previous step. The method passed to `Isolate.spawn` will be covered in a later step.\n-   Next, await the `connection.future`, and destructure the send port and receive port from the record it returns.\n-   Finally, return an instance of `Worker` by calling its private constructor, and passing in the ports from that completer.\ndart\n```\nclass Worker {\n  final SendPort _commands;\n  final ReceivePort _responses;\n​\n  static Future<Worker> spawn() async {\n    // Create a receive port and add its initial message handler.\n    final initPort = RawReceivePort();\n    final connection = Completer<(ReceivePort, SendPort)>.sync();\n    initPort.handler = (initialMessage) {\n      final commandPort = initialMessage as SendPort;\n      connection.complete((\n        ReceivePort.fromRawReceivePort(initPort),\n        commandPort,\n      ));\n    };\n    // Spawn the isolate.\n    try {\n      await Isolate.spawn(_startRemoteIsolate, (initPort.sendPort));\n    } on Object {\n      initPort.close();\n      rethrow;\n    }\n​\n    final (ReceivePort receivePort, SendPort sendPort) =\n        await connection.future;\n​\n    return Worker._(receivePort, sendPort);\n  }\n}\n```\ncontent\\_copy\nNote that in this example (compared to the [previous example](#basic-ports-example)), `Worker.spawn` acts as an asynchronous static constructor for this class and is the only way to create an instance of `Worker`. This simplifies the API, making the code that creates an instance of `Worker` cleaner.\n#### Step 4: Complete the isolate setup process\n[#](#step-4-complete-the-isolate-setup-process)\nIn this step, you will complete the basic isolate setup process. This correlates almost entirely to the [previous example](#basic-ports-example), and there are no new concepts. There is a slight change in that the code is broken into more methods, which is a design practice that sets you up for adding more functionality through the remainder of this example. For an in-depth walkthrough of the basic process of setting up an isolate, see the [basic ports example](#basic-ports-example).\nFirst, create the private constructor that is returned from the `Worker.spawn` method. In the constructor body, add a listener to the receive port used by the main isolate, and pass an as-yet undefined method to that listener called `_handleResponsesFromIsolate`.\ndart\n```\nclass Worker {\n  final SendPort _commands;\n  final ReceivePort _responses;\n​\n  Worker._(this._responses, this._commands) {\n    _responses.listen(_handleResponsesFromIsolate);\n  }\n}\n```\ncontent\\_copy\nNext, add the code to `_startRemoteIsolate` that is responsible for initializing the ports on the worker isolate. [Recall](#step-3-spawn-a-worker-isolate-with-isolate-spawn) that this method was passed to `Isolate.spawn` in the `Worker.spawn` method, and it will be passed the main isolate’s `SendPort` as an argument.\n-   Create a new `ReceivePort`.\n-   Send that port’s `SendPort` back to the main isolate.\n-   Call a new method called `_handleCommandsToIsolate`, and pass both the new `ReceivePort` and `SendPort` from the main isolate as arguments.\ndart\n```\nstatic void _startRemoteIsolate(SendPort sendPort) {\n  final receivePort = ReceivePort();\n  sendPort.send(receivePort.sendPort);\n  _handleCommandsToIsolate(receivePort, sendPort);\n}\n```\ncontent\\_copy\nNext, add the `_handleCommandsToIsolate` method, which is responsible for receiving messages from the main isolate, decoding json on the worker isolate, and sending the decoded json back as a response.\n-   First, declare a listener on the worker isolate’s `ReceivePort`.\n-   Within the callback added to the listener, attempt to decode the JSON passed from the main isolate within a [`try`/`catch` block](https://dart.dev/language/error-handling#catch). If decoding is successful, send the decoded JSON back to the main isolate.\n-   If there is an error, send back a [`RemoteError`](https://api.dart.dev/dart-isolate/RemoteError-class.html).\ndart\n```\nstatic void _handleCommandsToIsolate(\n  ReceivePort receivePort,\n  SendPort sendPort,\n) {\n  receivePort.listen((message) {\n    try {\n      final jsonData = jsonDecode(message as String);\n      sendPort.send(jsonData);\n    } catch (e) {\n      sendPort.send(RemoteError(e.toString(), ''));\n    }\n  });\n}\n```\ncontent\\_copy\nNext, add the code for the `_handleResponsesFromIsolate` method.\n-   First, check if the message is a `RemoteError`, in which case you should `throw` that error.\n-   Otherwise, print the message. In future steps, you will update this code to return messages rather than print them.\ndart\n```\nvoid _handleResponsesFromIsolate(dynamic message) {\n  if (message is RemoteError) {\n    throw message;\n  } else {\n    print(message);\n  }\n}\n```\ncontent\\_copy\nFinally, add the `parseJson` method, which is a public method that allows outside code to send JSON to the worker isolate to be decoded.\ndart\n```\nFuture<Object?> parseJson(String message) async {\n  _commands.send(message);\n}\n```\ncontent\\_copy\nYou will update this method in the next step.\n#### Step 5: Handle multiple messages at the same time\n[#](#step-5-handle-multiple-messages-at-the-same-time)\nCurrently, if you rapidly send messages to the worker isolate, the isolate will send the decoded json response in _the order that they complete_, rather than the order that they’re sent. You have no way to determine which response corresponds to which message.\nIn this step, you’ll fix this problem by giving each message an id, and using `Completer` objects to ensure that when outside code calls `parseJson` the response that is returned to that caller is the correct response.\nFirst, add two class-level properties to `Worker`:\n-   `Map<int, Completer<Object?>> _activeRequests`\n-   `int _idCounter`\ndart\n```\nclass Worker {\n  final SendPort _commands;\n  final ReceivePort _responses;\n  final Map<int, Completer<Object?>> _activeRequests = {};\n  int _idCounter = 0;\n  // ···\n}\n```\ncontent\\_copy\nThe `_activeRequests` map associates a message sent to the worker isolate with a `Completer`. The keys used in `_activeRequests` are taken from `_idCounter`, which will be increased as more messages are sent.\nNext, update the `parseJson` method to create completers before it sends messages to the worker isolate.\n-   First create a `Completer`.\n-   Next, increment `_idCounter`, so that each `Completer` is associated with a unique number.\n-   Add an entry to the `_activeRequests` map in which the key is the current number of `_idCounter`, and the completer is the value.\n-   Send the message to the worker isolate, along with the id. Because you can only send one value through the `SendPort`, wrap the id and message in a [record](https://dart.dev/language/records).\n-   Finally, return the completer’s future, which will eventually contain the response from the worker isolate.\ndart\n```\nFuture<Object?> parseJson(String message) async {\n  final completer = Completer<Object?>.sync();\n  final id = _idCounter++;\n  _activeRequests[id] = completer;\n  _commands.send((id, message));\n  return await completer.future;\n}\n```\ncontent\\_copy\nYou also need to update `_handleResponsesFromIsolate` and `_handleCommandsToIsolate` to handle this system.\nIn `_handleCommandsToIsolate`, you need to account for the `message` being a record with two values, rather than just the json text. Do so by destructuring the values from `message`.\nThen, after decoding the json, update the call to `sendPort.send` to pass both the id and the decoded json back to the main isolate, again using a record.\ndart\n```\nstatic void _handleCommandsToIsolate(\n  ReceivePort receivePort,\n  SendPort sendPort,\n) {\n  receivePort.listen((message) {\n    final (int id, String jsonText) = message as (int, String); // New\n    try {\n      final jsonData = jsonDecode(jsonText);\n      sendPort.send((id, jsonData)); // Updated\n    } catch (e) {\n      sendPort.send((id, RemoteError(e.toString(), '')));\n    }\n  });\n}\n```\ncontent\\_copy\nFinally, update the `_handleResponsesFromIsolate`.\n-   First, destructure the id and the response from the message argument again.\n-   Then, remove the completer that corresponds to this request from the `_activeRequests` map.\n-   Lastly, rather than throwing an error or printing the decoded json, complete the completer, passing in the response. When this completes, the response will be returned to the code that called `parseJson` on the main isolate.\ndart\n```\nvoid _handleResponsesFromIsolate(dynamic message) {\n  final (int id, Object? response) = message as (int, Object?); // New\n  final completer = _activeRequests.remove(id)!; // New\n​\n  if (response is RemoteError) {\n    completer.completeError(response); // Updated\n  } else {\n    completer.complete(response); // Updated\n  }\n}\n```\ncontent\\_copy\n#### Step 6: Add functionality to close the ports\n[#](#step-6-add-functionality-to-close-the-ports)\nWhen the isolate is no longer being used by your code, you should close the ports on the main isolate and the worker isolate.\n-   First, add a class-level boolean that tracks if the ports are closed.\n-   Then, add the `Worker.close` method. Within this method:\n    -   Update `_closed` to be true.\n    -   Send a final message to the worker isolate. This message is a `String` that reads “shutdown”, but it could be any object you’d like. You will use it in the next code snippet.\n-   Finally, check if `_activeRequests` is empty. If it is, close down the main isolate’s `ReceivePort` named `_responses`.\ndart\n```\nclass Worker {\n  bool _closed = false;\n  // ···\n  void close() {\n    if (!_closed) {\n      _closed = true;\n      _commands.send('shutdown');\n      if (_activeRequests.isEmpty) _responses.close();\n      print('--- port closed --- ');\n    }\n  }\n}\n```\ncontent\\_copy\n-   Next, you need to handle the “shutdown” message in the worker isolate. Add the following code to the `_handleCommandsToIsolate` method. This code will check if the message is a `String` that reads “shutdown”. If it is, it will close the worker isolate’s `ReceivePort`, and return.\ndart\n```\nstatic void _handleCommandsToIsolate(\n  ReceivePort receivePort,\n  SendPort sendPort,\n) {\n  receivePort.listen((message) {\n    // New if-block.\n    if (message == 'shutdown') {\n      receivePort.close();\n      return;\n    }\n    final (int id, String jsonText) = message as (int, String);\n    try {\n      final jsonData = jsonDecode(jsonText);\n      sendPort.send((id, jsonData));\n    } catch (e) {\n      sendPort.send((id, RemoteError(e.toString(), '')));\n    }\n  });\n}\n```\ncontent\\_copy\n-   Finally, you should add code to check if the ports are closed before trying to send messages. Add one line in the `Worker.parseJson` method.\ndart\n```\nFuture<Object?> parseJson(String message) async {\n  if (_closed) throw StateError('Closed'); // New\n  final completer = Completer<Object?>.sync();\n  final id = _idCounter++;\n  _activeRequests[id] = completer;\n  _commands.send((id, message));\n  return await completer.future;\n}\n```\ncontent\\_copy\n#### Complete example\n[#](#complete-example)\nExpand here to see the full example\ndart\n```\nimport 'dart:async';\nimport 'dart:convert';\nimport 'dart:isolate';\n​\nvoid main() async {\n  final worker = await Worker.spawn();\n  print(await worker.parseJson('{\"key\":\"value\"}'));\n  print(await worker.parseJson('\"banana\"'));\n  print(await worker.parseJson('[true, false, null, 1, \"string\"]'));\n  print(\n    await Future.wait([worker.parseJson('\"yes\"'), worker.parseJson('\"no\"')]),\n  );\n  worker.close();\n}\n​\nclass Worker {\n  final SendPort _commands;\n  final ReceivePort _responses;\n  final Map<int, Completer<Object?>> _activeRequests = {};\n  int _idCounter = 0;\n  bool _closed = false;\n​\n  Future<Object?> parseJson(String message) async {\n    if (_closed) throw StateError('Closed');\n    final completer = Completer<Object?>.sync();\n    final id = _idCounter++;\n    _activeRequests[id] = completer;\n    _commands.send((id, message));\n    return await completer.future;\n  }\n​\n  static Future<Worker> spawn() async {\n    // Create a receive port and add its initial message handler.\n    final initPort = RawReceivePort();\n    final connection = Completer<(ReceivePort, SendPort)>.sync();\n    initPort.handler = (initialMessage) {\n      final commandPort = initialMessage as SendPort;\n      connection.complete((\n        ReceivePort.fromRawReceivePort(initPort),\n        commandPort,\n      ));\n    };\n​\n    // Spawn the isolate.\n    try {\n      await Isolate.spawn(_startRemoteIsolate, (initPort.sendPort));\n    } on Object {\n      initPort.close();\n      rethrow;\n    }\n​\n    final (ReceivePort receivePort, SendPort sendPort) =\n        await connection.future;\n​\n    return Worker._(receivePort, sendPort);\n  }\n​\n  Worker._(this._responses, this._commands) {\n    _responses.listen(_handleResponsesFromIsolate);\n  }\n​\n  void _handleResponsesFromIsolate(dynamic message) {\n    final (int id, Object? response) = message as (int, Object?);\n    final completer = _activeRequests.remove(id)!;\n​\n    if (response is RemoteError) {\n      completer.completeError(response);\n    } else {\n      completer.complete(response);\n    }\n​\n    if (_closed && _activeRequests.isEmpty) _responses.close();\n  }\n​\n  static void _handleCommandsToIsolate(\n    ReceivePort receivePort,\n    SendPort sendPort,\n  ) {\n    receivePort.listen((message) {\n      if (message == 'shutdown') {\n        receivePort.close();\n        return;\n      }\n      final (int id, String jsonText) = message as (int, String);\n      try {\n        final jsonData = jsonDecode(jsonText);\n        sendPort.send((id, jsonData));\n      } catch (e) {\n        sendPort.send((id, RemoteError(e.toString(), '')));\n      }\n    });\n  }\n​\n  static void _startRemoteIsolate(SendPort sendPort) {\n    final receivePort = ReceivePort();\n    sendPort.send(receivePort.sendPort);\n    _handleCommandsToIsolate(receivePort, sendPort);\n  }\n​\n  void close() {\n    if (!_closed) {\n      _closed = true;\n      _commands.send('shutdown');\n      if (_activeRequests.isEmpty) _responses.close();\n      print('--- port closed --- ');\n    }\n  }\n}\n```\ncontent\\_copy\n[chevron\\_left\nPrevious Asynchronous support\n](https://dart.dev/language/async)[\nNext Sound null safety\nchevron\\_right](https://dart.dev/null-safety)\nWas this page's content helpful?\nthumb\\_up thumb\\_down\nUnless stated otherwise, the documentation on this site reflects Dart 3.10.3. Page last updated on 2025-12-10. [View source](https://github.com/dart-lang/site-www/blob/main/src/content/language/isolates.md) or [report an issue](https://github.com/dart-lang/site-www/issues/new?template=1_page_issue.yml&page-url=https://dart.dev/language/isolates&page-source=https://github.com/dart-lang/site-www/blob/main/src/content/language/isolates.md \"Report an issue with this page\").\n[![Dart](https://dart.dev/assets/img/logo/logo-white-text.svg)](https://dart.dev/ \"Dart\")\n[](https://blog.dart.dev \"Dart's Medium publication\")[](https://github.com/dart-lang \"Dart's GitHub organization\")[](https://bsky.app/profile/dart.dev \"Dart's Bluesky (Twitter) profile\")[](https://twitter.com/dart_lang \"Dart's X (Twitter) profile\")\nExcept as otherwise noted, this site is licensed under a [Creative Commons Attribution 4.0 International License,](https://creativecommons.org/licenses/by/4.0/) and code samples are licensed under the [3-Clause BSD License.](https://opensource.org/licenses/BSD-3-Clause)\n-   [Terms](https://dart.dev/terms \"Terms of use\")\n-   [Privacy](https://policies.google.com/privacy \"Privacy policy\")\n-   [Security](https://dart.dev/security \"Security philosophy and practices\")\n[](https://jaspr.site \"This site is built with the Jaspr web framework for Dart.\")",
  "timestamp": 1769963767338,
  "title": "Isolates"
}