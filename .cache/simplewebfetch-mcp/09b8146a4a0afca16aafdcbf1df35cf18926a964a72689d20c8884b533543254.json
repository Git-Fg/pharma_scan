{
  "url": "https://riverpod.dev/docs/concepts/about_code_generation",
  "markdown": "# About code generation | Riverpod\nCode generation is the idea of using a tool to generate code for us. In Dart, it comes with the downside of requiring an extra step to \"compile\" an application. Although this problem may be solved in the near future, as the Dart team is working on a potential solution to this problem.\nIn the context of Riverpod, code generation is about slightly changing the syntax for defining a \"provider\". For example, instead of:\n```\nfinal fetchUserProvider = FutureProvider.autoDispose.family<User, int>((  ref,  userId,) async {  final json = await http.get('api/user/$userId');  return User.fromJson(json);});\n```\nUsing code generation, we would write:\n```\n@riverpodFuture<User> fetchUser(Ref ref, {required int userId}) async {  final json = await http.get('api/user/$userId');  return User.fromJson(json);}\n```\nWhen using Riverpod, code generation is completely optional. It is entirely possible to use Riverpod without. At the same time, Riverpod embraces code generation and recommends using it.\nFor information on how to install and use Riverpod's code generator, refer to the [Getting started](https://riverpod.dev/docs/introduction/getting_started) page. Make sure to enable code generation in the documentation's sidebar.\n## Should I use code generation?[​](#should-i-use-code-generation \"Direct link to Should I use code generation?\")\nCode generation is optional in Riverpod. With that in mind, you may wonder if you should use it or not.\nThe answer is: **Only if you already use code-generation for other things**. (cf Freezed, json\\_serializable, etc.)\nWhen the Dart team was working on a feature called \"macros\", using code generation was the recommended way to use Riverpod. Unfortunately, those have been cancelled.\nWhile code-generation brings many benefits, it currently is still fairly slow. The Dart team is working on improving the performance of code generation, but it is unclear when that will be available and how much it will improve. As such, if you are not already using code generation in your project, it is probably not worth it to start using it just for Riverpod.\nAt the same time, many applications already use code generation with packages such as [Freezed](https://pub.dev/packages/freezed) or [json\\_serializable](https://pub.dev/packages/json_serializable). In that case, your project probably is already set up for code generation, and using Riverpod should be simple.\n## What are the benefits of using code generation?[​](#what-are-the-benefits-of-using-code-generation \"Direct link to What are the benefits of using code generation?\")\nYou may be wondering: \"If code generation is optional in Riverpod, why use it?\"\nAs always with packages: To make your life easier. This includes but is not limited to:\n-   Better syntax, more readable/flexible, and with a reduced learning curve.\n    -   No need to worry about the type of provider. Write your logic, and Riverpod will pick the most suitable provider for you.\n    -   The syntax no longer looks like we're defining a \"dirty global variable\". Instead we are defining a custom function/class.\n    -   Passing parameters to providers is now unrestricted. Instead of being limited to using [Family](https://riverpod.dev/docs/concepts2/family) and passing a single positional parameter, you can now pass any parameter. This includes named parameters, optional ones, and even default values.\n-   **Stateful hot-reload** of the code written in Riverpod.\n-   Better debugging, through the generation of extra metadata that the debugger then picks up.\n## The Syntax[​](#the-syntax \"Direct link to The Syntax\")\n### Defining a provider:[​](#defining-a-provider \"Direct link to Defining a provider:\")\nWhen defining a provider using code generation, it is helpful to keep in mind the following points:\n-   Providers can be defined either as an annotated function or as an annotated class. They are pretty much the same, but Class-based provider has the advantage of including public methods that enable external objects to modify the state of the provider (side-effects). Functional providers are syntax sugar for writing a Class-based provider with nothing but a `build` method, and as such cannot be modified by the UI.\n-   All Dart async primitives (Future, FutureOr, and Stream) are supported.\n-   When a function is marked as async, the provider automatically handles errors/loading states and exposes an AsyncValue.\n|  | Functional\n(Can’t perform side-effects\nusing public methods) | Class-Based\n(Can perform side-effects\nusing public methods) |\n| Sync |\n```\n@riverpodString example(Ref ref) {  return 'foo';}\n```\n |\n```\n@riverpodclass Example extends _$Example {  @override  String build() {    return 'foo';  }  // Add methods to mutate the state}\n```\n |\n| Async - Future |\n```\n@riverpodFuture<String> example(Ref ref) async {  return Future.value('foo');}\n```\n |\n```\n@riverpodclass Example extends _$Example {  @override  Future<String> build() async {    return Future.value('foo');  }  // Add methods to mutate the state}\n```\n |\n| Async - Stream |\n```\n@riverpodStream<String> example(Ref ref) async* {  yield 'foo';}\n```\n |\n```\n@riverpodclass Example extends _$Example {  @override  Stream<String> build() async* {    yield 'foo';  }  // Add methods to mutate the state}\n```\n |\n### Enabling/disable autoDispose:[​](#enablingdisable-autodispose \"Direct link to Enabling/disable autoDispose:\")\nWhen using code generation, providers are autoDispose by default. That means that they will automatically dispose of themselves when there are no listeners attached to them (ref.watch/ref.listen).\nThis default setting better aligns with Riverpod's philosophy. Initially with the non-code generation variant, autoDispose was off by default to accommodate users migrating from `package:provider`.\nIf you want to disable autoDispose, you can do so by passing `keepAlive: true` to the annotation.\n```\n// AutoDispose provider (keepAlive is false by default)@riverpodString example1(Ref ref) => 'foo';// Non autoDispose provider@Riverpod(keepAlive: true)String example2(Ref ref) => 'foo';\n```\n### Passing parameters to a provider (family):[​](#passing-parameters-to-a-provider-family \"Direct link to Passing parameters to a provider (family):\")\nWhen using code generation, we no-longer need to rely on the `family` modifier to pass parameters to a provider. Instead, the main function of our provider can accept any number of parameters, including named, optional, or default values.\nDo note however that these parameters should still have a consistent ==. Meaning either the values should be cached, or the parameters should override ==.\n| Functional | Class-Based |\n|\n```\n@riverpodString example(  Ref ref,  int param1, {  String param2 = 'foo',}) {  return 'Hello $param1 & $param2';}\n```\n |\n```\n@riverpodclass Example extends _$Example {  @override  String build(    int param1, {    String param2 = 'foo',  }) {    return 'Hello $param1 & $param2';  }  // Add methods to mutate the state}\n```\n |\n## Migrate from non-code-generation variant:[​](#migrate-from-non-code-generation-variant \"Direct link to Migrate from non-code-generation variant:\")\nWhen using non-code-generation variant, it is necessary to manually determine the type of your provider. The following are the corresponding options for transitioning into code-generation variant:\n| Provider |\n| Before |\n```\nfinal exampleProvider = Provider.autoDispose<String>(  (ref) {    return 'foo';  },);\n```\n |\n| After |\n```\n@riverpodString example(Ref ref) {  return 'foo';}\n```\n |\n| NotifierProvider |\n| Before |\n```\nfinal exampleProvider = NotifierProvider.autoDispose<ExampleNotifier, String>(  ExampleNotifier.new,);class ExampleNotifier extends Notifier<String> {  @override  String build() {    return 'foo';  }  // Add methods to mutate the state}\n```\n |\n| After |\n```\n@riverpodclass Example extends _$Example {  @override  String build() {    return 'foo';  }  // Add methods to mutate the state}\n```\n |\n| FutureProvider |\n| Before |\n```\nfinal exampleProvider = FutureProvider.autoDispose<String>((ref) async {  return Future.value('foo');});\n```\n |\n| After |\n```\n@riverpodFuture<String> example(Ref ref) async {  return Future.value('foo');}\n```\n |\n| StreamProvider |\n| Before |\n```\nfinal exampleProvider =    StreamProvider.autoDispose<String>((ref) async* {  yield 'foo';});\n```\n |\n| After |\n```\n@riverpodStream<String> example(Ref ref) async* {  yield 'foo';}\n```\n |\n| AsyncNotifierProvider |\n| Before |\n```\nfinal exampleProvider =    AsyncNotifierProvider.autoDispose<ExampleNotifier, String>(      ExampleNotifier.new,    );class ExampleNotifier extends AsyncNotifier<String> {  @override  Future<String> build() async {    return Future.value('foo');  }  // Add methods to mutate the state}\n```\n |\n| After |\n```\n@riverpodclass Example extends _$Example {  @override  Future<String> build() async {    return Future.value('foo');  }  // Add methods to mutate the state}\n```\n |\n| StreamNotifierProvider |\n| Before |\n```\nfinal exampleProvider =    StreamNotifierProvider.autoDispose<ExampleNotifier, String>(() {  return ExampleNotifier();});class ExampleNotifier extends StreamNotifier<String> {  @override  Stream<String> build() async* {    yield 'foo';  }  // Add methods to mutate the state}\n```\n |\n| After |\n```\n@riverpodclass Example extends _$Example {  @override  Stream<String> build() async* {    yield 'foo';  }  // Add methods to mutate the state}\n```\n |",
  "timestamp": 1769973817209,
  "title": "About code generation | Riverpod"
}