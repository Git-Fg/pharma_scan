{
  "url": "https://quickbirdstudios.com/blog/macros-dart-flutter",
  "markdown": "# RIP build_runner: A Deep Dive Into Macros in Dart & Flutter\n*By Marvin M√§rz*\n---\n**Dart macros** are here to change the game for Flutter and Dart developers. If you‚Äôve ever been frustrated by the complexities of using `build_runner`for code generation‚Äîlike slow build times, constant manual regenerations, and synchronization headaches‚Äîmacros offer a powerful, integrated alternative.\nUnlike`build_runner`, which requires external dependencies and can feel cumbersome, Dart macros enable code generation directly at compile time, eliminating the need for a separate build step. This means faster builds, reduced boilerplate, and more time focused on writing the code that truly matters.\n---\n## What do we need üõ†Ô∏è\nMacros are a built-in language feature in Dart, meaning all the core functionality is already available. However, there are several helpful extensions that can simplify development‚Äîwe‚Äôll cover those later.\nSince the macros feature hasn‚Äôt yet reached the stable channel, we currently need to work within the beta channel or, for those willing to be on the cutting edge, the main channel of Flutter. The Flutter team has announced that the first macro feature (`@JsonCodable`) is expected to arrive in the stable channel later this year (2024), with support for custom macro development anticipated in Q1 2025.\n### Enable Macros\nJust run `flutter channel beta` followed by a `flutter upgrade` (change beta to main if you want to use the latest build from Github). Since macros are a language feature, you also need to change your project‚Äôs minimum required Dart version. Macros are supported since Dart 3.5.0-152. You can set this in your `pubspec.yaml` under `environment`. E.g you can use this configuration:\nenvironment:\n  sdk: '>=3.5.0-152 <4.0.0'\n  flutter: \">=2.0.0\"\nSo the linter does not complain we also need to enable the macros experiment in our analyzer file. In your `analysis_option.yaml` add:\nenable-experiment:\n- macros\n**With these steps, you‚Äôre all set to start developing macros!**\n## What are Macros? üì∏\nMacros are a Dart feature that enable **static meta-programming**, allowing the language to analyze code and automatically generate additional functionality based on it. While similar to`build_runner` , macros run instantly during compilation rather than as a separate task, making them much faster.\nAs mentioned above there is already one macro that works out of the box called `@JsonCodable`. Simply add this annotation to a data class, and it will generate everything needed for JSON serialization and deserialization. In most IDEs, you can even jump directly to the generated code. For example, in VSCode, you‚Äôll see a ‚ÄúGo to augmentation‚Äù option‚Äîclick it to view the code created by the macro.\nAnd yes it‚Äôs that lightning-fast. Unlike `build_runner`¬†combined with `JsonSerializable` or `Freezed`, macros generate code instantly with no need to run extra commands in the terminal. ü§Ø\nHere are some additional benefits of macros in Dart that make Flutter development easier:\n-   **Code Generation**: Macros automatically create repetitive code, like getters, setters, and boilerplate methods, saving you time and reducing errors.\n-   **Goodbye to `build_runner`¬†Tasks**: Macros handle code generation at compile-time, eliminating the need for `build_runner` tasks, which speeds up development.\n-   **Compile-Time Optimizations**: Macros add optimized code before runtime, which boosts performance without any added runtime overhead.\n-   **Improved Consistency**: By automating patterns, macros bring consistency to your codebase, minimizing bugs from human error.\n-   **Custom Annotations**: Macros let you create powerful, specific annotations that add functionality‚Äîlike validation or logging‚Äîwithout cluttering your main code.\nReady to build your own macro? Let‚Äôs start with a simple example and then we dive into the details!\n### The toString Macro\nLet‚Äôs start with an easy example. We want to create a macro that adds a custom `toString` method to a class. The custom `toString` should always output ‚ÄúMacros are awesome‚Äù.\nMacros are created by adding a modifier to a class called `macro`. In our case, we want to call our macro `Awesome`. I typed out the complete class first and then we will go into detail about what everything does.\nimport 'dart:async';\nimport 'package:macros/macros.dart';\nfinal \\_dartCore = Uri.parse('dart:core');\nmacro class Awesome implements ClassDeclarationsMacro {\n  const Awesome();\n  @override\n  Future<void> buildDeclarationsForClass(\n    ClassDeclaration clazz,\n    MemberDeclarationBuilder builder,\n  ) async {\n    final print = await builder.resolveIdentifier(\\_dartCore, 'print');\n    builder.declareInType(\n      DeclarationCode.fromParts(\\[\n        '@override\\\\\\\\n',\n        'void toString() {\\\\\\\\n',\n        print,\n        '(\"Macros are awesome\");}',\n      \\]),\n    );\n  }\n}\nNow the only thing that‚Äôs left is to use our macro. To use a macro you need to annotate the class with the macro.\n@Awesome()\nclass Bird {\n  final String name;\n  const Bird(this.name);\n}\nLet‚Äôs use our class now and see if it worked:\nconst bird = Bird('QuickBird');\nprint(bird.toString());\n// Output: Macros are awesome\nWow, it worked üéâ.¬†OK, this looks complicated!¬†We now step through the code and check what every declaration does. We start with the first line (skipping the imports for now)\n### The Details üîç\nmacro class Awesome implements ClassDeclarationsMacro\nTo create a macro we need to annotate the class with the macro identifier. In our case we want to implement the macro on the class-level, that‚Äôs why we need to implement the `ClassDeclarationsMacro`. There are also other interfaces to implement a macro on the function-level, constructor-level, or others. We take a look at those later.\nMost macros have two important methods that we most of the time have to override:\n`buildDefinitionForClass`provides the mechanism to inspect a class‚Äôs structure (its fields, methods, and annotations) at compile-time and allows the macro to inject or modify code based on that class.\n`buildDeclarationsForClass`is used to define or modify the actual implementation of a class (like methods or fields), `buildDeclarationsForClass` focuses on generating new **declarations** that aren‚Äôt originally part of the class or its members.\nIn our example, we just wanted to implement a method that is independent of the rest of the class but technically we could have split it up to build the method definition name, parameters, etc., and later do the print statement within the buildDeclarations method. In that case, we decided to go the easier route for better understanding.\nfinal print = await builder.resolveIdentifier(\\_dartCore, 'print');\nSince we want to print out something to the console we also need the print function from the Dart Standard library. Technically we could write out the print statement as a String but we also need to take care of the import statement. By calling `resolveIndentifier` Dart will take care of it. So it‚Äôs always advised to use it when you want to use something that‚Äôs not directly part of the language or if you want to use some library.\nbuilder.declareInType(\n     DeclarationCode.fromParts(\\[\n       '@override\\\\\\\\n',\n       'void toString() {\\\\\\\\n',\n       print,\n       '(\"Macros is awesome\");}',\n     \\]),\n   );\nAs mentioned earlier, there are different types of macros. While some are designed to be applied at the class level, others can be used on functions or constructors. Let‚Äôs explore those next.\n[![Join us as a Flutter Developer!](https://quickbirdstudios.com/wp-content/uploads/2022/01/Job-Ad-Flutter-Munich-Flutter.png)](https://quickbirdstudios.com/jobs-flutter-developer-en?utm_source=blog-post-job-ad-short-flutter)\n## Types of Macros\n#### ClassDeclarationMacro\nThis type of macro works on class declarations. It gives you the ability to inspect and modify classes, adding new members (fields, methods, constructors), changing existing ones, or even generate entirely new classes based on the structure of the original class. This makes sense e.g. when:\n-   Generating `copyWith`, `equals`, and `hashcode`¬†methods for data classes.\n-   Adding serialization/deserialization logic (like the `@JsonSerializable`example).\n-   Creating factory constructors or helper methods based on class fields.\n#### FunctionDeclarationMacro\n`FunctionDeclarationMacro` focuses on functions, enabling analysis and transformation of function signatures, parameters, and bodies. Examples of where this is useful include:\n-   Automatically generating documentation for functions.\n-   Adding logging or tracing code to functions.\n-   Creating wrapper functions with modified behavior.\nThere are even more types of macros, such as `VariableDeclarationMacro`, `MixinDeclarationMacro`, `ConstructionsDeclarationMacro`. For a comprehensive list, refer to Dart‚Äôs [macros](https://github.com/dart-lang/macros/blob/main/pkgs/macro/lib/src/macro.dart). documentation. Notably, a single macro class can implement multiple macro interfaces, allowing it to operate across several phases.\n#### Generated Code ‚Äì the augment keyword\nThe `augment` The keyword in Dart is used with macros, allowing developers to introduce code transformations or additions at compile-time. Specifically, it indicates that a macro can modify or ‚Äúaugment‚Äù existing code, such as methods or classes. This provides a way to extend or enhance functionality while keeping the source code clean and concise. However, using `augment`¬†outside of macros is not recommended. Instead, for general purposes, you should rely on traditional methods like inheritance, mixins, and extensions, unless they are leveraging macros.\n#### Order matters!\nYou can also add multiple macros to a class and they can also depend on each other. They will be executed bottom ‚¨ÜÔ∏è top.\n@Macro2()\n@Macro1()\nclass Order {}\nIn that case, @Macro1 is executed first, and then @Macro2 is executed.\n#### Resource Access in Macros\nSome macros may require loading resources, such as files. While this capability is supported, there are safeguards in place because macros run during analysis and are considered untrusted code. Therefore, macros are restricted from accessing resources outside the program‚Äôs designated scope.\n##### Other limitations\nSome other limitations of macros are:\n-   All macro constructors must be marked as const.\n-   Macro classes cannot be generated by other macros.\n-   All macros must implement at least one of the `macro` interfaces.\n-   Macros cannot be abstract.\nThis is the current state at the time of writing this article. Things might change in the future.\n## Conclusion\nMacros in Dart promise to address some of the most tedious, repetitive tasks in Flutter and Dart development. With macros, we can finally move beyond the burdens of `build_runner` and JSON serialization/deserialization. This opens up exciting possibilities for implementing functionalities that streamline user experiences by concealing complexity, making advanced features like navigation, storage, and modularization more accessible.\nHowever, macros also come with potential pitfalls. They can obscure functionality and lead to hidden behaviors that developers might not anticipate. Building macros is complex work that requires an understanding of various language elements‚Äînot the usual development task. Like with`build_runner` plugins, writing macros often involves detecting specific class elements and generating code, necessitating extensive string manipulation.\nIn short, macros hold promise for enhancing productivity but demand careful use to balance power with clarity.\nThanks for reading!\n**Do you search for a job as a Flutter Developer?**\n**Do you want to work with people that care about good software engineering?\n**[**Join our team in Munich**](https://quickbirdstudios.com/jobs-flutter-developer-en?utm_source=flutter-job-ad-blog-post)\n![](https://quickbirdstudios.com/wp-content/uploads/2022/07/JobsHeaderBild-min.png)",
  "timestamp": 1769973823142,
  "title": "RIP build_runner: A Deep Dive Into Macros in Dart & Flutter"
}