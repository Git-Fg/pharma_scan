import { Database } from "bun:sqlite";
import fs from "node:fs";
import path from "node:path";

const DB_PATH = path.join("data", "reference.db"); // Chemin vers la DB g√©n√©r√©e
const OUTPUT_DRIFT_PATH = path.join("..", "lib", "core", "database", "reference_schema.drift");

console.log("üîç Introspecting database schema...");

if (!fs.existsSync(DB_PATH)) {
  console.error(`‚ùå Database not found at ${DB_PATH}. Run build first.`);
  process.exit(1);
}

const db = new Database(DB_PATH);

// 1. En-t√™te Drift (Optionnel, mais propre)
let driftContent = `-- AUTOMATICALLY GENERATED BY backend_pipeline/tool/export_schema.ts
-- DO NOT EDIT MANUALLY
--
-- Source of Truth: backend_pipeline/src/db.ts
-- Timestamp: ${new Date().toISOString()}

`;

// 2. Extraction des Tables et Vues (Ordre important pour les FK, mais Drift g√®re bien)
// On exclut les tables internes de SQLite
const query = `
  SELECT type, name, sql 
  FROM sqlite_master 
  WHERE sql IS NOT NULL 
  AND name NOT LIKE 'sqlite_%'
  ORDER BY 
    CASE type 
      WHEN 'table' THEN 1 
      WHEN 'view' THEN 2 
      WHEN 'trigger' THEN 3 
      ELSE 4 
    END;
`;

const schemaItems = db.query(query).all() as { type: string, name: string, sql: string }[];

for (const item of schemaItems) {
  let sql = item.sql.trim();
  if (!sql.endsWith(';')) sql += ';';

  driftContent += `${sql}\n\n`;
}

// Ensure output directory exists
try {
  fs.mkdirSync(path.dirname(OUTPUT_DRIFT_PATH), { recursive: true });
  fs.writeFileSync(OUTPUT_DRIFT_PATH, driftContent);
  console.log(`‚úÖ Schema exported to: ${OUTPUT_DRIFT_PATH}`);
} catch (e) {
  console.error(`‚ùå Failed to write drift file: ${e}`);
  process.exit(1);
}

db.close();
