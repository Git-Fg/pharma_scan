// test/helpers/db_loader.dart

import 'dart:io';
import 'dart:math';

import 'package:drift/native.dart';
import 'package:path/path.dart' as p;
import 'package:pharma_scan/core/database/database.dart';
import 'package:pharma_scan/core/logic/sanitizer.dart';
import 'package:sqlite3/common.dart';

/// Configure SQLite avec les optimisations et fonctions personnalis√©es.
/// This is only used in tests (native platform only).
void configureAppSQLite(CommonDatabase database) {
  database
    ..execute('PRAGMA journal_mode=WAL')
    ..execute('PRAGMA busy_timeout=30000')
    ..execute('PRAGMA synchronous=NORMAL')
    ..execute('PRAGMA mmap_size=300000000')
    ..execute('PRAGMA temp_store=MEMORY')
    ..createFunction(
      functionName: 'normalize_text',
      argumentCount: const AllowedArgumentCount(1),
      deterministic: true,
      directOnly: false,
      function: (List<Object?> args) {
        final source = args.isEmpty ? '' : args.first?.toString() ?? '';
        if (source.isEmpty) return '';
        return normalizeForSearch(source);
      },
    );
}

/// WHY: Implements the "Thin Client" architecture for integration tests.
/// Instead of manually seeding tables with potentially outdated SQL,
/// we load a pre-populated "golden" database artifact from the backend.
///
/// This ensures:
/// 1. Schema consistency - The golden DB is built by the same backend that
///    builds production DBs, so schema is always correct.
/// 2. Realistic data - Tests run against real-world data structures.
/// 3. No test fragility - No hardcoded SQL strings to maintain.

/// Loads the golden database artifact for integration testing.
///
/// This function:
/// 1. Locates the golden.db file at `test/assets/golden.db`
/// 2. Creates a unique temporary copy to avoid file locking issues
/// 3. Returns an AppDatabase instance connected to this copy
///
/// Usage:
/// ```dart
/// late AppDatabase db;
///
/// setUp(() async {
///   db = await loadGoldenDatabase();
/// });
///
/// tearDown(() async {
///   await db.close();
/// });
/// ```
Future<AppDatabase> loadGoldenDatabase() async {
  // Locate the golden database source file
  final goldenDbPath = _resolveGoldenDbPath();
  final sourceFile = File(goldenDbPath);

  if (!sourceFile.existsSync()) {
    throw StateError(
      'Golden database not found at: $goldenDbPath\n'
      'Please ensure test/assets/golden.db exists.\n'
      'This file should be generated by the backend pipeline.',
    );
  }

  // Create a unique temporary copy to avoid SQLite locking issues
  // when running multiple tests in parallel
  final tempDir = await Directory.systemTemp.createTemp('pharma_test_');
  final timestamp = DateTime.now().millisecondsSinceEpoch;
  final randomSuffix = Random().nextInt(10000);
  final tempDbPath = p.join(
    tempDir.path,
    'golden_${timestamp}_$randomSuffix.db',
  );

  // Copy the golden database bytes to the temp location
  await sourceFile.copy(tempDbPath);

  // Initialize NativeDatabase with the temp copy
  final nativeDb = NativeDatabase(
    File(tempDbPath),
    setup: configureAppSQLite,
  );

  return AppDatabase.forTesting(nativeDb);
}

/// Resolves the path to the golden database file.
///
/// Handles both unit test (dart test) and integration test contexts
/// by checking relative paths from the working directory.
String _resolveGoldenDbPath() {
  final cwd = Directory.current.path;

  // Standard path for unit tests run from project root
  final standardPath = p.join(cwd, 'test', 'assets', 'golden.db');
  if (File(standardPath).existsSync()) {
    return standardPath;
  }

  // Fallback: Check if we're already in the test directory
  final localPath = p.join(cwd, 'assets', 'golden.db');
  if (File(localPath).existsSync()) {
    return localPath;
  }

  // Return standard path for error message clarity
  return standardPath;
}

/// Creates a fresh in-memory copy of the golden database.
///
/// This is useful for tests that need complete isolation and don't
/// require persistence. The database is copied into memory for faster
/// access and automatic cleanup.
///
/// NOTE: This loads the entire DB into memory, so only use for
/// reasonable-sized golden databases.
Future<AppDatabase> loadGoldenDatabaseInMemory() async {
  final goldenDbPath = _resolveGoldenDbPath();
  final sourceFile = File(goldenDbPath);

  if (!sourceFile.existsSync()) {
    throw StateError(
      'Golden database not found at: $goldenDbPath\n'
      'Please ensure test/assets/golden.db exists.',
    );
  }

  // Read the golden database bytes
  final bytes = await sourceFile.readAsBytes();

  // Create an in-memory database and restore from bytes
  // Note: drift doesn't directly support this, so we use a temp file approach
  final tempDir = await Directory.systemTemp.createTemp('pharma_mem_');
  final tempPath = p.join(tempDir.path, 'mem_golden.db');
  await File(tempPath).writeAsBytes(bytes);

  final nativeDb = NativeDatabase(
    File(tempPath),
    setup: configureAppSQLite,
  );

  return AppDatabase.forTesting(nativeDb);
}
