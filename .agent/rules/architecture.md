# Architecture & API Design

## PharmaScan Domain Architecture

**Core Philosophy**: Before designing features, understand the domain model and constraints:

- [`docs/DOMAIN_MODEL.md`](../../docs/DOMAIN_MODEL.md) - CIP/CIS hierarchy, chemical clusters, princeps election
- [`docs/EXPLORER_CORE_GOAL.md`](../../docs/EXPLORER_CORE_GOAL.md) - Brand-centric organization, scanner-first design
- [`docs/REGEX_BRITTLENESS.md`](../../docs/REGEX_BRITTLENESS.md) - Why composition lookup > regex

### Data Hierarchy

```
Cluster (Molecule/Combo)
  └── Group (Dosage/Form)
      └── CIS (Specialty)
          └── CIP (Presentation)
```

**Key Insight**: The CIP is the primary entry point (scanner). All data must be traceable to a scannable CIP with both a clean brand name and a clean generic name.

### Extension Types (Type Safety)

Use extension types for all domain identifiers:

```dart
extension type Cip13(int);      // 13-digit barcode
extension type CisCode(int);    // 8-digit specialty code
extension type ClusterId(String); // Chemical cluster
extension type GroupId(int);     // Dosage/form group
```

**Benefit**: Compile-time type safety prevents mixing incompatible identifiers.

### Dual SQLite Architecture

- **Reference Database**: BDPM data (read-only, generated by pipeline)
- **User Database**: Local data (restock, history, preferences)
- Both attach transparently for queries

### Chemical ID

Format: Substance codes joined with `+`

```
Amoxicillin + Clavulanic acid → "0045+1234"
Paracetamol alone → "0123"
```

Purpose: Cluster medications by identical chemical composition.

---

## Application Architecture

### Separation of Concerns

Aim for separation similar to MVC/MVVM with defined Model, View, and ViewModel/Controller roles.

### Logical Layers

Organize the project into logical layers:
- **Presentation** (widgets, screens) - UI only
- **Domain** (business logic, extensions) - Core rules
- **Data** (model classes, API clients) - Data access
- **Core** (shared classes, utilities, extension types) - Infra

### Feature-Based Organization

Organize code by feature where each feature has its own presentation, domain, and data subfolders:

```
lib/
├── core/           # Shared (cannot import features)
├── features/
│   ├── scanner/    # Can't import other features
│   ├── explorer/   # Can't import other features
│   └── restock/    # Can't import other features
└── app/            # Entry, router, theme
```

**Rule**: `core` cannot import `features`
**Rule**: `features` cannot import other `features`

### Layer Isolation

Enforced at compile time via lints. This prevents circular dependencies and keeps architecture clean.

---

## State Management Philosophy

### Riverpod + Signals

- **Riverpod**: Global app state, providers, dependency injection
- **Signals**: High-frequency UI state (scanner bubbles)
- **Hooks**: Lifecycle management

### AsyncValue Pattern

Use Dart 3 pattern matching for async state:

```dart
match<Widget, AsyncValue<Cluster>>(
  asyncValue,
  (data) => ClusterView(cluster: data.value),
  (error) => ErrorView(error: error.error),
  (loading) => LoadingIndicator(),
);
```

---

## API Design Principles

When building reusable APIs or libraries:

### Consider the User

Design APIs from the perspective of the person using them. The API should be intuitive and easy to use correctly.

### Documentation is Essential

Good documentation is part of good API design. It should be clear, concise, and provide examples.

### Schema-Driven Code Generation

The backend exports JSON contracts that generate type-safe Dart code. Never hand-write types that should be generated from the schema.

### Composition-Based Lookup

When working with medication data:
- Use BDPM composition data (`CIS_COMPO_bdpm.txt`) directly
- Avoid regex pattern matching for semantic relationships
- Brand ↔ Generic links come from composition, not string manipulation
