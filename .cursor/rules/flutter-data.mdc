---
description: Drift database patterns, SQL-first logic, FTS5 search, and query optimization
alwaysApply: false
---
# Flutter Data Layer (2025 Standard)

## SQL-First Logic

**Mandate:** If grouping/sorting/filtering can be expressed in SQL (tables/views), keep it in SQL.

- SQL > Dart: avoid mapping/grouping in Dart when a view can return the exact shape.
- Performance: let SQLite's optimizer handle joins and indices.

## Build Runner (2025 Reality)

- Dart Macros cancelled → `build_runner` is persistent standard
- Use `dart_mappable` ONLY for: Network DTOs, UI State
- **NEVER** for Database entities (use Extension Types wrapping Drift)

## Query Patterns

- Streams: prefer `watch()` for UI-facing data.
- Detail views: use `watchSingleOrNull()` to tolerate concurrent deletions.
- Bulk ops: push work into SQL views/queries; avoid per-row `customStatement`.
- FTS queries live in `.drift`; use generated accessors, not ad-hoc `customSelect`.

## Optimization

- **Transactions:** Wrap multiple writes in `transaction(() async { ... })`
- **Batching:** Use `batch((batch) { ... })` for bulk inserts
- **Indexing:** Define indices in `.drift` files on `WHERE`/`JOIN` columns

## FTS5 Search

**Standard setup:**

- Use FTS5 with the tokenizer/normalization strategy defined in domain docs (e.g., `docs/DOMAIN_LOGIC.md` for app-specific choices).
- Define virtual tables and SELECT helpers in `.drift`; consume generated accessors in DAOs.
- Normalize/trim input before querying; if custom SQL helpers exist, keep them single-source and documented in domain docs.
- Escape user-entered terms with an FTS5-safe helper before issuing search queries.
- Ensure the chosen tokenizer is supported by the SQLite build included in the app (verify bundled native libs match the target tokenizer).

## Database Safety

```dart
// ✅ watchSingleOrNull (prevents crashes on concurrent deletions)
Stream<Item?> watchItem(String id) => dao.watchSingleOrNull(id);

// ✅ .isIn handles large sets (Drift 2.24+, no manual chunking)
final query = db.select(db.table)..where((t) => t.id.isIn(ids));

// ❌ FORBIDDEN: String interpolation in queries
// ✅ Use Expression API for dynamic queries
```

## Drift Managers Mandate

**For bulk operations:** Push work into SQL views/inserts and consume the generated APIs; avoid per-row `customStatement` loops.

## Offline-First Architecture

- **Primary Source:** Local database (Drift) is source of truth
- **Sync:** Implement background sync for remote data when needed
- **Caching:** Use database as cache layer for network responses

## Anti-Patterns

- ❌ Dart loops for grouping/sorting (use SQL Views)
- ❌ String interpolation in queries (use Expression API)
- ❌ Manual chunking for `.isIn()` (Drift handles it)
- ❌ `watchSingle` (use `watchSingleOrNull`)
- ❌ `Either` in DAOs (use plain `Future<void>` and let exceptions bubble)
- ❌ Re-implementing search/group formatting in Dart when `.drift` views/queries exist
- ✅ SQL Views for aggregations
- ✅ Transactions for multi-write operations
- ✅ FTS5 search with domain-appropriate tokenizer

## Transactional Integrity (The "No-Orphan" Rule)

**Mandate:** Business operations that affect multiple tables MUST be atomic within the DAO.

- **Forbidden:** Orchestrating multi-table deletes/updates inside a Riverpod Notifier.
- **Required:** A single DAO method wrapped in `transaction(() async { ... })`.

### ❌ Anti-Pattern (Notifier Orchestration)

```dart
// BAD: If step 1 succeeds but step 2 fails/crashes, data is corrupted.
Future<void> deleteItem(String id) async {
  await db.itemsDao.delete(id);
  // <--- Potential crash/error here leaves "Ghost Data" in history
  await db.historyDao.deleteForItemId(id);
}
```

### ✅ Standard (DAO Transaction)

```dart
// GOOD: Atomic. Both happen, or neither happens.
// In ItemsDao:
Future<void> deleteItemFully(String id) async {
  await transaction(() async {
    await (delete(items)..where((t) => t.id.equals(id))).go();
    await (delete(history)..where((t) => t.itemId.equals(id))).go();
  });
}
```
