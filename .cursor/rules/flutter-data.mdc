---
description: Drift database patterns, SQL-first logic, and Isolate management
alwaysApply: false
---

# Flutter Data Layer (2025 Standard)

## Core Philosophy: SQL-First & Isolate-First

**1. SQL-First Definitions (`.drift` files)**

- **MANDATE:** Define tables, triggers, and indices in `.drift` files, NOT Dart classes.
- **Why:** Unlocks SQL power features (JSONB, Window Functions) and reduces build times.
- **Pattern:**

```sql
-- lib/database/tables.drift
CREATE TABLE items (
    id INT NOT NULL PRIMARY KEY AUTOINCREMENT,
    meta_data JSONB, -- Uses SQLite 3.45+ JSONB
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

**2. Isolate-First Execution**

- **MANDATE:** All database I/O must occur on a background isolate.
- **Implementation:** Use `NativeDatabase.createInBackground` in your database provider.
- **Forbidden:** Instantiating `NativeDatabase(File(...))` on the main thread.

## Interaction Patterns

**1. Records over DTOs**

- **Rule:** Do not create specific DTO classes for query results. Use Dart Records.
- **Pattern:**

```dart
// DAO
Future<List<({String name, double total})>> getStats() async {
  final query = select(users).join([...]);
  return query.map((r) => (
        name: r.readTable(users).name,
        total: r.read(orders.amount) ?? 0.0,
      )).get();
}
```

**2. Batch Operations**

- **Rule:** Use `batch` for multiple writes. Use `insertFromSelect` for bulk data moves (archiving) to avoid Dart-loop overhead.

## Search (FTS5)

- **Tokenization:** Use `tokenize='trigram'` for typo tolerance in `search_index`.
- **Normalization:** Use a custom SQL User Defined Function (UDF) `normalize_text` registered in the connection setup to ensure SQL and Dart logic match exactly.

## Anti-Patterns

- ❌ Defining schema in Dart (`class Users extends Table`).
- ❌ Accessing generated Row classes in the UI (Wrap in Domain Entity Extension Types).
- ❌ Main-thread DB connections (Causes UI jank).
