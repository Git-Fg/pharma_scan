---
description: CONSTANTLY APPLIED. Complete UI design system: Shadcn components, responsive design, accessibility, and layout safety.
globs: lib/features/**/*.dart, lib/core/widgets/**/*.dart
alwaysApply: true
---

# UI Design System (2025 Standard)

**Context:** Complete design system using `shadcn_ui`. This consolidates Shadcn components, responsive design, accessibility, and layout safety into a single source of truth.

## 1. Framework UI & Setup

### Core Philosophy

* **UI Library:** Use `shadcn_ui` widgets exclusively. Do NOT use other external UI component libraries or Material-only patterns for new code.
* **Icon Library:** Strictly use `LucideIcons` (bundled with shadcn_ui). Do NOT use `Icons.*` (Material).
* **Theme Access:** Access styles via `ShadTheme.of(context)` for colors, typography, and shapes.
* **Theme Supremacy:** All colors, typography, and shapes MUST use `ShadTheme.of(context).*`. Hardcoded values are FORBIDDEN.
* **Bundled Exports:** `flutter_animate`, `lucide_icons_flutter`, and `intl` are bundled with `shadcn_ui`. Do NOT import these packages separately in `pubspec.yaml`. Use them via `shadcn_ui` exports.

### Application Setup

**CRITICAL:** Follow this exact pattern for root application setup. `ShadApp.custom` wrapping `MaterialApp.router` is the standard pattern.

```dart
import 'package:shadcn_ui/shadcn_ui.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:auto_route/auto_route.dart';

class MyApp extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final appRouter = ref.watch(appRouterProvider);
    final themeMode = ref.watch(themeProvider).value ?? ThemeMode.system;
    
    return ShadApp.custom(
      themeMode: themeMode,
      theme: ShadThemeData(
        brightness: Brightness.light,
        colorScheme: const ShadGreenColorScheme.light(),
      ),
      darkTheme: ShadThemeData(
        brightness: Brightness.dark,
        colorScheme: const ShadGreenColorScheme.dark(),
      ),
      appBuilder: (context) {
        return MaterialApp.router(
          theme: Theme.of(context),
          darkTheme: Theme.of(context),
          supportedLocales: const [
            Locale('en', ''),
            Locale('fr', ''),
          ],
          localizationsDelegates: const [
            GlobalMaterialLocalizations.delegate,
            GlobalWidgetsLocalizations.delegate,
            GlobalCupertinoLocalizations.delegate,
          ],
          builder: (context, child) {
            return ShadAppBuilder(child: child!);
          },
          routerConfig: appRouter.config(),
        );
      },
    );
  }
}
```

**Key Points:**

* `ShadApp.custom` wraps `MaterialApp.router` via `appBuilder` - this is the standard pattern
* `ShadAppBuilder` must be in the `builder` callback
* `Theme.of(context)` is automatically provided by ShadApp
* `flutter_localizations` is required for localization support
* Use AutoRoute's `appRouter.config()` for router configuration
* **Theme Access Rule:** Use `ShadTheme.of(context).textTheme` exclusively. Prohibit `Theme.of(context).textTheme` unless accessing Material fallbacks.

### Typography & Colors

* **Typography:** Use semantic names: `h1`, `h2`, `h3`, `h4`, `p`, `lead`, `large`, `small`, `muted`.
* **Colors:** `ShadTheme.of(context).colorScheme.primary`, `destructive`, `muted`, `background`.
  * ❌ BAD: `Colors.red`, `Color(0xFF...)`
  * ✅ GOOD: `ShadTheme.of(context).colorScheme.destructive`
* **Shapes:** `ShadTheme.of(context).radius`.

## 2. Responsive Design (Shadcn Native)

**Mandate:** Use `ShadResponsiveBuilder` or `context.breakpoint` extension to branch UI logic based on screen size. **Raw `MediaQuery` width checks are FORBIDDEN for responsive design.**

**Preferred Approach:** `ShadResponsiveBuilder` with sealed class breakpoints

```dart
// ✅ CORRECT: Using ShadResponsiveBuilder with sealed class pattern matching
ShadResponsiveBuilder(
  builder: (context, breakpoint) {
    return switch (breakpoint) {
      ShadBreakpointTN() => const MobileView(),
      ShadBreakpointSM() => const MobileView(),
      ShadBreakpointMD() => const TabletView(),
      ShadBreakpointLG() => const DesktopView(),
      ShadBreakpointXL() => const DesktopView(),
      ShadBreakpointXXL() => const DesktopView(),
    };
  },
);
```

**Alternative Approach:** `context.breakpoint` extension

```dart
// ✅ CORRECT: Using context.breakpoint extension
final breakpoint = context.breakpoint;
if (breakpoint >= ShadTheme.of(context).breakpoints.md) {
  return DesktopLayout();
}
return MobileLayout();
```

**Available Sealed Classes:**

* `ShadBreakpointTN()` - Tiny (0)
* `ShadBreakpointSM()` - Small (640)
* `ShadBreakpointMD()` - Medium (768)
* `ShadBreakpointLG()` - Large (1024)
* `ShadBreakpointXL()` - Extra Large (1280)
* `ShadBreakpointXXL()` - Extra Extra Large (1536)

**Breakpoint Values (via `ShadTheme.of(context).breakpoints`):**

* `bp.tn` - Tiny (0)
* `bp.sm` - Small (640)
* `bp.md` - Medium (768)
* `bp.lg` - Large (1024)
* `bp.xl` - Extra Large (1280)
* `bp.xxl` - Extra Extra Large (1536)

**❌ FORBIDDEN:** Raw `MediaQuery.sizeOf(context).width` checks for responsive design. Use `ShadResponsiveBuilder` or `context.breakpoint` instead.

## 3. Accessibility (Trust by Default)

**Core Principle:** Shadcn widgets automatically provide semantic information from their `title`, `label`, `description`, `subtitle`, and `placeholder` properties. Flutter's accessibility system extracts this information automatically. **Trust by default.**

**When to Add Explicit Semantics:**

1. **Custom Widgets:** Only for widgets you build yourself that don't use Shadcn components
2. **Additional Context:** When you need to provide hints or labels beyond what Shadcn provides automatically
3. **Visual Text Mismatch:** When the visual text does not match the screen reader intent (e.g., icon-only button without tooltip)

**When NOT to Add Explicit Semantics:**

1. **Shadcn Widgets with Title/Label:** `ShadButton`, `ShadCard`, `ShadInput`, `ShadInputFormField`, `ShadSelect`, `ShadToaster` etc. already provide accessibility automatically
2. **Redundant Information:** Don't duplicate what the widget already announces
3. **Standard Use Cases:** For standard buttons, inputs, and cards with text labels, Shadcn handles accessibility automatically

### Widget-Specific Accessibility

**ShadButton:** Automatic from `child` Text content. No explicit `Semantics` wrapper needed in most cases.

```dart
// ✅ Correct: Automatic accessibility from Text content
ShadButton(
  onPressed: () {},
  child: const Text(Strings.confirm), // Text provides semantic label automatically
)
```

**ShadInput / ShadInputFormField:** Automatic from `label` property. Trust Shadcn's built-in accessibility.

```dart
// ✅ Correct: Automatic accessibility from label property
ShadInputFormField(
  id: 'code',
  label: const Text(Strings.codeLabel), // Provides semantic label automatically
  placeholder: const Text(Strings.codePlaceholder),
  validator: (v) => v.isEmpty ? Strings.errorRequired : null,
)
```

**ShadSelect:** Automatic from `placeholder`/`label` and selected value display.

```dart
// ✅ Correct: Automatic accessibility from placeholder and value
ShadSelect<String>(
  placeholder: const Text(Strings.themeSelector), // Provides semantic context automatically
  value: selectedValue,
  options: [
    ShadOption(value: 'light', child: Text(Strings.light)),
    ShadOption(value: 'dark', child: Text(Strings.dark)),
  ],
  onChanged: (value) => updateTheme(value),
)
```

**ShadToaster:** Automatic focus management for toast notifications.

```dart
// ✅ Correct: Automatic focus management
ShadToaster.of(context).show(
  ShadToast(
    title: Text(Strings.success),
    description: Text(Strings.savedSuccessfully),
    icon: Icon(LucideIcons.check),
  ),
);
```

**Decorative Icons:** Wrap decorative-only icons with `ExcludeSemantics`.

```dart
// ✅ Correct: Decorative chevron
ShadCard(
  child: Row(
    mainAxisAlignment: MainAxisAlignment.end,
    children: [
      ExcludeSemantics(
        child: const Icon(LucideIcons.chevronRight), // Decorative only
      ),
    ],
  ),
)
```

### Focus Management

**FocusTraversalGroup:** Group related form fields for logical keyboard navigation.

```dart
// ✅ Correct: Form with grouped fields
FocusTraversalGroup(
  child: Column(
    children: [
      ShadInputFormField(
        id: 'name',
        label: const Text(Strings.nameLabel),
      ),
      ShadInputFormField(
        id: 'email',
        label: const Text(Strings.emailLabel),
      ),
    ],
  ),
)
```

### String Consistency

**CRITICAL:** All user-facing text (including button text, labels, placeholders) MUST use `Strings.dart` constants. This ensures both visual text and automatic semantic labels are consistent.

```dart
// ✅ Correct: Using Strings constants in Shadcn widgets (automatic semantics)
ShadButton(
  onPressed: () {},
  child: const Text(Strings.search), // Text provides semantic label automatically
)

// ❌ Forbidden: Hardcoded strings
ShadButton(
  onPressed: () {},
  child: const Text('Search'), // FORBIDDEN
)
```

## 4. Layout & Lists

### The Golden Rule of Constraints

**"Constraints go down. Sizes go up. Parent sets position."**

* **Constraint:** You generally cannot size a widget larger than its parent allows.
* **Overflow:** Occurs when a child demands more space than the parent allows.

### Flex Layout Safety (Column/Row)

**Unbounded Children:** NEVER place a widget with infinite size (e.g., `ListView`, `GridView`, `TextField` with `maxLines: null`) inside a `Column` or `Row` without constraints.

```dart
// ❌ BAD:
Column(
  children: [
    Text('Header'),
    ListView(...), // CRASH: Unbounded vertical height
  ],
)

// ✅ GOOD: Wrap in Expanded or Flexible
Column(
  children: [
    Text('Header'),
    Expanded(child: ListView(...)), // OK: Takes remaining space
  ],
)
```

**Text Overflow:** ALWAYS assume text will be longer than expected (localization, dynamic data).

```dart
// ❌ BAD: Text(data.title) inside a Row
// ✅ GOOD: Wrap in Expanded and handle overflow
Row(
  children: [
    Icon(...),
    Expanded(
      child: Text(
        data.title,
        overflow: TextOverflow.ellipsis, // Critical
        maxLines: 1,
      ),
    ),
  ],
)
```

### Sliver Protocol (MANDATORY)

**The Root Scrollable:** The root of every screen **MUST** be a `CustomScrollView` (Sliver Protocol).

* **❌ Forbidden:** `Scaffold` > `SingleChildScrollView` > `Column`. This legacy pattern handles keyboards poorly and prevents sticky headers.
* **✅ Mandatory:** `Scaffold` > `CustomScrollView`.

**List Nesting:** NEVER nest a `ListView` inside a `SingleChildScrollView`. It destroys performance and scrolling physics.

* **Solution:** Use **Slivers** with `CustomScrollView` to compose scrollable content efficiently.

### List Items (The "No Tile" Fix)

**Mandate:** Shadcn lacks a `ListTile`. Material `ListTile` and `CupertinoListTile` are **FORBIDDEN**. Use custom `Row` + `Expanded` + `ShadTheme` styling pattern.

```dart
// ✅ CORRECT: Custom Shadcn-styled Row
GestureDetector(
  onTap: onTap,
  child: Container(
    padding: const EdgeInsets.all(16),
    decoration: BoxDecoration(
      border: Border(bottom: BorderSide(color: theme.colorScheme.border)),
    ),
    child: Row(
      children: [
        Icon(LucideIcons.pill, color: theme.colorScheme.primary),
        const Gap(16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text('Title', style: theme.textTheme.base),
              Text('Subtitle', style: theme.textTheme.muted),
            ],
          ),
        ),
        Icon(LucideIcons.chevronRight, size: 16, color: theme.colorScheme.mutedForeground),
      ],
    ),
  ),
)
```

### Keyboard Handling

**Root Scaffold Keyboard Supremacy:** Only the Root `Scaffold` (Navigation Shell) sets `resizeToAvoidBottomInset: true`. All nested Page Scaffolds MUST set `resizeToAvoidBottomInset: false`.

**Bottom Sheet Keyboard Padding:** Bottom sheets must wrap content in `SingleChildScrollView`. `ShadSheet` handles keyboard avoidance natively, so manual padding calculations are unnecessary.

```dart
// ✅ GOOD: Simple structure with SingleChildScrollView
builder: (context) {
  return ShadSheet(
    title: Text(Strings.details),
    child: SingleChildScrollView(
      child: MyFormContent(),
    ),
  );
}
```

**Sliver Padding for Keyboard:** Use `SliverPadding` with `viewInsets` when needed in `CustomScrollView`.

```dart
CustomScrollView(
  slivers: [
    // ... content ...
    if (MediaQuery.viewInsetsOf(context).bottom > 0)
      SliverPadding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.viewInsetsOf(context).bottom,
        ),
      ),
  ],
)
```

**Form Scrolling:** All forms must be inside a scroll view (`CustomScrollView`). Do not use `Spacer()` inside a scrollable area. Use `SizedBox(height: ...)` or `SliverFillRemaining` instead.

### Performance Warnings

**Intrinsic Dimensions:** Avoid `IntrinsicHeight` and `IntrinsicWidth` whenever possible. They force an expensive double-layout pass.

* **Alternative:** Use `Row(crossAxisAlignment: CrossAxisAlignment.stretch)` to make children match heights.

## 5. Forms

**Mandate:** Use `ShadForm` with `GlobalKey<ShadFormState>` to handle validation and value retrieval automatically. Do NOT use manual `TextEditingController`s for standard form fields.

**Key Principles:**

* Use `useMemoized(() => GlobalKey<ShadFormState>())` for form keys in hooks
* All form fields MUST have unique `id` properties
* Use `saveAndValidate()` for submission validation
* Access values via `formKey.currentState!.value` (Map<String, dynamic>)
* Forbid manual `TextEditingController` management for standard forms

**Exception:** `TextEditingController` is acceptable for non-form inputs (e.g., search bars with real-time filtering) where you need direct access to the text value for debouncing or live updates.

```dart
// ✅ CORRECT: Using hooks with ShadForm
class MyForm extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formKey = useMemoized(() => GlobalKey<ShadFormState>());

    return ShadForm(
      key: formKey,
      child: Column(
        children: [
          ShadInputFormField(
            id: 'username', // Critical: Unique ID for value retrieval
            label: Text(Strings.username),
            placeholder: Text('Enter your username'),
            validator: (v) => v.length < 2 ? Strings.errorShort : null,
          ),
          ShadButton(
            onPressed: () {
              if (formKey.currentState!.saveAndValidate()) {
                final data = formKey.currentState!.value;
                final username = data['username'] as String;
                // Process data
              }
            },
            child: Text(Strings.submit),
          ),
        ],
      ),
    );
  }
}

// ❌ FORBIDDEN: Manual controller management
class BadForm extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = useTextEditingController(); // FORBIDDEN
    return ShadInput(
      controller: controller, // FORBIDDEN: Use ShadInputFormField with id instead
      onChanged: (v) => setState(() => _val = v), // FORBIDDEN
    );
  }
}
```

## 6. Components & Patterns

### Component Selection Protocol

| UI Need | Component to Use |
| :--- | :--- |
| **Scaffold** | `Scaffold` (Material) |
| **Button** | `ShadButton`, `ShadButton.outline`, `ShadButton.ghost` |
| **Icon Button** | `ShadIconButton` |
| **Card / Container** | `ShadCard` (Preferred) or `Container` with `ShadTheme` border |
| **Input** | `ShadInput` (Standalone) or `ShadInputFormField` (In Form) |
| **List Item** | `ShadCard` (Detail) or `Row` + `ShadTheme` styles (Dense) |
| **Badge** | `ShadBadge`, `ShadBadge.secondary`, `ShadBadge.outline` |
| **Toast** | `ShadToaster.of(context).show()` |
| **Dialog** | `showShadDialog` with `ShadDialog` or `ShadDialog.alert` |
| **Sheet** | `showShadSheet` (Side: `bottom` for mobile, `right` for desktop details) |

### Button Variants

```dart
// Primary (default)
ShadButton(
  onPressed: () {},
  child: const Text('Primary'),
)

// Secondary
ShadButton.secondary(
  onPressed: () {},
  child: const Text('Secondary'),
)

// Destructive
ShadButton.destructive(
  onPressed: () {},
  child: const Text('Destructive'),
)

// Outline
ShadButton.outline(
  onPressed: () {},
  child: const Text('Outline'),
)

// Ghost
ShadButton.ghost(
  onPressed: () {},
  child: const Text('Ghost'),
)
```

### Dialogs

```dart
// Standard dialog
showShadDialog(
  context: context,
  builder: (context) => ShadDialog(
    title: Text(Strings.confirmAction),
    description: Text(Strings.cannotBeUndone),
    actions: [
      ShadButton.outline(
        child: Text(Strings.cancel),
        onPressed: () => Navigator.of(context).pop(),
      ),
      ShadButton(
        child: Text(Strings.confirm),
        onPressed: () {
          // Perform action
          Navigator.of(context).pop();
        },
      ),
    ],
  ),
);

// Alert dialog
showShadDialog(
  context: context,
  builder: (context) => ShadDialog.alert(
    title: Text(Strings.areYouSure),
    description: Text(Strings.cannotBeUndone),
    actions: [
      ShadButton.outline(
        child: Text(Strings.cancel),
        onPressed: () => Navigator.of(context).pop(false),
      ),
      ShadButton(
        child: Text(Strings.continue),
        onPressed: () => Navigator.of(context).pop(true),
      ),
    ],
  ),
);
```

### Sheet & Overlay Patterns

**Mandate:** You **MUST** use `showShadSheet` directly for all sheet overlays. Custom wrappers (e.g., `AdaptiveOverlay`, `showAdaptiveSheet`) are **FORBIDDEN**.

**Sheet Side Configuration:**

* **Default:** Use `side: ShadSheetSide.bottom` for mobile-friendly bottom sheets (standard for forms, filters, details).
* **Desktop Details:** Use `side: ShadSheetSide.right` only when specifically designing desktop detail panels.

**Native Close Button Rule:** `ShadSheet` provides a native close button automatically when a `title` is provided. **NEVER** duplicate this by adding a close button in the `actions` array.

```dart
// ✅ CORRECT: Direct usage of showShadSheet
showShadSheet(
  context: context,
  side: ShadSheetSide.bottom,
  builder: (context) => ShadSheet(
    title: Text(Strings.details),
    description: Text(Strings.additionalInfo),
    actions: [
      ShadButton.outline(
        onPressed: () => Navigator.of(context).pop(),
        child: Text(Strings.cancel),
      ),
      ShadButton(
        onPressed: () {
          // Perform action
          Navigator.of(context).pop();
        },
        child: Text(Strings.confirm),
      ),
    ],
    child: SingleChildScrollView(
      child: Content(),
    ),
  ),
);

// ❌ FORBIDDEN: Custom wrapper functions
showAdaptiveSheet(context: context, builder: (context) => ...); // FORBIDDEN
```

### Cards

```dart
// Card with header, content, and footer
ShadCard(
  title: Text(Strings.createProject),
  description: Text(Strings.deployInOneClick),
  footer: Row(
    mainAxisAlignment: MainAxisAlignment.spaceBetween,
    children: [
      ShadButton.outline(
        child: Text(Strings.cancel),
        onPressed: () {},
      ),
      ShadButton(
        child: Text(Strings.deploy),
        onPressed: () {},
      ),
    ],
  ),
  child: Padding(
    padding: const EdgeInsets.symmetric(vertical: 16),
    child: Column(
      children: [
        // Content here
      ],
    ),
  ),
)
```

### High-Performance Tables

**Rule:** Choose the appropriate table implementation based on dataset size to ensure optimal performance.

* **Small Data (< 20 rows):** Use `ShadTable.list`. All children are created immediately, suitable for small static datasets.
* **Large Data (> 20 rows):** Use `ShadTable` with `builder`. This uses `two_dimensional_scrollables` for lazy rendering, ensuring only visible cells are built.

```dart
// ✅ CORRECT: Small static data
ShadTable.list(
  header: const [
    ShadTableCell.header(child: Text('Name')),
    ShadTableCell.header(child: Text('Status')),
  ],
  children: smallList.map((item) => [
    ShadTableCell(child: Text(item.name)),
    ShadTableCell(child: Text(item.status)),
  ]).toList(),
)

// ✅ CORRECT: Large dynamic data with lazy rendering
ShadTable(
  columnCount: 4,
  rowCount: largeList.length,
  header: (context, column) {
    return ShadTableCell.header(
      child: Text(headings[column]),
    );
  },
  builder: (context, index) {
    final data = largeList[index.row][index.column];
    return ShadTableCell(
      child: Text(data.toString()),
    );
  },
)
```

### Error UI Patterns

**Inline Error:** Use `ShadAlert` with destructive style.

```dart
ShadAlert.destructive(
  icon: Icon(LucideIcons.circleAlert),
  title: Text(Strings.error),
  description: Text(error.toString()),
)
```

**Full Screen Error:** Use a centered `ShadCard` with `ShadButton` for retry.

```dart
Center(
  child: ShadCard(
    title: Text(Strings.error),
    description: Text(Strings.unableToLoadData),
    child: ShadButton.icon(
      onPressed: () => retry(),
      icon: Icon(LucideIcons.refresh),
      child: Text(Strings.retry),
    ),
  ),
)
```

**Toast Error:** Use `ShadToaster` for transient errors.

```dart
ShadToaster.of(context).show(
  ShadToast(
    title: Text(Strings.actionFailed),
    description: Text(Strings.operationCouldNotBeCompleted),
    icon: Icon(LucideIcons.triangleAlert),
  ),
);
```

### Testing Pattern

**Test helpers must use `ShadApp.custom`:**

```dart
import 'package:shadcn_ui/shadcn_ui.dart';

extension PumpApp on WidgetTester {
  Future<void> pumpApp(Widget widget) async {
    await pumpWidget(
      ProviderScope(
        child: ShadApp.custom(
          theme: ShadThemeData(
            brightness: Brightness.light,
            colorScheme: const ShadGreenColorScheme.light(),
          ),
          appBuilder: (context) {
            return MaterialApp.router(
              routerConfig: appRouter.config(),
              builder: (context, child) => ShadAppBuilder(child: child!),
            );
          },
        ),
      ),
    );
  }
}
```

## 7. Anti-Patterns

### 1. The "Smart Wrapper" Anti-Pattern (Strictly Forbidden)

**Definition:** Creating a custom widget or utility function that wraps a library widget (like `ShadSheet`, `ShadDialog`) just to apply default padding, scrolling, or layout logic.

**Why it fails:** It couples *presentation* (the sheet) with *layout* (scrolling/padding), causing issues like "white blocs" behind keyboards and making the underlying API inaccessible.

**Legacy Forbidden Patterns:**

* **`AdaptiveOverlay` / `showAdaptiveSheet`:** This custom utility that switches between `showModalBottomSheet` and `showShadDialog` based on screen size is **FORBIDDEN**. Use `showShadSheet` directly with `side: ShadSheetSide.bottom` for consistent mobile-friendly sheets. This is the native Shadcn way to handle responsive drawers/sheets.

**❌ BAD (Forbidden):**

```dart
// Hides the underlying API, enforces scrolling where it might not be needed
Future<void> showMySheet(Widget child) {
  return showShadSheet(
    builder: (_) => SingleChildScrollView( // <--- FORBIDDEN: Enforced layout
      padding: EdgeInsets.all(16),         // <--- FORBIDDEN: Enforced padding
      child: child,
    ),
  );
}
```

**✅ GOOD (Allowed):**

```dart
// Pure dispatcher. The caller handles layout.
Future<void> showSheet(WidgetBuilder builder) {
  return showShadSheet(
    builder: builder, // Direct pass-through
  );
}

// Caller usage:
showSheet(
  (context) => SingleChildScrollView(child: MyContent()),
);
```

### 2. The "Layout Manager" Anti-Pattern

**Definition:** A parent widget calculating padding based on `MediaQuery` for its children, instead of letting children handle their own safe areas or insets.

**Rule:** **Content owns Layout.**

* A `Sheet` should not know about the keyboard. The `Form` inside the sheet should handle the keyboard.
* A `Card` should not handle scrolling. The `ListView` containing the card handles scrolling.

**Rule:**

* Use `showShadSheet` / `showShadDialog` directly in the UI code. This is the native Shadcn way.
* Use `showShadSheet` with the `side` parameter (`ShadSheetSide.bottom`, `ShadSheetSide.right`, etc.) to control sheet positioning. Do not manually calculate sheet sizing.
* If you need a dispatcher (mobile vs desktop), it must pass properties through *transparently* without adding layout widgets.
* **Exception:** Only use `DraggableScrollableSheet` when you specifically need a drag handle that snaps to percentages (e.g., a resizable bottom panel). For standard forms, use `SingleChildScrollView` with keyboard padding.

### 3. The "Manual Form State" Anti-Pattern

**Definition:** Manually creating `TextEditingController`s, `FocusNode`s, and `setState` variables for standard form fields when using `ShadInput`.

**Why it fails:** It adds unnecessary boilerplate and defeats the purpose of `ShadForm`'s automatic data aggregation and validation. `ShadForm` with `GlobalKey<ShadFormState>` is the **ONLY** allowed way to handle form submission and validation. `ShadForm` with `ShadInputFormField` handles all of this automatically through the `id`-based value system and `saveAndValidate()` method.

**❌ BAD (Forbidden):**

```dart
// Manual controller management defeats ShadForm's purpose
class BadForm extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = useTextEditingController(); // FORBIDDEN
    final focusNode = useFocusNode(); // FORBIDDEN
    final value = useState(''); // FORBIDDEN
    
    return ShadInput(
      controller: controller, // FORBIDDEN
      focusNode: focusNode, // FORBIDDEN
      onChanged: (v) => value.value = v, // FORBIDDEN: Manual state management
    );
    // Manual validation logic...
  }
}
```

**✅ GOOD (Allowed):**

```dart
// ShadForm with GlobalKey<ShadFormState> is the ONLY allowed way to handle form submission and validation
class GoodForm extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formKey = useMemoized(() => GlobalKey<ShadFormState>());
    
    return ShadForm(
      key: formKey,
      child: Column(
        children: [
          ShadInputFormField(
            id: 'field_id', // Critical: Unique ID
            label: Text(Strings.fieldLabel),
            validator: (v) => v.isEmpty ? Strings.errorRequired : null,
          ),
          ShadButton(
            onPressed: () {
              if (formKey.currentState!.saveAndValidate()) {
                final data = formKey.currentState!.value;
                final fieldValue = data['field_id'] as String;
                // Process data
              }
            },
            child: Text(Strings.submit),
          ),
        ],
      ),
    );
  }
}
```

**Exception:** `TextEditingController` is acceptable for non-form inputs (e.g., search bars with real-time filtering) where you need direct access to the text value for debouncing or live updates. However, if the search is part of a form submission, use `ShadInputFormField` instead.
