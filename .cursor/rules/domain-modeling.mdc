---
description: Extension Types for zero-cost domain abstractions and ID types
alwaysApply: false
---
# Domain Modeling (2025 Standard)

## Extension Types Pattern

**Core Principle:** UI must NEVER consume raw database rows. Use Extension Types for zero-cost abstraction.

**Benefits:**

- Zero runtime overhead (compile-time only)
- Decouples UI from database schema
- Type safety without allocation
- Direct interface implementation (`implements`) reduces boilerplate

## Wrapping Database Rows

```dart
// ✅ Extension Type wrapping Drift class (generic example)
extension type ProductEntity(ProductSummaryData _data) {
  String get name => _data.name;
  String get category => _data.category ?? '';
  bool get isFeatured => _data.isFeatured;

  // Computed properties
  String get displayName => name;
  bool get hasTags => _data.tags.isNotEmpty;

  factory ProductEntity.fromData(ProductSummaryData data) {
    return ProductEntity(data);
  }
}

// Usage in Provider
@riverpod
Stream<List<ProductEntity>> products(Ref ref, String query) {
  final dao = ref.watch(productDaoProvider);
  return dao.watchProducts(query).map((rows) {
    return rows.map(ProductEntity.fromData).toList();
  });
}
```

## ID Types (Eliminate Primitive Obsession)

```dart
// ✅ Strongly-typed IDs with validation
extension type ProductId(String _value) implements String {
  ProductId(this._value) : assert(_value.isNotEmpty, 'ProductId required');

  @override
  String toString() => _value;
}

extension type OrderId(String _value) implements String {
  OrderId(this._value) : assert(_value.length == 8, 'OrderId must be 8 chars');

  @override
  String toString() => _value;
}

// Usage
final id = ProductId('SKU-123'); // ✅ Valid
// final invalid = OrderId('123'); // ❌ Assertion error (debug)
```

## Semantic Types (Guaranteed Invariants)

```dart
// ✅ Type guarantees normalization (search-specific, lightweight)
extension type NormalizedQuery(String _value) implements String {
  factory NormalizedQuery(String input) {
    final normalized = normalizeForSearch(input);
    return NormalizedQuery._(normalized);
  }

  NormalizedQuery._(this._value);

  @override
  String toString() => _value;
}

// Usage in DAO
Future<List<Data>> searchProducts(
  NormalizedQuery query, // ✅ Already normalized for search
) async {
  return _performSearch(query);
}
```

## Architecture Layers

- **Database Layer:** DAOs return raw Drift classes
- **Domain Layer:** Extension Types wrap Drift classes (in `lib/features/*/domain/entities/`)
- **Presentation Layer:** UI consumes only Extension Types

## Rules

- **ALLOWED:** Accessing raw Drift fields via `.data` or `implements` for read-only display
- **FORBIDDEN:** Traditional DTOs/ViewModels with allocation
- **REQUIRED:** All DB rows wrapped in Extension Types before UI exposure
- **REQUIRED:** Location `lib/features/*/domain/entities/`
- **PREFERRED:** Use `implements` on Extension Types when wrapping a single class

## Extension Types vs Dart Extensions

- **Extension Types:** Wrap entire DB rows (domain entities)
- **Dart Extensions (`extension on`):** Add utility methods to existing types

## Anti-Patterns

- ❌ Raw Drift classes in UI
- ❌ Traditional POJOs mirroring DB rows 1:1
- ❌ "Passthrough" classes without logic (DELETE them)
- ✅ Extension Types for zero-cost abstraction
- ✅ Strong ID types
- ✅ Semantic guarantees via factory constructors

## Safety for Semantic/ID Types

- **FORBIDDEN:** Unchecked `as` casts when constructing extension types (`ProductId`, `OrderId`, `GroupId`, `NormalizedQuery`, etc.).
- **REQUIRED:** Use private constructors or validated factories (e.g., `NormalizedQuery._(...)`, `ProductId.validated(...)`) so invariants are enforced without runtime casts.
