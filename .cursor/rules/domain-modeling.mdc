---
alwaysApply: false
description: Extension Types for zero-cost domain abstractions and ID types
---

# Domain Modeling Standards (2025)

## 1. Entities (Persistent Data)
- **MUST** use **Extension Types** wrapping generated Drift classes.
- **NEVER** duplicate database fields in a manual Dart class.
- **WHY:** Ensures zero runtime overhead and strict compile-time sync with DB schema.

Implementation:
```dart
extension type MedicamentEntity(MedicamentSummaryData _data) {
  factory MedicamentEntity.fromData(MedicamentSummaryData data) => MedicamentEntity(data);
  String get name => _data.nomCanonique;
}
```

## 2. Ephemeral Data (UI/State)
- **MUST** use **Named Records** (typedefs) for:
  - Repository arguments/responses
  - Dialog results
  - Simple composite state (e.g., `({T data, bool isLoading})`)
- **WHY:** Structural typing reduces boilerplate and testing surface area.

## 3. Ad-Hoc Queries
- **MUST** return Records for JOINs (e.g., `({MedicamentEntity med, Stock stock})`).
- **FORBIDDEN:** Creating "Projection Classes" just for one query.

## 4. ID Types (Eliminate Primitive Obsession)
- **REQUIRED:** Validation guarantees (e.g., `Cip13.validated(...)`).
- **FORBIDDEN:** Unchecked `as` casts.

## 5. UI State Modeling
- **Sealed Classes:** For mutually exclusive states (e.g., `Initial | Loading | Data | Error`).
- **Exhaustive Matching:** Use Dart 3 `switch` expressions.

## Architecture Layers
- **Database Layer:** DAOs return raw Drift classes.
- **Domain Layer:** Extension Types wrap Drift classes.
- **Presentation Layer:** UI consumes only Extension Types/Records.
