
---

description: Extension Types for zero-cost domain abstractions and ID types
globs: lib/**/domain/**/*.dart, lib/core/database/**/*.dart
alwaysApply: false
---

# Domain Modeling (2025 Standard)

## Extension Types Pattern

**Core Principle:** UI must NEVER consume raw database rows. Use Extension Types for zero-cost abstraction.

**Benefits:**

- Zero runtime overhead (compile-time only)
- Decouples UI from database schema
- Type safety without allocation

## Wrapping Database Rows

```
// ✅ Extension Type wrapping Drift class
extension type MedicamentEntity(MedicamentSummaryData _data) {
  String get canonicalName => _data.nomCanonique;
  String get pharmaceuticalForm => _data.formePharmaceutique ?? '';
  bool get isPrinceps => _data.isPrinceps;
  
  // Computed properties
  String get displayName => canonicalName;
  bool get hasCommonPrinciples => _data.principesActifsCommuns.isNotEmpty;
  
  factory MedicamentEntity.fromData(MedicamentSummaryData data) {
    return MedicamentEntity(data);
  }
}

// Usage in Provider
@riverpod
Stream<List<MedicamentEntity>> medicaments(Ref ref, String query) {
  final dao = ref.watch(catalogDaoProvider);
  return dao.watchMedicaments(query).map((summaries) {
    return summaries.map(MedicamentEntity.fromData).toList();
  });
}
```

## ID Types (Eliminate Primitive Obsession)

```
// ✅ Strongly-typed IDs with validation
extension type Cip13(String _value) implements String {
  Cip13(this._value) 
    : assert(_value.length == 13, 'CIP must be 13 digits');
  
  @override
  String toString() => _value;
}

extension type CisCode(String _value) implements String {
  CisCode(this._value) 
    : assert(_value.length == 8, 'CIS must be 8 digits');
  
  @override
  String toString() => _value;
}

// Usage
final cip = Cip13('3401360000123'); // ✅ Valid
// final invalid = Cip13('123'); // ❌ Assertion error (debug)
```

## Semantic Types (Guaranteed Invariants)

```
// ✅ Type guarantees normalization
extension type NormalizedQuery(String _value) implements String {
  factory NormalizedQuery(String input) {
    final normalized = normalizePrincipleOptimal(input);
    return NormalizedQuery._(normalized);
  }
  
  NormalizedQuery._(this._value);
  
  @override
  String toString() => _value;
}

// Usage in DAO
Future<List<Data>> searchMedicaments(
  NormalizedQuery query, // ✅ Guaranteed normalized
) async {
  return _performSearch(query); // No re-normalization needed
}
```

## Architecture Layers

- **Database Layer:** DAOs return raw Drift classes
- **Domain Layer:** Extension Types wrap Drift classes (in `lib/features/*/domain/entities/`)
- **Presentation Layer:** UI consumes only Extension Types

## Rules

- **FORBIDDEN:** Raw Drift classes in UI widgets
- **FORBIDDEN:** Traditional DTOs/ViewModels with allocation
- **REQUIRED:** All DB rows wrapped in Extension Types before UI exposure
- **REQUIRED:** Location `lib/features/*/domain/entities/`

## Extension Types vs Dart Extensions

- **Extension Types:** Wrap entire DB rows (domain entities)
- **Dart Extensions (`extension on`):** Add utility methods to existing types

## Anti-Patterns

- ❌ Raw Drift classes in UI
- ❌ Traditional POJOs mirroring DB rows 1:1
- ❌ "Passthrough" classes without logic (DELETE them)
- ✅ Extension Types for zero-cost abstraction
- ✅ Strong ID types
- ✅ Semantic guarantees via factory constructors
