---
description: QA protocols, testing patterns, mocking strategy, and quality gates
globs: test/**/*.dart, integration_test/**/*.dart
alwaysApply: false
---

# QA & Testing (2025 Standard)

## Quality Gate (Run Before Every Commit)

```
dart run build_runner build --delete-conflicting-outputs
dart fix --apply
dart analyze --fatal-infos --fatal-warnings
flutter test
```

**Auto-Fix Discipline:** If analyzer surfaces fixable warnings, run `dart fix --apply` (up to 3x) before manual review.

## Mocking Strategy

**Library:** `mocktail` exclusively (FORBIDDEN: `mockito`)

```
import 'package:mocktail/mocktail.dart';

class MockDatabaseService extends Mock implements DatabaseService {}

void main() {
  late MockDatabaseService database;
  
  setUp(() {
    database = MockDatabaseService();
    registerFallbackValue(const ItemSummary());
  });
  
  test('returns empty list', () async {
    when(() => database.fetchItems()).thenAnswer((_) async => []);
    // ...
  });
}
```

## Robot Pattern (Complex Flows)

**When to Use:** Multi-step flows reused across tests

**When NOT to Use:** Simple tests (use direct finders)

```
// ✅ Complex flow: Robot pattern
class ExplorerRobot {
  ExplorerRobot(this.tester);
  final WidgetTester tester;
  
  Future<void> searchFor(String term) async { ... }
  void expectResultCount(int count) { ... }
}

testWidgets('full search flow', (tester) async {
  final robot = ExplorerRobot(tester);
  await robot.searchFor('Test Query');
  robot.expectResultCount(5);
});

// ✅ Simple test: Direct finders
testWidgets('displays item name', (tester) async {
  await tester.pumpWidget(MyWidget(item: testItem));
  expect(find.text('Test Item'), findsOneWidget);
});
```

## String Literals Ban

**FORBIDDEN:** String literals in `find.text()`, `find.byTooltip()`, `find.bySemanticsLabel()`

**REQUIRED:** Use `Strings.*` constants

```
// ❌ FORBIDDEN
expect(find.text('Search'), findsOneWidget);

// ✅ REQUIRED
import 'package:your_app/core/utils/strings.dart';
expect(find.text(Strings.search), findsOneWidget);
```

## Layout Resilience Tests

```
testWidgets('adapts to narrow screen', (tester) async {
  await tester.binding.setSurfaceSize(const Size(400, 800));
  await tester.pumpWidget(MyWidget());
  expect(find.byType(MyWidget), findsOneWidget);
});

testWidgets('adapts to wide screen', (tester) async {
  await tester.binding.setSurfaceSize(const Size(1000, 800));
  await tester.pumpWidget(MyWidget());
  // Verify layout changes appropriately
});
```

## Anti-Patterns

- ❌ String literals in tests (use `Strings.*`)
- ❌ `mockito` (use `mocktail`)
- ❌ Over-engineering simple tests with Robots
- ✅ Robot pattern for complex flows
- ✅ Direct finders for simple tests
- ✅ `Strings.*` for all text expectations
