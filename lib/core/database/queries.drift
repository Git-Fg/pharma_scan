import 'database.dart';
import 'views.drift';
import 'tables/scanned_boxes.dart';

-- Queries for MedicamentSummary table
getMedicamentSummaryByCis: SELECT * FROM medicament_summary WHERE cis_code = ?;
getAllMedicamentSummaries: SELECT * FROM medicament_summary ORDER BY nom_canonique;
getMedicamentSummariesByGroup: SELECT * FROM medicament_summary WHERE group_id = ? ORDER BY is_princeps DESC, nom_canonique;
getDistinctPrincipesActifsCommuns: SELECT DISTINCT principes_actifs_communs FROM medicament_summary WHERE principes_actifs_communs != '' ORDER BY principes_actifs_communs;

-- FTS search with optional filters for route and ATC class.
searchMedicaments:
SELECT ms.*, l.name AS lab_name
FROM medicament_summary ms
LEFT JOIN laboratories l ON l.id = ms.titulaire_id
INNER JOIN search_index si ON ms.cis_code = si.cis_code
WHERE search_index MATCH :fts
  AND (:routeFilter = '' OR ms.voies_administration LIKE '%' || :routeFilter || '%')
  AND (:atcFilter = '' OR ms.atc_code LIKE :atcFilter || '%')
  AND (:labFilter = -1 OR ms.titulaire_id = :labFilter)
ORDER BY bm25(search_index) ASC, ms.nom_canonique
LIMIT 50;

-- Scan history (reverse chronological, limited)
getScanHistory:
SELECT 
    sb.cip,
    sb.scanned_at,
    COALESCE(ms.nom_canonique, 'Produit inconnu') AS label,
    ms.princeps_de_reference,
    ms.is_princeps
FROM scanned_boxes sb
LEFT JOIN medicaments m ON m.code_cip = sb.cip
LEFT JOIN medicament_summary ms ON ms.cis_code = m.cis_code
ORDER BY sb.scanned_at DESC
LIMIT :limit;

CREATE VIRTUAL TABLE search_index USING fts5(
  cis_code UNINDEXED,
  molecule_name,
  brand_name,
  tokenize='trigram'
);

-- Helpers to manage the search index directly from SQL
deleteSearchIndex: DELETE FROM search_index;

insertSearchIndexFromSummary:
INSERT INTO search_index (
  cis_code,
  molecule_name,
  brand_name
)
SELECT
  ms.cis_code,
  normalize_text(COALESCE(ms.nom_canonique, '')) AS molecule_name,
  normalize_text(COALESCE(ms.princeps_de_reference, '')) AS brand_name
FROM medicament_summary ms;

CREATE VIEW detailed_scan_results AS
SELECT
  m.code_cip,
  m.cis_code,
  s.nom_specialite,
  s.procedure_type AS specialite_procedure_type,
  s.forme_pharmaceutique,
  COALESCE(ls.name, ls2.name) AS specialite_titulaire,
  s.conditions_prescription AS specialite_conditions_prescription,
  ms.group_id,
  ms.is_princeps,
  ms.nom_canonique,
  ms.principes_actifs_communs,
  ms.princeps_de_reference,
  ms.princeps_brand_name,
  ms.forme_pharmaceutique AS summary_forme_pharmaceutique,
  ms.procedure_type AS summary_procedure_type,
  COALESCE(ls.name, ls2.name) AS summary_titulaire,
  ms.conditions_prescription AS summary_conditions_prescription
FROM medicaments m
INNER JOIN specialites s ON s.cis_code = m.cis_code
INNER JOIN medicament_summary ms ON ms.cis_code = m.cis_code
LEFT JOIN laboratories ls ON ls.id = ms.titulaire_id
LEFT JOIN laboratories ls2 ON ls2.id = s.titulaire_id;

-- Aggregation queries for populating medicament_summary table
-- These queries are validated at compile time against the schema
deleteMedicamentSummaries: DELETE FROM medicament_summary;

-- Insert grouped medications from view_aggregated_grouped view.
-- The view contains all the aggregation logic with CTEs for compile-time validation.
insertGroupedMedicamentSummaries:
INSERT OR REPLACE INTO medicament_summary (
  cis_code,
  nom_canonique,
  is_princeps,
  group_id,
  member_type,
  principes_actifs_communs,
  princeps_de_reference,
  forme_pharmaceutique,
  voies_administration,
  princeps_brand_name,
  procedure_type,
  titulaire_id,
  conditions_prescription,
  date_amm,
  is_surveillance,
  formatted_dosage,
  atc_code,
  status,
  price_min,
  price_max,
  aggregated_conditions,
  ansm_alert_url,
  is_hospital,
  is_dental,
  is_list1,
  is_list2,
  is_narcotic,
  is_exception,
  is_restricted,
  is_otc
)
SELECT * FROM view_aggregated_grouped;

-- Insert standalone medications from view_aggregated_standalone view.
-- The view contains all the aggregation logic with CTEs for compile-time validation.
insertStandaloneMedicamentSummaries:
INSERT OR REPLACE INTO medicament_summary (
  cis_code,
  nom_canonique,
  is_princeps,
  group_id,
  member_type,
  principes_actifs_communs,
  princeps_de_reference,
  forme_pharmaceutique,
  voies_administration,
  princeps_brand_name,
  procedure_type,
  titulaire_id,
  conditions_prescription,
  date_amm,
  is_surveillance,
  formatted_dosage,
  atc_code,
  status,
  price_min,
  price_max,
  aggregated_conditions,
  ansm_alert_url,
  is_hospital,
  is_dental,
  is_list1,
  is_list2,
  is_narcotic,
  is_exception,
  is_restricted,
  is_otc,
  representative_cip
)
SELECT * FROM view_aggregated_standalone;

getMedicamentSummaryCount: SELECT COUNT(*) AS count FROM medicament_summary;

-- Cross-validation query: Get Type 0 (princeps) member names for a group
-- Returns the shortest nom_specialite as fallback if parsed princepsLabel doesn't match
getPrincepsNamesForGroup:
SELECT
  gg.group_id,
  gg.princeps_label AS parsed_princeps,
  MIN(s.nom_specialite) AS shortest_name,
  COUNT(*) AS match_count
FROM generique_groups gg
INNER JOIN group_members gm ON gg.group_id = gm.group_id
INNER JOIN medicaments m ON gm.code_cip = m.code_cip
INNER JOIN specialites s ON m.cis_code = s.cis_code
WHERE gm.type = 0
  AND gg.group_id = :groupId
GROUP BY gg.group_id, gg.princeps_label
HAVING (
  -- Check if parsed_princeps appears in any Type 0 member name (normalized LIKE)
  gg.princeps_label IS NULL
  OR NOT EXISTS (
    SELECT 1
    FROM group_members gm2
    INNER JOIN medicaments m2 ON gm2.code_cip = m2.code_cip
    INNER JOIN specialites s2 ON m2.cis_code = s2.cis_code
    WHERE gm2.group_id = gg.group_id
      AND gm2.type = 0
      AND normalize_text(s2.nom_specialite) LIKE '%' || normalize_text(gg.princeps_label) || '%'
  )
);

-- Query to get all groups with the same active principles as a target group
-- Uses self-join on principes_actifs_communs to find related groups
-- Always includes the target group itself, even if it has no principes_actifs_communs
getGroupsWithSamePrinciples:
SELECT vgd.*
FROM view_group_details vgd
WHERE vgd.group_id = :targetGroupId
   OR vgd.group_id IN (
    SELECT DISTINCT ms2.group_id
    FROM medicament_summary ms1
    INNER JOIN medicament_summary ms2 
        ON ms1.principes_actifs_communs = ms2.principes_actifs_communs
    WHERE ms1.group_id = :targetGroupId
      AND ms1.principes_actifs_communs IS NOT NULL
      AND ms1.principes_actifs_communs != '[]'
      AND ms1.principes_actifs_communs != ''
      AND ms2.group_id IS NOT NULL
      AND ms2.group_id != ''
      AND ms2.group_id != :targetGroupId
  )
ORDER BY vgd.is_princeps DESC, vgd.nom_canonique ASC;

-- Query to find related therapies (superset groups)
-- Finds groups where target principles are a SUBSET of candidate principles
getRelatedTherapies:
SELECT DISTINCT vgd.*
FROM view_group_details vgd
INNER JOIN medicament_summary ms ON vgd.group_id = ms.group_id
WHERE vgd.group_id != :targetGroupId
  AND vgd.is_princeps = 1
  AND ms.principes_actifs_communs IS NOT NULL
  AND ms.principes_actifs_communs != '[]'
  AND ms.principes_actifs_communs != ''
  AND json_array_length(ms.principes_actifs_communs) > :targetLength
  AND NOT EXISTS (
    SELECT 1
    FROM json_each(:targetPrinciples) as target
    WHERE target.value NOT IN (
      SELECT value FROM json_each(ms.principes_actifs_communs)
    )
  )
ORDER BY vgd.princeps_de_reference ASC;

-- Batch update for princeps and molecule labels using SQL (no Dart loops).
refineGroupMetadata:
UPDATE generique_groups
SET
  princeps_label = COALESCE(
    NULLIF(princeps_label, ''),
    (
      SELECT name FROM (
        SELECT s.nom_specialite AS name
        FROM group_members gm
        INNER JOIN medicaments m ON gm.code_cip = m.code_cip
        INNER JOIN specialites s ON m.cis_code = s.cis_code
        WHERE gm.group_id = generique_groups.group_id
          AND gm.type = 0
          AND s.nom_specialite IS NOT NULL
          AND s.nom_specialite != ''
        ORDER BY LENGTH(s.nom_specialite), s.nom_specialite
        LIMIT 1
      )
    )
  ),
  molecule_label = COALESCE(
    NULLIF(molecule_label, ''),
    NULLIF(
      TRIM(libelle),
      ''
    )
  );
