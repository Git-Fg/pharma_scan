import 'database.dart';
import 'reference_schema.drift';
import 'user_schema.drift';
import 'views.drift';

-- Queries for MedicamentSummary table - using traditional SELECT * (for compatibility)
-- New modern approach uses ** operator for automatic mapping, see examples below

-- FTS search with optional filters for route and ATC class.
-- UPDATE: Utilisation de ms.** pour mapper automatiquement vers MedicamentSummaryData
searchMedicaments:
SELECT ms.**, l.name AS lab_name
FROM medicament_summary ms
LEFT JOIN laboratories l ON l.id = ms.titulaire_id
INNER JOIN search_index si ON ms.cis_code = si.cis_code
WHERE search_index MATCH :fts
  AND (:routeFilter = '' OR ms.voies_administration LIKE '%' || :routeFilter || '%')
  AND (:atcFilter = '' OR ms.atc_code LIKE :atcFilter || '%')
  AND (:labFilter = -1 OR ms.titulaire_id = :labFilter)
ORDER BY bm25(search_index) ASC, ms.nom_canonique
LIMIT 50;

-- FTS search for streaming.
-- UPDATE: Utilisation de ms.**
watchMedicaments:
SELECT ms.**, l.name AS lab_name
FROM medicament_summary ms
LEFT JOIN laboratories l ON l.id = ms.titulaire_id
INNER JOIN search_index si ON ms.cis_code = si.cis_code
WHERE search_index MATCH :fts
  AND (:routeFilter = '' OR ms.voies_administration LIKE '%' || :routeFilter || '%')
  AND (:atcFilter = '' OR ms.atc_code LIKE :atcFilter || '%')
  AND (:labFilter = -1 OR ms.titulaire_id = :labFilter)
ORDER BY bm25(search_index) ASC, ms.nom_canonique
LIMIT 50;

-- Scan query
-- UPDATE: Utilisation de ms.**
getProductByCip:
SELECT
  m.code_cip,
  m.cis_code,
  m.prix_public,
  m.taux_remboursement,
  m.commercialisation_statut,
  m.agrement_collectivites,
  m.presentation_label,
  ma.statut AS availability_statut,
  ms.**, -- Mappe automatiquement toutes les colonnes de ms vers MedicamentSummaryData
  ls.name AS lab_name
FROM medicaments m
INNER JOIN medicament_summary ms ON ms.cis_code = m.cis_code
LEFT JOIN laboratories ls ON ls.id = ms.titulaire_id
LEFT JOIN medicament_availability ma ON ma.code_cip = m.code_cip
WHERE m.code_cip = :cipCode
LIMIT 1;


-- Scan history (reverse chronological, limited)
-- Utilise la structure du schÃ©ma SQL distant : scanned_boxes avec cip_code et scan_timestamp
getScanHistory:
SELECT 
    sb.cip_code AS cip,
    datetime(sb.scan_timestamp) AS scanned_at,
    COALESCE(ms.nom_canonique, 'Produit inconnu') AS label,
    ms.princeps_de_reference,
    COALESCE(ms.is_princeps, 0) AS is_princeps
FROM scanned_boxes sb
LEFT JOIN medicaments m ON m.code_cip = sb.cip_code
LEFT JOIN medicament_summary ms ON ms.cis_code = m.cis_code
ORDER BY sb.scan_timestamp DESC
LIMIT :limit;

-- Helpers to manage the search index directly from SQL
-- Note: search_index table is defined in dbschema.drift
deleteSearchIndex: DELETE FROM search_index;

insertSearchIndexFromSummary:
INSERT INTO search_index (
  cis_code,
  molecule_name,
  brand_name
)
SELECT
  ms.cis_code,
  normalize_text(COALESCE(ms.nom_canonique, '')) AS molecule_name,
  normalize_text(COALESCE(ms.princeps_de_reference, '')) AS brand_name
FROM medicament_summary ms;

-- SIMPLIFIED: medicament_summary already contains all specialite data
-- No need to join with specialites table
CREATE VIEW detailed_scan_results AS
SELECT
  m.code_cip,
  m.cis_code,
  ms.nom_canonique AS nom_specialite,  -- Use nom_canonique from medicament_summary
  ms.procedure_type AS specialite_procedure_type,
  ms.forme_pharmaceutique,
  ls.name AS specialite_titulaire,  -- Single source from medicament_summary.titulaire_id
  ms.conditions_prescription AS specialite_conditions_prescription,
  ms.group_id,
  ms.is_princeps,
  ms.nom_canonique,
  ms.principes_actifs_communs,
  ms.princeps_de_reference,
  ms.princeps_brand_name,
  ms.forme_pharmaceutique AS summary_forme_pharmaceutique,
  ms.procedure_type AS summary_procedure_type,
  ls.name AS summary_titulaire,  -- Same as specialite_titulaire
  ms.conditions_prescription AS summary_conditions_prescription
FROM medicaments m
INNER JOIN medicament_summary ms ON ms.cis_code = m.cis_code
LEFT JOIN laboratories ls ON ls.id = ms.titulaire_id;


getMedicamentSummaryCount: SELECT COUNT(*) AS count FROM medicament_summary;

-- Cross-validation query: Get Type 0 (princeps) member names for a group
-- Returns the shortest nom_specialite as fallback if parsed princepsLabel doesn't match
getPrincepsNamesForGroup:
SELECT
  gg.group_id,
  gg.princeps_label AS parsed_princeps,
  MIN(s.nom_specialite) AS shortest_name,
  COUNT(*) AS match_count
FROM generique_groups gg
INNER JOIN group_members gm ON gg.group_id = gm.group_id
INNER JOIN medicaments m ON gm.code_cip = m.code_cip
INNER JOIN specialites s ON m.cis_code = s.cis_code
WHERE gm.type = 0
  AND gg.group_id = :groupId
GROUP BY gg.group_id, gg.princeps_label
HAVING (
  -- Check if parsed_princeps appears in any Type 0 member name (normalized LIKE)
  gg.princeps_label IS NULL
  OR NOT EXISTS (
    SELECT 1
    FROM group_members gm2
    INNER JOIN medicaments m2 ON gm2.code_cip = m2.code_cip
    INNER JOIN specialites s2 ON m2.cis_code = s2.cis_code
    WHERE gm2.group_id = gg.group_id
      AND gm2.type = 0
      AND normalize_text(s2.nom_specialite) LIKE '%' || normalize_text(gg.princeps_label) || '%'
  )
);

-- Query to get all groups with the same active principles as a target group
-- Uses self-join on principes_actifs_communs to find related groups
-- Always includes the target group itself, even if it has no principes_actifs_communs
getGroupsWithSamePrinciples:
SELECT vgd.*
FROM view_group_details vgd
WHERE vgd.group_id = :targetGroupId
   OR vgd.group_id IN (
    SELECT DISTINCT ms2.group_id
    FROM medicament_summary ms1
    INNER JOIN medicament_summary ms2 
        ON ms1.principes_actifs_communs = ms2.principes_actifs_communs
    WHERE ms1.group_id = :targetGroupId
      AND ms1.principes_actifs_communs IS NOT NULL
      AND ms1.principes_actifs_communs != '[]'
      AND ms1.principes_actifs_communs != ''
      AND ms2.group_id IS NOT NULL
      AND ms2.group_id != ''
      AND ms2.group_id != :targetGroupId
  )
ORDER BY vgd.is_princeps DESC, vgd.nom_canonique ASC;

-- Query to find related therapies (superset groups)
-- Finds groups where target principles are a SUBSET of candidate principles
getRelatedTherapies:
SELECT DISTINCT vgd.*
FROM view_group_details vgd
INNER JOIN medicament_summary ms ON vgd.group_id = ms.group_id
WHERE vgd.group_id != :targetGroupId
  AND vgd.is_princeps = 1
  AND ms.principes_actifs_communs IS NOT NULL
  AND ms.principes_actifs_communs != '[]'
  AND ms.principes_actifs_communs != ''
  AND json_array_length(ms.principes_actifs_communs) > :targetLength
  AND NOT EXISTS (
    SELECT 1
    FROM json_each(:targetPrinciples) as target
    WHERE target.value NOT IN (
      SELECT value FROM json_each(ms.principes_actifs_communs)
    )
  )
ORDER BY vgd.princeps_de_reference ASC;

-- SQL-First Mapping Example: Join medicaments with specialites using ** operator
-- This demonstrates the automatic mapping feature where m.** maps all columns from medicaments
-- and s.** maps all columns from specialites, creating strongly-typed result classes

-- Batch update for princeps and molecule labels using SQL (no Dart loops).
refineGroupMetadata:
UPDATE generique_groups
SET
  princeps_label = COALESCE(
    NULLIF(princeps_label, ''),
    (
      SELECT name FROM (
        SELECT s.nom_specialite AS name
        FROM group_members gm
        INNER JOIN medicaments m ON gm.code_cip = m.code_cip
        INNER JOIN specialites s ON m.cis_code = s.cis_code
        WHERE gm.group_id = generique_groups.group_id
          AND gm.type = 0
          AND s.nom_specialite IS NOT NULL
          AND s.nom_specialite != ''
        ORDER BY LENGTH(s.nom_specialite), s.nom_specialite
        LIMIT 1
      )
    )
  ),
  molecule_label = COALESCE(
    NULLIF(molecule_label, ''),
    NULLIF(
      TRIM(libelle),
      ''
    )
  );

-- Additional SQL-First Mapping Examples

-- Get detailed product information by CIP code with all joined data automatically mapped
getProductDetailsByCip:
SELECT
    m.**,         -- All medicament columns
    s.**,         -- All specialite columns
    l.name AS laboratory_name,  -- Laboratory name
    ms.nom_canonique AS summary_nom_canonique,
    ms.princeps_de_reference AS summary_princeps_ref,
    ms.principes_actifs_communs AS summary_principes
FROM medicaments m
INNER JOIN specialites s ON m.cis_code = s.cis_code
INNER JOIN medicament_summary ms ON m.cis_code = ms.cis_code
LEFT JOIN laboratories l ON l.id = s.titulaire_id
WHERE m.code_cip = :cipCode;

-- Get all products by laboratory with automatic mapping of all related data
getProductsByLaboratory:
SELECT
    m.**,         -- All medicament columns
    s.**,         -- All specialite columns
    ms.**         -- All medicament_summary columns
FROM medicaments m
INNER JOIN specialites s ON m.cis_code = s.cis_code
INNER JOIN medicament_summary ms ON m.cis_code = ms.cis_code
WHERE s.titulaire_id = :labId
ORDER BY s.nom_specialite;

-- Get availability information for products with automatic mapping
getProductAvailability:
SELECT
    m.**,         -- All medicament columns
    s.nom_specialite,
    ma.statut AS availability_status,
    ma.date_debut,
    ma.date_fin,
    ma.lien
FROM medicaments m
INNER JOIN specialites s ON m.cis_code = s.cis_code
LEFT JOIN medicament_availability ma ON ma.code_cip = m.code_cip
WHERE m.code_cip = :cipCode;
