import 'database.dart';
import 'reference_schema.drift';
import 'user_schema.drift';

-- Scan history (reverse chronological, limited)
-- Utilise la structure du schÃ©ma SQL distant : scanned_boxes avec cip_code et scan_timestamp
getScanHistory:
SELECT 
    sb.cip_code AS cip,
    datetime(sb.scan_timestamp) AS scanned_at,
    COALESCE(ms.nom_canonique, 'Produit inconnu') AS label,
    ms.princeps_de_reference,
    COALESCE(ms.is_princeps, 0) AS is_princeps
FROM scanned_boxes sb
LEFT JOIN medicaments m ON m.cip_code = sb.cip_code
LEFT JOIN medicament_summary ms ON ms.cis_code = m.cis_code
ORDER BY sb.scan_timestamp DESC
LIMIT :limit;



-- Query to get all groups with the same active principles as a target group
-- Uses self-join on principes_actifs_communs to find related groups
-- Always includes the target group itself, even if it has no principes_actifs_communs
getGroupsWithSamePrinciples:
SELECT ugd.*
FROM ui_group_details ugd
WHERE ugd.group_id = :targetGroupId
   OR ugd.group_id IN (
    SELECT DISTINCT ms2.group_id
    FROM medicament_summary ms1
    INNER JOIN medicament_summary ms2
        ON ms1.principes_actifs_communs = ms2.principes_actifs_communs
    WHERE ms1.group_id = :targetGroupId
      AND ms1.principes_actifs_communs IS NOT NULL
      AND ms1.principes_actifs_communs != '[]'
      AND ms1.principes_actifs_communs != ''
      AND ms2.group_id IS NOT NULL
      AND ms2.group_id != ''
      AND ms2.group_id != :targetGroupId
  )
ORDER BY ugd.is_princeps DESC, ugd.nom_canonique ASC;

-- Query to find related therapies (superset groups)
-- Finds groups where target principles are a SUBSET of candidate principles
getRelatedTherapies:
SELECT DISTINCT ugd.*
FROM ui_group_details ugd
INNER JOIN medicament_summary ms ON ugd.group_id = ms.group_id
WHERE ugd.group_id != :targetGroupId
  AND ugd.is_princeps = 1
  AND ms.principes_actifs_communs IS NOT NULL
  AND ms.principes_actifs_communs != '[]'
  AND ms.principes_actifs_communs != ''
  AND json_array_length(ms.principes_actifs_communs) > :targetLength
  AND NOT EXISTS (
    SELECT 1
    FROM json_each(:targetPrinciples) as target
    WHERE target.value NOT IN (
      SELECT value FROM json_each(ms.principes_actifs_communs)
    )
  )
ORDER BY ugd.princeps_de_reference ASC;



